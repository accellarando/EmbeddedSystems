ARM GAS  /tmp/ccMw3CGW.s 			page 1


   1              		.cpu cortex-m0
   2              		.arch armv6s-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"motor.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "Src/motor.c"
  18              		.section	.text.pwm_init,"ax",%progbits
  19              		.align	1
  20              		.global	pwm_init
  21              		.syntax unified
  22              		.code	16
  23              		.thumb_func
  25              	pwm_init:
  26              	.LFB44:
   1:Src/motor.c   **** /* ------------------------------------------------------------------------------------------------
   2:Src/motor.c   ****  *  Motor Control and Initialization Functions
   3:Src/motor.c   ****  * ------------------------------------------------------------------------------------------------
   4:Src/motor.c   ****  */
   5:Src/motor.c   **** #include "motor.h"
   6:Src/motor.c   **** 
   7:Src/motor.c   **** volatile int16_t error_integral = 0;    // Integrated error signal
   8:Src/motor.c   **** volatile uint8_t duty_cycle = 0;    	// Output PWM duty cycle
   9:Src/motor.c   **** volatile int16_t target_rpm = 0;    	// Desired speed target
  10:Src/motor.c   **** volatile int16_t motorl_speed = 0;   	// Measured left motor speed
  11:Src/motor.c   **** volatile int16_t motorr_speed = 0;   	// Measured left motor speed
  12:Src/motor.c   **** volatile int8_t adc_value = 0;      	// ADC measured motor current
  13:Src/motor.c   **** volatile int16_t error = 0;         	// Speed error signal
  14:Src/motor.c   **** volatile uint8_t Kp = 1;            	// Proportional gain
  15:Src/motor.c   **** volatile uint8_t Ki = 1;            	// Integral gain
  16:Src/motor.c   **** 
  17:Src/motor.c   **** // Sets up the entire motor drive system
  18:Src/motor.c   **** void motor_init(void) {
  19:Src/motor.c   ****     pwm_init();
  20:Src/motor.c   ****     encoder_init();
  21:Src/motor.c   ****     ADC_init();
  22:Src/motor.c   **** }
  23:Src/motor.c   **** 
  24:Src/motor.c   **** // Sets up the PWM and direction signals to drive the H-Bridge
  25:Src/motor.c   **** void pwm_init(void) {
  27              		.loc 1 25 21 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccMw3CGW.s 			page 2


  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
  26:Src/motor.c   **** 	//RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
  27:Src/motor.c   **** 	
  28:Src/motor.c   ****     // Set up pin PA4 for H-bridge PWM output (TIMER 14 CH1)
  29:Src/motor.c   **** 	/*
  30:Src/motor.c   ****     GPIOA->MODER |= (1 << 9);
  31:Src/motor.c   ****     GPIOA->MODER &= ~(1 << 8);
  32:Src/motor.c   **** 	
  33:Src/motor.c   **** 	  // Set up pin PB3 for H-bridge PWM output (TIMER 2 CH2)
  34:Src/motor.c   ****     GPIOB->MODER |= (1 << 7);
  35:Src/motor.c   ****     GPIOB->MODER &= ~(1 << 6);
  36:Src/motor.c   **** 
  37:Src/motor.c   ****     // Set PA4 to AF4,
  38:Src/motor.c   ****     GPIOA->AFR[0] &= 0xFFF0FFFF; // clear PA4 bits,
  39:Src/motor.c   ****     GPIOA->AFR[0] |= (1 << 18);
  40:Src/motor.c   **** 	
  41:Src/motor.c   **** 		// Set PB3 to AF2,
  42:Src/motor.c   ****     GPIOB->AFR[0] &= 0xFFFF0FFF; // clear PB3 bits,
  43:Src/motor.c   ****     GPIOB->AFR[0] |= (1 << 13);
  44:Src/motor.c   **** 
  45:Src/motor.c   ****     // Set up a PA5, PA8 as GPIO output pins for motor direction control
  46:Src/motor.c   ****     GPIOA->MODER &= 0xFFFCF3FF; // clear PA5, PA6 bits,
  47:Src/motor.c   ****     GPIOA->MODER |= (1 << 10) | (1 << 16);
  48:Src/motor.c   **** 	
  49:Src/motor.c   **** 		// Set up a PB2, PB10 as GPIO output pins for motor direction control
  50:Src/motor.c   ****     GPIOB->MODER &= 0xFFCFFFCF; // clear PB2, PB10 bits,
  51:Src/motor.c   ****     GPIOB->MODER |= (1 << 4) | (1 << 20);
  52:Src/motor.c   **** 	*/
  53:Src/motor.c   ****    
  54:Src/motor.c   ****     //Initialize one direction pin to high, the other low
  55:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_a.gpio, motor_left_pins.dir_a.pin.Pin, GPIO_PIN_SET);
  38              		.loc 1 55 2 view .LVU1
  39              		.loc 1 55 73 is_stmt 0 view .LVU2
  40 0002 244C     		ldr	r4, .L2
  41              		.loc 1 55 2 view .LVU3
  42 0004 A18B     		ldrh	r1, [r4, #28]
  43 0006 A069     		ldr	r0, [r4, #24]
  44 0008 0122     		movs	r2, #1
  45 000a FFF7FEFF 		bl	HAL_GPIO_WritePin
  46              	.LVL0:
  56:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_b.gpio, motor_left_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
  47              		.loc 1 56 2 is_stmt 1 view .LVU4
  48 000e A18E     		ldrh	r1, [r4, #52]
  49 0010 206B     		ldr	r0, [r4, #48]
  50 0012 0022     		movs	r2, #0
  51 0014 FFF7FEFF 		bl	HAL_GPIO_WritePin
  52              	.LVL1:
  57:Src/motor.c   **** 
  58:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_a.gpio, motor_right_pins.dir_a.pin.Pin, GPIO_PIN_SET);
  53              		.loc 1 58 2 view .LVU5
  54              		.loc 1 58 75 is_stmt 0 view .LVU6
  55 0018 1F4C     		ldr	r4, .L2+4
  56              		.loc 1 58 2 view .LVU7
  57 001a A18B     		ldrh	r1, [r4, #28]
ARM GAS  /tmp/ccMw3CGW.s 			page 3


  58 001c A069     		ldr	r0, [r4, #24]
  59 001e 0122     		movs	r2, #1
  60 0020 FFF7FEFF 		bl	HAL_GPIO_WritePin
  61              	.LVL2:
  59:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_b.gpio, motor_right_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
  62              		.loc 1 59 2 is_stmt 1 view .LVU8
  63 0024 A18E     		ldrh	r1, [r4, #52]
  64 0026 206B     		ldr	r0, [r4, #48]
  65 0028 0022     		movs	r2, #0
  66 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
  67              	.LVL3:
  60:Src/motor.c   **** 
  61:Src/motor.c   ****     // Set up PWM timer
  62:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;
  68              		.loc 1 62 5 view .LVU9
  69              		.loc 1 62 8 is_stmt 0 view .LVU10
  70 002e 1B4B     		ldr	r3, .L2+8
  71 0030 D969     		ldr	r1, [r3, #28]
  72              		.loc 1 62 18 view .LVU11
  73 0032 8022     		movs	r2, #128
  74 0034 5200     		lsls	r2, r2, #1
  75 0036 0A43     		orrs	r2, r1
  76 0038 DA61     		str	r2, [r3, #28]
  63:Src/motor.c   ****     TIM14->CR1 = 0;                         // Clear control registers
  77              		.loc 1 63 5 is_stmt 1 view .LVU12
  78              		.loc 1 63 16 is_stmt 0 view .LVU13
  79 003a 194A     		ldr	r2, .L2+12
  80 003c 0021     		movs	r1, #0
  81 003e 1160     		str	r1, [r2]
  64:Src/motor.c   ****     TIM14->CCMR1 = 0;                       // (prevents having to manually clear bits)
  82              		.loc 1 64 5 is_stmt 1 view .LVU14
  83              		.loc 1 64 18 is_stmt 0 view .LVU15
  84 0040 9161     		str	r1, [r2, #24]
  65:Src/motor.c   ****     TIM14->CCER = 0;
  85              		.loc 1 65 5 is_stmt 1 view .LVU16
  86              		.loc 1 65 17 is_stmt 0 view .LVU17
  87 0042 1162     		str	r1, [r2, #32]
  66:Src/motor.c   **** 		
  67:Src/motor.c   **** 		RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
  88              		.loc 1 67 3 is_stmt 1 view .LVU18
  89              		.loc 1 67 6 is_stmt 0 view .LVU19
  90 0044 DC69     		ldr	r4, [r3, #28]
  91              		.loc 1 67 16 view .LVU20
  92 0046 0120     		movs	r0, #1
  93 0048 0443     		orrs	r4, r0
  94 004a DC61     		str	r4, [r3, #28]
  68:Src/motor.c   ****     TIM2->CR1 = 0;                         // Clear control registers
  95              		.loc 1 68 5 is_stmt 1 view .LVU21
  96              		.loc 1 68 15 is_stmt 0 view .LVU22
  97 004c 8023     		movs	r3, #128
  98 004e DB05     		lsls	r3, r3, #23
  99 0050 1960     		str	r1, [r3]
  69:Src/motor.c   ****     TIM2->CCMR1 = 0;                       // (prevents having to manually clear bits)
 100              		.loc 1 69 5 is_stmt 1 view .LVU23
 101              		.loc 1 69 17 is_stmt 0 view .LVU24
 102 0052 9961     		str	r1, [r3, #24]
  70:Src/motor.c   ****     TIM2->CCER = 0;
ARM GAS  /tmp/ccMw3CGW.s 			page 4


 103              		.loc 1 70 5 is_stmt 1 view .LVU25
 104              		.loc 1 70 16 is_stmt 0 view .LVU26
 105 0054 1962     		str	r1, [r3, #32]
  71:Src/motor.c   **** 
  72:Src/motor.c   ****     // Set output-compare CH1 to PWM1 mode and enable CCR1 preload buffer
  73:Src/motor.c   ****     TIM14->CCMR1 |= (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE);
 106              		.loc 1 73 5 is_stmt 1 view .LVU27
 107              		.loc 1 73 10 is_stmt 0 view .LVU28
 108 0056 9469     		ldr	r4, [r2, #24]
 109              		.loc 1 73 18 view .LVU29
 110 0058 6825     		movs	r5, #104
 111 005a 2C43     		orrs	r4, r5
 112 005c 9461     		str	r4, [r2, #24]
  74:Src/motor.c   ****     TIM14->CCER |= TIM_CCER_CC1E;           // Enable capture-compare channel 1
 113              		.loc 1 74 5 is_stmt 1 view .LVU30
 114              		.loc 1 74 10 is_stmt 0 view .LVU31
 115 005e 146A     		ldr	r4, [r2, #32]
 116              		.loc 1 74 17 view .LVU32
 117 0060 0443     		orrs	r4, r0
 118 0062 1462     		str	r4, [r2, #32]
  75:Src/motor.c   ****     TIM14->PSC = 1;                         // Run timer on 24Mhz
 119              		.loc 1 75 5 is_stmt 1 view .LVU33
 120              		.loc 1 75 16 is_stmt 0 view .LVU34
 121 0064 9062     		str	r0, [r2, #40]
  76:Src/motor.c   ****     TIM14->ARR = 1200;                      // PWM at 20kHz
 122              		.loc 1 76 5 is_stmt 1 view .LVU35
 123              		.loc 1 76 16 is_stmt 0 view .LVU36
 124 0066 9625     		movs	r5, #150
 125 0068 ED00     		lsls	r5, r5, #3
 126 006a D562     		str	r5, [r2, #44]
  77:Src/motor.c   ****     TIM14->CCR1 = 0;                        // Start PWM at 0% duty cycle
 127              		.loc 1 77 5 is_stmt 1 view .LVU37
 128              		.loc 1 77 17 is_stmt 0 view .LVU38
 129 006c 5163     		str	r1, [r2, #52]
  78:Src/motor.c   ****     
  79:Src/motor.c   ****     TIM14->CR1 |= TIM_CR1_CEN;              // Enable timer
 130              		.loc 1 79 5 is_stmt 1 view .LVU39
 131              		.loc 1 79 10 is_stmt 0 view .LVU40
 132 006e 1468     		ldr	r4, [r2]
 133              		.loc 1 79 16 view .LVU41
 134 0070 0443     		orrs	r4, r0
 135 0072 1460     		str	r4, [r2]
  80:Src/motor.c   **** 		
  81:Src/motor.c   **** 		TIM2->CCMR1 |= (TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2PE);
 136              		.loc 1 81 3 is_stmt 1 view .LVU42
 137              		.loc 1 81 7 is_stmt 0 view .LVU43
 138 0074 9C69     		ldr	r4, [r3, #24]
 139              		.loc 1 81 15 view .LVU44
 140 0076 D022     		movs	r2, #208
 141 0078 D201     		lsls	r2, r2, #7
 142 007a 2243     		orrs	r2, r4
 143 007c 9A61     		str	r2, [r3, #24]
  82:Src/motor.c   ****     TIM2->CCER |= TIM_CCER_CC2E;           // Enable capture-compare channel 2
 144              		.loc 1 82 5 is_stmt 1 view .LVU45
 145              		.loc 1 82 9 is_stmt 0 view .LVU46
 146 007e 1A6A     		ldr	r2, [r3, #32]
 147              		.loc 1 82 16 view .LVU47
ARM GAS  /tmp/ccMw3CGW.s 			page 5


 148 0080 1024     		movs	r4, #16
 149 0082 2243     		orrs	r2, r4
 150 0084 1A62     		str	r2, [r3, #32]
  83:Src/motor.c   ****     TIM2->PSC = 1;                         // Run timer on 24Mhz
 151              		.loc 1 83 5 is_stmt 1 view .LVU48
 152              		.loc 1 83 15 is_stmt 0 view .LVU49
 153 0086 9862     		str	r0, [r3, #40]
  84:Src/motor.c   ****     TIM2->ARR = 1200;                      // PWM at 20kHz
 154              		.loc 1 84 5 is_stmt 1 view .LVU50
 155              		.loc 1 84 15 is_stmt 0 view .LVU51
 156 0088 DD62     		str	r5, [r3, #44]
  85:Src/motor.c   ****     TIM2->CCR2 = 0;                        // Start PWM at 0% duty cycle
 157              		.loc 1 85 5 is_stmt 1 view .LVU52
 158              		.loc 1 85 16 is_stmt 0 view .LVU53
 159 008a 9963     		str	r1, [r3, #56]
  86:Src/motor.c   ****     
  87:Src/motor.c   ****     TIM2->CR1 |= TIM_CR1_CEN;              // Enable timer
 160              		.loc 1 87 5 is_stmt 1 view .LVU54
 161              		.loc 1 87 9 is_stmt 0 view .LVU55
 162 008c 1A68     		ldr	r2, [r3]
 163              		.loc 1 87 15 view .LVU56
 164 008e 0243     		orrs	r2, r0
 165 0090 1A60     		str	r2, [r3]
  88:Src/motor.c   **** }
 166              		.loc 1 88 1 view .LVU57
 167              		@ sp needed
 168 0092 70BD     		pop	{r4, r5, r6, pc}
 169              	.L3:
 170              		.align	2
 171              	.L2:
 172 0094 00000000 		.word	motor_left_pins
 173 0098 00000000 		.word	motor_right_pins
 174 009c 00100240 		.word	1073876992
 175 00a0 00200040 		.word	1073750016
 176              		.cfi_endproc
 177              	.LFE44:
 179              		.global	__aeabi_uidiv
 180              		.section	.text.pwm_setDutyCycleL,"ax",%progbits
 181              		.align	1
 182              		.global	pwm_setDutyCycleL
 183              		.syntax unified
 184              		.code	16
 185              		.thumb_func
 187              	pwm_setDutyCycleL:
 188              	.LVL4:
 189              	.LFB45:
  89:Src/motor.c   **** 
  90:Src/motor.c   **** // Set the duty cycle of the PWM Left, accepts (0-100)
  91:Src/motor.c   **** void pwm_setDutyCycleL(uint8_t duty) {
 190              		.loc 1 91 38 is_stmt 1 view -0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		.loc 1 91 38 is_stmt 0 view .LVU59
 195 0000 10B5     		push	{r4, lr}
 196              	.LCFI1:
 197              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccMw3CGW.s 			page 6


 198              		.cfi_offset 4, -8
 199              		.cfi_offset 14, -4
  92:Src/motor.c   ****     if(duty <= 100) {
 200              		.loc 1 92 5 is_stmt 1 view .LVU60
 201              		.loc 1 92 7 is_stmt 0 view .LVU61
 202 0002 6428     		cmp	r0, #100
 203 0004 06D8     		bhi	.L4
  93:Src/motor.c   ****         TIM14->CCR1 = ((uint32_t)duty*TIM14->ARR)/100;  // Use linear transform to produce CCR1 val
 204              		.loc 1 93 9 is_stmt 1 view .LVU62
 205              		.loc 1 93 44 is_stmt 0 view .LVU63
 206 0006 044C     		ldr	r4, .L6
 207 0008 E36A     		ldr	r3, [r4, #44]
 208              		.loc 1 93 38 view .LVU64
 209 000a 5843     		muls	r0, r3
 210              	.LVL5:
 211              		.loc 1 93 50 view .LVU65
 212 000c 6421     		movs	r1, #100
 213 000e FFF7FEFF 		bl	__aeabi_uidiv
 214              	.LVL6:
 215              		.loc 1 93 21 view .LVU66
 216 0012 6063     		str	r0, [r4, #52]
 217              	.L4:
  94:Src/motor.c   ****         // (CCR1 == "pulse" parameter in PWM struct used by peripheral library)
  95:Src/motor.c   ****     }
  96:Src/motor.c   **** }
 218              		.loc 1 96 1 view .LVU67
 219              		@ sp needed
 220 0014 10BD     		pop	{r4, pc}
 221              	.L7:
 222 0016 C046     		.align	2
 223              	.L6:
 224 0018 00200040 		.word	1073750016
 225              		.cfi_endproc
 226              	.LFE45:
 228              		.section	.text.pwm_setDutyCycleR,"ax",%progbits
 229              		.align	1
 230              		.global	pwm_setDutyCycleR
 231              		.syntax unified
 232              		.code	16
 233              		.thumb_func
 235              	pwm_setDutyCycleR:
 236              	.LVL7:
 237              	.LFB46:
  97:Src/motor.c   **** 
  98:Src/motor.c   **** // Set the duty cycle of the PWM Right, accepts (0-100)
  99:Src/motor.c   **** void pwm_setDutyCycleR(uint8_t duty) {
 238              		.loc 1 99 38 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		.loc 1 99 38 is_stmt 0 view .LVU69
 243 0000 10B5     		push	{r4, lr}
 244              	.LCFI2:
 245              		.cfi_def_cfa_offset 8
 246              		.cfi_offset 4, -8
 247              		.cfi_offset 14, -4
 100:Src/motor.c   ****     if(duty <= 100) {
ARM GAS  /tmp/ccMw3CGW.s 			page 7


 248              		.loc 1 100 5 is_stmt 1 view .LVU70
 249              		.loc 1 100 7 is_stmt 0 view .LVU71
 250 0002 6428     		cmp	r0, #100
 251 0004 07D8     		bhi	.L8
 101:Src/motor.c   ****         TIM2->CCR2 = ((uint32_t)duty*TIM2->ARR)/100;  // Use linear transform to produce CCR1 value
 252              		.loc 1 101 9 is_stmt 1 view .LVU72
 253              		.loc 1 101 42 is_stmt 0 view .LVU73
 254 0006 8024     		movs	r4, #128
 255 0008 E405     		lsls	r4, r4, #23
 256 000a E36A     		ldr	r3, [r4, #44]
 257              		.loc 1 101 37 view .LVU74
 258 000c 5843     		muls	r0, r3
 259              	.LVL8:
 260              		.loc 1 101 48 view .LVU75
 261 000e 6421     		movs	r1, #100
 262 0010 FFF7FEFF 		bl	__aeabi_uidiv
 263              	.LVL9:
 264              		.loc 1 101 20 view .LVU76
 265 0014 A063     		str	r0, [r4, #56]
 266              	.L8:
 102:Src/motor.c   ****         // (CCR2 == "pulse" parameter in PWM struct used by peripheral library)
 103:Src/motor.c   ****     }
 104:Src/motor.c   **** }
 267              		.loc 1 104 1 view .LVU77
 268              		@ sp needed
 269 0016 10BD     		pop	{r4, pc}
 270              		.cfi_endproc
 271              	.LFE46:
 273              		.section	.text.set_Motor_Direction,"ax",%progbits
 274              		.align	1
 275              		.global	set_Motor_Direction
 276              		.syntax unified
 277              		.code	16
 278              		.thumb_func
 280              	set_Motor_Direction:
 281              	.LVL10:
 282              	.LFB47:
 105:Src/motor.c   **** 
 106:Src/motor.c   **** /*
 107:Src/motor.c   ****  * This sets an individual motor's direction.
 108:Src/motor.c   ****  * Note: use MoveMotors to change multiple motor values, eg to turn.
 109:Src/motor.c   ****  */
 110:Src/motor.c   **** void set_Motor_Direction(Direction dir, motor_pins_t* pins){
 283              		.loc 1 110 60 is_stmt 1 view -0
 284              		.cfi_startproc
 285              		@ args = 0, pretend = 0, frame = 0
 286              		@ frame_needed = 0, uses_anonymous_args = 0
 287              		.loc 1 110 60 is_stmt 0 view .LVU79
 288 0000 10B5     		push	{r4, lr}
 289              	.LCFI3:
 290              		.cfi_def_cfa_offset 8
 291              		.cfi_offset 4, -8
 292              		.cfi_offset 14, -4
 293 0002 0C00     		movs	r4, r1
 111:Src/motor.c   **** 	switch(dir){
 294              		.loc 1 111 2 is_stmt 1 view .LVU80
 295 0004 0028     		cmp	r0, #0
ARM GAS  /tmp/ccMw3CGW.s 			page 8


 296 0006 02D0     		beq	.L11
 297 0008 0328     		cmp	r0, #3
 298 000a 0BD0     		beq	.L12
 299              	.LVL11:
 300              	.L10:
 112:Src/motor.c   **** 		case FORWARD:
 113:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_SET);
 114:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 115:Src/motor.c   **** 			break;
 116:Src/motor.c   **** 		case BACKWARD:
 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_RESET);
 118:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 119:Src/motor.c   **** 			break;
 120:Src/motor.c   **** 		default:
 121:Src/motor.c   **** 			;
 122:Src/motor.c   **** 	}
 123:Src/motor.c   **** }
 301              		.loc 1 123 1 is_stmt 0 view .LVU81
 302              		@ sp needed
 303              	.LVL12:
 304              		.loc 1 123 1 view .LVU82
 305 000c 10BD     		pop	{r4, pc}
 306              	.LVL13:
 307              	.L11:
 113:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 308              		.loc 1 113 4 is_stmt 1 view .LVU83
 309 000e 898B     		ldrh	r1, [r1, #28]
 310              	.LVL14:
 113:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 311              		.loc 1 113 4 is_stmt 0 view .LVU84
 312 0010 A069     		ldr	r0, [r4, #24]
 313              	.LVL15:
 113:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 314              		.loc 1 113 4 view .LVU85
 315 0012 0122     		movs	r2, #1
 316 0014 FFF7FEFF 		bl	HAL_GPIO_WritePin
 317              	.LVL16:
 114:Src/motor.c   **** 			break;
 318              		.loc 1 114 4 is_stmt 1 view .LVU86
 319 0018 A18E     		ldrh	r1, [r4, #52]
 320 001a 206B     		ldr	r0, [r4, #48]
 321 001c 0022     		movs	r2, #0
 322 001e FFF7FEFF 		bl	HAL_GPIO_WritePin
 323              	.LVL17:
 115:Src/motor.c   **** 		case BACKWARD:
 324              		.loc 1 115 4 view .LVU87
 325 0022 F3E7     		b	.L10
 326              	.LVL18:
 327              	.L12:
 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 328              		.loc 1 117 4 view .LVU88
 329 0024 898B     		ldrh	r1, [r1, #28]
 330              	.LVL19:
 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 331              		.loc 1 117 4 is_stmt 0 view .LVU89
 332 0026 A069     		ldr	r0, [r4, #24]
 333              	.LVL20:
ARM GAS  /tmp/ccMw3CGW.s 			page 9


 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 334              		.loc 1 117 4 view .LVU90
 335 0028 0022     		movs	r2, #0
 336 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
 337              	.LVL21:
 118:Src/motor.c   **** 			break;
 338              		.loc 1 118 4 is_stmt 1 view .LVU91
 339 002e A18E     		ldrh	r1, [r4, #52]
 340 0030 206B     		ldr	r0, [r4, #48]
 341 0032 0122     		movs	r2, #1
 342 0034 FFF7FEFF 		bl	HAL_GPIO_WritePin
 343              	.LVL22:
 119:Src/motor.c   **** 		default:
 344              		.loc 1 119 4 view .LVU92
 121:Src/motor.c   **** 	}
 345              		.loc 1 121 4 view .LVU93
 346              		.loc 1 123 1 is_stmt 0 view .LVU94
 347 0038 E8E7     		b	.L10
 348              		.cfi_endproc
 349              	.LFE47:
 351              		.section	.text.set_Forward,"ax",%progbits
 352              		.align	1
 353              		.global	set_Forward
 354              		.syntax unified
 355              		.code	16
 356              		.thumb_func
 358              	set_Forward:
 359              	.LFB48:
 124:Src/motor.c   **** 
 125:Src/motor.c   **** void set_Forward(){
 360              		.loc 1 125 19 is_stmt 1 view -0
 361              		.cfi_startproc
 362              		@ args = 0, pretend = 0, frame = 0
 363              		@ frame_needed = 0, uses_anonymous_args = 0
 364 0000 10B5     		push	{r4, lr}
 365              	.LCFI4:
 366              		.cfi_def_cfa_offset 8
 367              		.cfi_offset 4, -8
 368              		.cfi_offset 14, -4
 126:Src/motor.c   **** 	//left go forward
 127:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
 369              		.loc 1 127 2 view .LVU96
 370 0002 0749     		ldr	r1, .L15
 371 0004 0020     		movs	r0, #0
 372 0006 FFF7FEFF 		bl	set_Motor_Direction
 373              	.LVL23:
 128:Src/motor.c   **** 
 129:Src/motor.c   **** 	//right go forward
 130:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 374              		.loc 1 130 2 view .LVU97
 375 000a 0649     		ldr	r1, .L15+4
 376 000c 0020     		movs	r0, #0
 377 000e FFF7FEFF 		bl	set_Motor_Direction
 378              	.LVL24:
 131:Src/motor.c   **** 
 132:Src/motor.c   **** 	pwm_setDutyCycleR(100);
 379              		.loc 1 132 2 view .LVU98
ARM GAS  /tmp/ccMw3CGW.s 			page 10


 380 0012 6420     		movs	r0, #100
 381 0014 FFF7FEFF 		bl	pwm_setDutyCycleR
 382              	.LVL25:
 133:Src/motor.c   **** 	pwm_setDutyCycleL(100);
 383              		.loc 1 133 2 view .LVU99
 384 0018 6420     		movs	r0, #100
 385 001a FFF7FEFF 		bl	pwm_setDutyCycleL
 386              	.LVL26:
 134:Src/motor.c   **** 
 135:Src/motor.c   **** 
 136:Src/motor.c   **** 	/* the old way
 137:Src/motor.c   **** 		GPIOA->ODR |= (1 << 5);
 138:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 8);
 139:Src/motor.c   **** 		GPIOB->ODR |= (1 << 10);
 140:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 2);
 141:Src/motor.c   **** 	*/
 142:Src/motor.c   **** }
 387              		.loc 1 142 1 is_stmt 0 view .LVU100
 388              		@ sp needed
 389 001e 10BD     		pop	{r4, pc}
 390              	.L16:
 391              		.align	2
 392              	.L15:
 393 0020 00000000 		.word	motor_left_pins
 394 0024 00000000 		.word	motor_right_pins
 395              		.cfi_endproc
 396              	.LFE48:
 398              		.section	.text.set_Backward,"ax",%progbits
 399              		.align	1
 400              		.global	set_Backward
 401              		.syntax unified
 402              		.code	16
 403              		.thumb_func
 405              	set_Backward:
 406              	.LFB49:
 143:Src/motor.c   **** 
 144:Src/motor.c   **** void set_Backward(){
 407              		.loc 1 144 20 is_stmt 1 view -0
 408              		.cfi_startproc
 409              		@ args = 0, pretend = 0, frame = 0
 410              		@ frame_needed = 0, uses_anonymous_args = 0
 411 0000 10B5     		push	{r4, lr}
 412              	.LCFI5:
 413              		.cfi_def_cfa_offset 8
 414              		.cfi_offset 4, -8
 415              		.cfi_offset 14, -4
 145:Src/motor.c   **** 	//left go backward
 146:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 416              		.loc 1 146 2 view .LVU102
 417 0002 0749     		ldr	r1, .L18
 418 0004 0320     		movs	r0, #3
 419 0006 FFF7FEFF 		bl	set_Motor_Direction
 420              	.LVL27:
 147:Src/motor.c   **** 
 148:Src/motor.c   **** 	//right go backward
 149:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 421              		.loc 1 149 2 view .LVU103
ARM GAS  /tmp/ccMw3CGW.s 			page 11


 422 000a 0649     		ldr	r1, .L18+4
 423 000c 0320     		movs	r0, #3
 424 000e FFF7FEFF 		bl	set_Motor_Direction
 425              	.LVL28:
 150:Src/motor.c   **** 	pwm_setDutyCycleR(100);
 426              		.loc 1 150 2 view .LVU104
 427 0012 6420     		movs	r0, #100
 428 0014 FFF7FEFF 		bl	pwm_setDutyCycleR
 429              	.LVL29:
 151:Src/motor.c   **** 	pwm_setDutyCycleL(100);
 430              		.loc 1 151 2 view .LVU105
 431 0018 6420     		movs	r0, #100
 432 001a FFF7FEFF 		bl	pwm_setDutyCycleL
 433              	.LVL30:
 152:Src/motor.c   **** 	/* the old way
 153:Src/motor.c   **** 		GPIOA->ODR |= (1 << 8);
 154:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 5);
 155:Src/motor.c   **** 		GPIOB->ODR |= (1 << 2);
 156:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 10);
 157:Src/motor.c   **** 	*/
 158:Src/motor.c   **** }
 434              		.loc 1 158 1 is_stmt 0 view .LVU106
 435              		@ sp needed
 436 001e 10BD     		pop	{r4, pc}
 437              	.L19:
 438              		.align	2
 439              	.L18:
 440 0020 00000000 		.word	motor_left_pins
 441 0024 00000000 		.word	motor_right_pins
 442              		.cfi_endproc
 443              	.LFE49:
 445              		.section	.text.set_Right,"ax",%progbits
 446              		.align	1
 447              		.global	set_Right
 448              		.syntax unified
 449              		.code	16
 450              		.thumb_func
 452              	set_Right:
 453              	.LFB50:
 159:Src/motor.c   **** 
 160:Src/motor.c   **** void set_Right(){
 454              		.loc 1 160 17 is_stmt 1 view -0
 455              		.cfi_startproc
 456              		@ args = 0, pretend = 0, frame = 0
 457              		@ frame_needed = 0, uses_anonymous_args = 0
 458 0000 10B5     		push	{r4, lr}
 459              	.LCFI6:
 460              		.cfi_def_cfa_offset 8
 461              		.cfi_offset 4, -8
 462              		.cfi_offset 14, -4
 161:Src/motor.c   **** 	//left go forward
 162:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
 463              		.loc 1 162 2 view .LVU108
 464 0002 0749     		ldr	r1, .L21
 465 0004 0020     		movs	r0, #0
 466 0006 FFF7FEFF 		bl	set_Motor_Direction
 467              	.LVL31:
ARM GAS  /tmp/ccMw3CGW.s 			page 12


 163:Src/motor.c   **** 
 164:Src/motor.c   **** 	//right go backward
 165:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 468              		.loc 1 165 2 view .LVU109
 469 000a 0649     		ldr	r1, .L21+4
 470 000c 0320     		movs	r0, #3
 471 000e FFF7FEFF 		bl	set_Motor_Direction
 472              	.LVL32:
 166:Src/motor.c   **** 	pwm_setDutyCycleR(100);
 473              		.loc 1 166 2 view .LVU110
 474 0012 6420     		movs	r0, #100
 475 0014 FFF7FEFF 		bl	pwm_setDutyCycleR
 476              	.LVL33:
 167:Src/motor.c   **** 	pwm_setDutyCycleL(100);
 477              		.loc 1 167 2 view .LVU111
 478 0018 6420     		movs	r0, #100
 479 001a FFF7FEFF 		bl	pwm_setDutyCycleL
 480              	.LVL34:
 168:Src/motor.c   **** 	/* old way
 169:Src/motor.c   **** 		GPIOA->ODR |= (1 << 5);
 170:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 8);
 171:Src/motor.c   **** 		GPIOB->ODR |= (1 << 2);
 172:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 10);
 173:Src/motor.c   **** 	*/
 174:Src/motor.c   **** }
 481              		.loc 1 174 1 is_stmt 0 view .LVU112
 482              		@ sp needed
 483 001e 10BD     		pop	{r4, pc}
 484              	.L22:
 485              		.align	2
 486              	.L21:
 487 0020 00000000 		.word	motor_left_pins
 488 0024 00000000 		.word	motor_right_pins
 489              		.cfi_endproc
 490              	.LFE50:
 492              		.section	.text.set_Left,"ax",%progbits
 493              		.align	1
 494              		.global	set_Left
 495              		.syntax unified
 496              		.code	16
 497              		.thumb_func
 499              	set_Left:
 500              	.LFB51:
 175:Src/motor.c   **** 
 176:Src/motor.c   **** void set_Left(){
 501              		.loc 1 176 16 is_stmt 1 view -0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 0
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505 0000 10B5     		push	{r4, lr}
 506              	.LCFI7:
 507              		.cfi_def_cfa_offset 8
 508              		.cfi_offset 4, -8
 509              		.cfi_offset 14, -4
 177:Src/motor.c   **** 	//left go backward
 178:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 510              		.loc 1 178 2 view .LVU114
ARM GAS  /tmp/ccMw3CGW.s 			page 13


 511 0002 0749     		ldr	r1, .L24
 512 0004 0320     		movs	r0, #3
 513 0006 FFF7FEFF 		bl	set_Motor_Direction
 514              	.LVL35:
 179:Src/motor.c   **** 	
 180:Src/motor.c   **** 	//right go forward
 181:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 515              		.loc 1 181 2 view .LVU115
 516 000a 0649     		ldr	r1, .L24+4
 517 000c 0020     		movs	r0, #0
 518 000e FFF7FEFF 		bl	set_Motor_Direction
 519              	.LVL36:
 182:Src/motor.c   **** 
 183:Src/motor.c   **** 	pwm_setDutyCycleR(100);
 520              		.loc 1 183 2 view .LVU116
 521 0012 6420     		movs	r0, #100
 522 0014 FFF7FEFF 		bl	pwm_setDutyCycleR
 523              	.LVL37:
 184:Src/motor.c   **** 	pwm_setDutyCycleL(100);
 524              		.loc 1 184 2 view .LVU117
 525 0018 6420     		movs	r0, #100
 526 001a FFF7FEFF 		bl	pwm_setDutyCycleL
 527              	.LVL38:
 185:Src/motor.c   **** 	/*
 186:Src/motor.c   **** 		GPIOA->ODR |= (1 << 8);
 187:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 5);
 188:Src/motor.c   **** 		GPIOB->ODR |= (1 << 10);
 189:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 2);
 190:Src/motor.c   **** 	*/
 191:Src/motor.c   **** }
 528              		.loc 1 191 1 is_stmt 0 view .LVU118
 529              		@ sp needed
 530 001e 10BD     		pop	{r4, pc}
 531              	.L25:
 532              		.align	2
 533              	.L24:
 534 0020 00000000 		.word	motor_left_pins
 535 0024 00000000 		.word	motor_right_pins
 536              		.cfi_endproc
 537              	.LFE51:
 539              		.section	.text.motors_Off,"ax",%progbits
 540              		.align	1
 541              		.global	motors_Off
 542              		.syntax unified
 543              		.code	16
 544              		.thumb_func
 546              	motors_Off:
 547              	.LFB52:
 192:Src/motor.c   **** 
 193:Src/motor.c   **** void motors_Off(){
 548              		.loc 1 193 18 is_stmt 1 view -0
 549              		.cfi_startproc
 550              		@ args = 0, pretend = 0, frame = 0
 551              		@ frame_needed = 0, uses_anonymous_args = 0
 552 0000 10B5     		push	{r4, lr}
 553              	.LCFI8:
 554              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccMw3CGW.s 			page 14


 555              		.cfi_offset 4, -8
 556              		.cfi_offset 14, -4
 194:Src/motor.c   **** 	pwm_setDutyCycleR(0);
 557              		.loc 1 194 2 view .LVU120
 558 0002 0020     		movs	r0, #0
 559 0004 FFF7FEFF 		bl	pwm_setDutyCycleR
 560              	.LVL39:
 195:Src/motor.c   **** 	pwm_setDutyCycleL(0);
 561              		.loc 1 195 2 view .LVU121
 562 0008 0020     		movs	r0, #0
 563 000a FFF7FEFF 		bl	pwm_setDutyCycleL
 564              	.LVL40:
 196:Src/motor.c   **** }
 565              		.loc 1 196 1 is_stmt 0 view .LVU122
 566              		@ sp needed
 567 000e 10BD     		pop	{r4, pc}
 568              		.cfi_endproc
 569              	.LFE52:
 571              		.section	.rodata.MoveMotors.str1.4,"aMS",%progbits,1
 572              		.align	2
 573              	.LC10:
 574 0000 4D6F7665 		.ascii	"MoveMotors executed!\012\000"
 574      4D6F746F 
 574      72732065 
 574      78656375 
 574      74656421 
 575 0016 0000     		.align	2
 576              	.LC12:
 577 0018 496E7661 		.ascii	"Invalid command to MoveMotors!\012\000"
 577      6C696420 
 577      636F6D6D 
 577      616E6420 
 577      746F204D 
 578              		.section	.text.MoveMotors,"ax",%progbits
 579              		.align	1
 580              		.global	MoveMotors
 581              		.syntax unified
 582              		.code	16
 583              		.thumb_func
 585              	MoveMotors:
 586              	.LVL41:
 587              	.LFB53:
 197:Src/motor.c   **** 
 198:Src/motor.c   **** uint8_t* MoveMotors(MotorCommand* cmd){
 588              		.loc 1 198 39 is_stmt 1 view -0
 589              		.cfi_startproc
 590              		@ args = 0, pretend = 0, frame = 0
 591              		@ frame_needed = 0, uses_anonymous_args = 0
 592              		.loc 1 198 39 is_stmt 0 view .LVU124
 593 0000 10B5     		push	{r4, lr}
 594              	.LCFI9:
 595              		.cfi_def_cfa_offset 8
 596              		.cfi_offset 4, -8
 597              		.cfi_offset 14, -4
 598 0002 0400     		movs	r4, r0
 199:Src/motor.c   **** 	motors_Off();
 599              		.loc 1 199 2 is_stmt 1 view .LVU125
ARM GAS  /tmp/ccMw3CGW.s 			page 15


 600 0004 FFF7FEFF 		bl	motors_Off
 601              	.LVL42:
 200:Src/motor.c   **** 	uint8_t* err = "MoveMotors executed!\n";
 602              		.loc 1 200 2 view .LVU126
 201:Src/motor.c   **** 	switch(cmd->dir){
 603              		.loc 1 201 2 view .LVU127
 604              		.loc 1 201 12 is_stmt 0 view .LVU128
 605 0008 2378     		ldrb	r3, [r4]
 606              		.loc 1 201 2 view .LVU129
 607 000a 022B     		cmp	r3, #2
 608 000c 16D0     		beq	.L28
 609 000e 09D8     		bhi	.L29
 610 0010 002B     		cmp	r3, #0
 611 0012 0FD0     		beq	.L30
 612 0014 012B     		cmp	r3, #1
 613 0016 03D1     		bne	.L34
 202:Src/motor.c   **** 		case FORWARD:
 203:Src/motor.c   **** 			set_Forward();
 204:Src/motor.c   **** 			break;
 205:Src/motor.c   **** 		case LEFT:
 206:Src/motor.c   **** 			set_Left();
 614              		.loc 1 206 4 is_stmt 1 view .LVU130
 615 0018 FFF7FEFF 		bl	set_Left
 616              	.LVL43:
 207:Src/motor.c   **** 			break;
 617              		.loc 1 207 4 view .LVU131
 200:Src/motor.c   **** 	switch(cmd->dir){
 618              		.loc 1 200 11 is_stmt 0 view .LVU132
 619 001c 0948     		ldr	r0, .L36
 620              		.loc 1 207 4 view .LVU133
 621 001e 08E0     		b	.L27
 622              	.L34:
 201:Src/motor.c   **** 		case FORWARD:
 623              		.loc 1 201 2 view .LVU134
 624 0020 0948     		ldr	r0, .L36+4
 625 0022 06E0     		b	.L27
 626              	.L29:
 627 0024 042B     		cmp	r3, #4
 628 0026 03D1     		bne	.L35
 208:Src/motor.c   **** 		case RIGHT:
 209:Src/motor.c   **** 			set_Right();
 210:Src/motor.c   **** 			break;
 211:Src/motor.c   **** 		case OFF:
 212:Src/motor.c   **** 			motors_Off();
 629              		.loc 1 212 4 is_stmt 1 view .LVU135
 630 0028 FFF7FEFF 		bl	motors_Off
 631              	.LVL44:
 213:Src/motor.c   **** 			break;
 632              		.loc 1 213 4 view .LVU136
 200:Src/motor.c   **** 	switch(cmd->dir){
 633              		.loc 1 200 11 is_stmt 0 view .LVU137
 634 002c 0548     		ldr	r0, .L36
 635              	.LVL45:
 214:Src/motor.c   **** 		default:
 215:Src/motor.c   **** 			err = "Invalid command to MoveMotors!\n";
 216:Src/motor.c   **** 	}
 217:Src/motor.c   **** 	return err;
ARM GAS  /tmp/ccMw3CGW.s 			page 16


 636              		.loc 1 217 2 is_stmt 1 view .LVU138
 637              		.loc 1 217 9 is_stmt 0 view .LVU139
 638 002e 00E0     		b	.L27
 639              	.LVL46:
 640              	.L35:
 201:Src/motor.c   **** 		case FORWARD:
 641              		.loc 1 201 2 view .LVU140
 642 0030 0548     		ldr	r0, .L36+4
 643              	.LVL47:
 644              	.L27:
 218:Src/motor.c   **** }
 645              		.loc 1 218 1 view .LVU141
 646              		@ sp needed
 647              	.LVL48:
 648              		.loc 1 218 1 view .LVU142
 649 0032 10BD     		pop	{r4, pc}
 650              	.LVL49:
 651              	.L30:
 203:Src/motor.c   **** 			break;
 652              		.loc 1 203 4 is_stmt 1 view .LVU143
 653 0034 FFF7FEFF 		bl	set_Forward
 654              	.LVL50:
 204:Src/motor.c   **** 		case LEFT:
 655              		.loc 1 204 4 view .LVU144
 200:Src/motor.c   **** 	switch(cmd->dir){
 656              		.loc 1 200 11 is_stmt 0 view .LVU145
 657 0038 0248     		ldr	r0, .L36
 204:Src/motor.c   **** 		case LEFT:
 658              		.loc 1 204 4 view .LVU146
 659 003a FAE7     		b	.L27
 660              	.L28:
 209:Src/motor.c   **** 			break;
 661              		.loc 1 209 4 is_stmt 1 view .LVU147
 662 003c FFF7FEFF 		bl	set_Right
 663              	.LVL51:
 210:Src/motor.c   **** 		case OFF:
 664              		.loc 1 210 4 view .LVU148
 200:Src/motor.c   **** 	switch(cmd->dir){
 665              		.loc 1 200 11 is_stmt 0 view .LVU149
 666 0040 0048     		ldr	r0, .L36
 210:Src/motor.c   **** 		case OFF:
 667              		.loc 1 210 4 view .LVU150
 668 0042 F6E7     		b	.L27
 669              	.L37:
 670              		.align	2
 671              	.L36:
 672 0044 00000000 		.word	.LC10
 673 0048 18000000 		.word	.LC12
 674              		.cfi_endproc
 675              	.LFE53:
 677              		.section	.text.encoder_init,"ax",%progbits
 678              		.align	1
 679              		.global	encoder_init
 680              		.syntax unified
 681              		.code	16
 682              		.thumb_func
 684              	encoder_init:
ARM GAS  /tmp/ccMw3CGW.s 			page 17


 685              	.LFB54:
 219:Src/motor.c   **** 
 220:Src/motor.c   **** // Sets up encoder interface to read motor speed
 221:Src/motor.c   **** void encoder_init(void) {
 686              		.loc 1 221 25 is_stmt 1 view -0
 687              		.cfi_startproc
 688              		@ args = 0, pretend = 0, frame = 0
 689              		@ frame_needed = 0, uses_anonymous_args = 0
 690 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 691              	.LCFI10:
 692              		.cfi_def_cfa_offset 20
 693              		.cfi_offset 4, -20
 694              		.cfi_offset 5, -16
 695              		.cfi_offset 6, -12
 696              		.cfi_offset 7, -8
 697              		.cfi_offset 14, -4
 698 0002 C646     		mov	lr, r8
 699 0004 00B5     		push	{lr}
 700              	.LCFI11:
 701              		.cfi_def_cfa_offset 24
 702              		.cfi_offset 8, -24
 222:Src/motor.c   ****     
 223:Src/motor.c   ****     // Set up encoder input pins (TIMER 3 CH1 and CH2)
 224:Src/motor.c   ****     GPIOB->MODER &= ~(GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0);
 703              		.loc 1 224 5 view .LVU152
 704              		.loc 1 224 10 is_stmt 0 view .LVU153
 705 0006 394B     		ldr	r3, .L39
 706 0008 1A68     		ldr	r2, [r3]
 707              		.loc 1 224 18 view .LVU154
 708 000a 3949     		ldr	r1, .L39+4
 709 000c 0A40     		ands	r2, r1
 710 000e 1A60     		str	r2, [r3]
 225:Src/motor.c   ****     GPIOB->MODER |= (GPIO_MODER_MODER4_1 | GPIO_MODER_MODER5_1);
 711              		.loc 1 225 5 is_stmt 1 view .LVU155
 712              		.loc 1 225 10 is_stmt 0 view .LVU156
 713 0010 1968     		ldr	r1, [r3]
 714              		.loc 1 225 18 view .LVU157
 715 0012 A022     		movs	r2, #160
 716 0014 1201     		lsls	r2, r2, #4
 717 0016 0A43     		orrs	r2, r1
 718 0018 1A60     		str	r2, [r3]
 226:Src/motor.c   ****     GPIOB->AFR[0] |= ( (1 << 16) | (1 << 20) );
 719              		.loc 1 226 5 is_stmt 1 view .LVU158
 720              		.loc 1 226 15 is_stmt 0 view .LVU159
 721 001a 196A     		ldr	r1, [r3, #32]
 722              		.loc 1 226 19 view .LVU160
 723 001c 8822     		movs	r2, #136
 724 001e 5203     		lsls	r2, r2, #13
 725 0020 0A43     		orrs	r2, r1
 726 0022 1A62     		str	r2, [r3, #32]
 227:Src/motor.c   **** 		
 228:Src/motor.c   **** 		// Set up encoder input pins (TIMER 15 CH1 and CH2)
 229:Src/motor.c   **** 		GPIOB->MODER &= ~(GPIO_MODER_MODER14_0 | GPIO_MODER_MODER15_0);
 727              		.loc 1 229 3 is_stmt 1 view .LVU161
 728              		.loc 1 229 8 is_stmt 0 view .LVU162
 729 0024 1A68     		ldr	r2, [r3]
 730              		.loc 1 229 16 view .LVU163
ARM GAS  /tmp/ccMw3CGW.s 			page 18


 731 0026 3349     		ldr	r1, .L39+8
 732 0028 0A40     		ands	r2, r1
 733 002a 1A60     		str	r2, [r3]
 230:Src/motor.c   ****     GPIOB->MODER |= (GPIO_MODER_MODER14_1 | GPIO_MODER_MODER15_1);
 734              		.loc 1 230 5 is_stmt 1 view .LVU164
 735              		.loc 1 230 10 is_stmt 0 view .LVU165
 736 002c 1968     		ldr	r1, [r3]
 737              		.loc 1 230 18 view .LVU166
 738 002e A022     		movs	r2, #160
 739 0030 1206     		lsls	r2, r2, #24
 740 0032 0A43     		orrs	r2, r1
 741 0034 1A60     		str	r2, [r3]
 231:Src/motor.c   ****     GPIOB->AFR[1] |= ( (1 << 24) | (1 << 28) );
 742              		.loc 1 231 5 is_stmt 1 view .LVU167
 743              		.loc 1 231 15 is_stmt 0 view .LVU168
 744 0036 596A     		ldr	r1, [r3, #36]
 745              		.loc 1 231 19 view .LVU169
 746 0038 8822     		movs	r2, #136
 747 003a 5205     		lsls	r2, r2, #21
 748 003c 0A43     		orrs	r2, r1
 749 003e 5A62     		str	r2, [r3, #36]
 232:Src/motor.c   **** 
 233:Src/motor.c   ****     // Set up encoder interface (TIM3 encoder input mode)
 234:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
 750              		.loc 1 234 5 is_stmt 1 view .LVU170
 751              		.loc 1 234 8 is_stmt 0 view .LVU171
 752 0040 2D49     		ldr	r1, .L39+12
 753 0042 CB69     		ldr	r3, [r1, #28]
 754              		.loc 1 234 18 view .LVU172
 755 0044 0222     		movs	r2, #2
 756 0046 1343     		orrs	r3, r2
 757 0048 CB61     		str	r3, [r1, #28]
 235:Src/motor.c   ****     TIM3->CCMR1 = 0;
 758              		.loc 1 235 5 is_stmt 1 view .LVU173
 759              		.loc 1 235 17 is_stmt 0 view .LVU174
 760 004a 2C4B     		ldr	r3, .L39+16
 761 004c 0022     		movs	r2, #0
 762 004e 9A61     		str	r2, [r3, #24]
 236:Src/motor.c   ****     TIM3->CCER = 0;
 763              		.loc 1 236 5 is_stmt 1 view .LVU175
 764              		.loc 1 236 16 is_stmt 0 view .LVU176
 765 0050 1A62     		str	r2, [r3, #32]
 237:Src/motor.c   ****     TIM3->SMCR = 0;
 766              		.loc 1 237 5 is_stmt 1 view .LVU177
 767              		.loc 1 237 16 is_stmt 0 view .LVU178
 768 0052 9A60     		str	r2, [r3, #8]
 238:Src/motor.c   ****     TIM3->CR1 = 0;
 769              		.loc 1 238 5 is_stmt 1 view .LVU179
 770              		.loc 1 238 15 is_stmt 0 view .LVU180
 771 0054 1A60     		str	r2, [r3]
 239:Src/motor.c   **** 
 240:Src/motor.c   ****     TIM3->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected 
 772              		.loc 1 240 5 is_stmt 1 view .LVU181
 773              		.loc 1 240 9 is_stmt 0 view .LVU182
 774 0056 9869     		ldr	r0, [r3, #24]
 775              		.loc 1 240 17 view .LVU183
 776 0058 0224     		movs	r4, #2
ARM GAS  /tmp/ccMw3CGW.s 			page 19


 777 005a FF34     		adds	r4, r4, #255
 778 005c A046     		mov	r8, r4
 779 005e 2043     		orrs	r0, r4
 780 0060 9861     		str	r0, [r3, #24]
 241:Src/motor.c   ****     TIM3->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and f
 781              		.loc 1 241 5 is_stmt 1 view .LVU184
 782              		.loc 1 241 9 is_stmt 0 view .LVU185
 783 0062 9868     		ldr	r0, [r3, #8]
 784              		.loc 1 241 16 view .LVU186
 785 0064 0327     		movs	r7, #3
 786 0066 3843     		orrs	r0, r7
 787 0068 9860     		str	r0, [r3, #8]
 242:Src/motor.c   ****     TIM3->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest pos
 788              		.loc 1 242 5 is_stmt 1 view .LVU187
 789              		.loc 1 242 15 is_stmt 0 view .LVU188
 790 006a 254E     		ldr	r6, .L39+20
 791 006c DE62     		str	r6, [r3, #44]
 243:Src/motor.c   ****     TIM3->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negati
 792              		.loc 1 243 5 is_stmt 1 view .LVU189
 793              		.loc 1 243 15 is_stmt 0 view .LVU190
 794 006e 254D     		ldr	r5, .L39+24
 795 0070 5D62     		str	r5, [r3, #36]
 244:Src/motor.c   ****     // (Could also cast unsigned register to signed number to get negative numbers if it rotates ba
 245:Src/motor.c   ****     //  just another option, the mid-bias is a bit simpler to understand though.)
 246:Src/motor.c   ****     TIM3->CR1 |= TIM_CR1_CEN;                               // Enable timer
 796              		.loc 1 246 5 is_stmt 1 view .LVU191
 797              		.loc 1 246 9 is_stmt 0 view .LVU192
 798 0072 1868     		ldr	r0, [r3]
 799 0074 8446     		mov	ip, r0
 800              		.loc 1 246 15 view .LVU193
 801 0076 0120     		movs	r0, #1
 802 0078 6446     		mov	r4, ip
 803 007a 0443     		orrs	r4, r0
 804 007c 1C60     		str	r4, [r3]
 247:Src/motor.c   **** 		
 248:Src/motor.c   **** 		RCC->APB2ENR |= RCC_APB2ENR_TIM15EN;
 805              		.loc 1 248 3 is_stmt 1 view .LVU194
 806              		.loc 1 248 6 is_stmt 0 view .LVU195
 807 007e 8B69     		ldr	r3, [r1, #24]
 808 0080 9C46     		mov	ip, r3
 809              		.loc 1 248 16 view .LVU196
 810 0082 8023     		movs	r3, #128
 811 0084 5B02     		lsls	r3, r3, #9
 812 0086 6446     		mov	r4, ip
 813 0088 2343     		orrs	r3, r4
 814 008a 8B61     		str	r3, [r1, #24]
 249:Src/motor.c   ****     TIM15->CCMR1 = 0;
 815              		.loc 1 249 5 is_stmt 1 view .LVU197
 816              		.loc 1 249 18 is_stmt 0 view .LVU198
 817 008c 1E4B     		ldr	r3, .L39+28
 818 008e 9A61     		str	r2, [r3, #24]
 250:Src/motor.c   ****     TIM15->CCER = 0;
 819              		.loc 1 250 5 is_stmt 1 view .LVU199
 820              		.loc 1 250 17 is_stmt 0 view .LVU200
 821 0090 1A62     		str	r2, [r3, #32]
 251:Src/motor.c   ****     TIM15->SMCR = 0;
 822              		.loc 1 251 5 is_stmt 1 view .LVU201
ARM GAS  /tmp/ccMw3CGW.s 			page 20


 823              		.loc 1 251 17 is_stmt 0 view .LVU202
 824 0092 9A60     		str	r2, [r3, #8]
 252:Src/motor.c   ****     TIM15->CR1 = 0;
 825              		.loc 1 252 5 is_stmt 1 view .LVU203
 826              		.loc 1 252 16 is_stmt 0 view .LVU204
 827 0094 1A60     		str	r2, [r3]
 253:Src/motor.c   **** 
 254:Src/motor.c   ****     TIM15->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected
 828              		.loc 1 254 5 is_stmt 1 view .LVU205
 829              		.loc 1 254 10 is_stmt 0 view .LVU206
 830 0096 9A69     		ldr	r2, [r3, #24]
 831              		.loc 1 254 18 view .LVU207
 832 0098 4446     		mov	r4, r8
 833 009a 1443     		orrs	r4, r2
 834 009c 9C61     		str	r4, [r3, #24]
 255:Src/motor.c   ****     TIM15->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and 
 835              		.loc 1 255 5 is_stmt 1 view .LVU208
 836              		.loc 1 255 10 is_stmt 0 view .LVU209
 837 009e 9A68     		ldr	r2, [r3, #8]
 838              		.loc 1 255 17 view .LVU210
 839 00a0 3A43     		orrs	r2, r7
 840 00a2 9A60     		str	r2, [r3, #8]
 256:Src/motor.c   ****     TIM15->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest po
 841              		.loc 1 256 5 is_stmt 1 view .LVU211
 842              		.loc 1 256 16 is_stmt 0 view .LVU212
 843 00a4 DE62     		str	r6, [r3, #44]
 257:Src/motor.c   ****     TIM15->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negat
 844              		.loc 1 257 5 is_stmt 1 view .LVU213
 845              		.loc 1 257 16 is_stmt 0 view .LVU214
 846 00a6 5D62     		str	r5, [r3, #36]
 258:Src/motor.c   ****     // (Could also cast unsigned register to signed number to get negative numbers if it rotates ba
 259:Src/motor.c   ****     //  just another option, the mid-bias is a bit simpler to understand though.)
 260:Src/motor.c   ****     TIM15->CR1 |= TIM_CR1_CEN;     
 847              		.loc 1 260 5 is_stmt 1 view .LVU215
 848              		.loc 1 260 10 is_stmt 0 view .LVU216
 849 00a8 1A68     		ldr	r2, [r3]
 850              		.loc 1 260 16 view .LVU217
 851 00aa 0243     		orrs	r2, r0
 852 00ac 1A60     		str	r2, [r3]
 261:Src/motor.c   **** 
 262:Src/motor.c   ****     // Configure a second timer (TIM6) to fire an ISR on update event
 263:Src/motor.c   ****     // Used to periodically check and update speed variable
 264:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
 853              		.loc 1 264 5 is_stmt 1 view .LVU218
 854              		.loc 1 264 8 is_stmt 0 view .LVU219
 855 00ae CB69     		ldr	r3, [r1, #28]
 856              		.loc 1 264 18 view .LVU220
 857 00b0 1022     		movs	r2, #16
 858 00b2 1343     		orrs	r3, r2
 859 00b4 CB61     		str	r3, [r1, #28]
 265:Src/motor.c   ****     
 266:Src/motor.c   ****     // Select PSC and ARR values that give an appropriate interrupt rate
 267:Src/motor.c   ****     TIM6->PSC = 11;
 860              		.loc 1 267 5 is_stmt 1 view .LVU221
 861              		.loc 1 267 15 is_stmt 0 view .LVU222
 862 00b6 154B     		ldr	r3, .L39+32
 863 00b8 053A     		subs	r2, r2, #5
ARM GAS  /tmp/ccMw3CGW.s 			page 21


 864 00ba 9A62     		str	r2, [r3, #40]
 268:Src/motor.c   ****     TIM6->ARR = 30000;
 865              		.loc 1 268 5 is_stmt 1 view .LVU223
 866              		.loc 1 268 15 is_stmt 0 view .LVU224
 867 00bc 144A     		ldr	r2, .L39+36
 868 00be DA62     		str	r2, [r3, #44]
 269:Src/motor.c   ****     
 270:Src/motor.c   ****     TIM6->DIER |= TIM_DIER_UIE;             // Enable update event interrupt
 869              		.loc 1 270 5 is_stmt 1 view .LVU225
 870              		.loc 1 270 9 is_stmt 0 view .LVU226
 871 00c0 DA68     		ldr	r2, [r3, #12]
 872              		.loc 1 270 16 view .LVU227
 873 00c2 0243     		orrs	r2, r0
 874 00c4 DA60     		str	r2, [r3, #12]
 271:Src/motor.c   ****     TIM6->CR1 |= TIM_CR1_CEN;               // Enable Timer
 875              		.loc 1 271 5 is_stmt 1 view .LVU228
 876              		.loc 1 271 9 is_stmt 0 view .LVU229
 877 00c6 1A68     		ldr	r2, [r3]
 878              		.loc 1 271 15 view .LVU230
 879 00c8 0243     		orrs	r2, r0
 880 00ca 1A60     		str	r2, [r3]
 272:Src/motor.c   **** 
 273:Src/motor.c   ****     NVIC_EnableIRQ(TIM6_DAC_IRQn);          // Enable interrupt in NVIC
 881              		.loc 1 273 5 is_stmt 1 view .LVU231
 882              	.LVL52:
 883              	.LBB6:
 884              	.LBI6:
 885              		.file 2 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V5.0.5
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     28. May 2018
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /*
   8:Drivers/CMSIS/Include/core_cm0.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/core_cm0.h ****  *
  10:Drivers/CMSIS/Include/core_cm0.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/core_cm0.h ****  *
  12:Drivers/CMSIS/Include/core_cm0.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/core_cm0.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/core_cm0.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/core_cm0.h ****  *
  16:Drivers/CMSIS/Include/core_cm0.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/core_cm0.h ****  *
  18:Drivers/CMSIS/Include/core_cm0.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/core_cm0.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/core_cm0.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/core_cm0.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/core_cm0.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/core_cm0.h ****  */
  24:Drivers/CMSIS/Include/core_cm0.h **** 
  25:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  26:Drivers/CMSIS/Include/core_cm0.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__clang__)
  28:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  29:Drivers/CMSIS/Include/core_cm0.h **** #endif
ARM GAS  /tmp/ccMw3CGW.s 			page 22


  30:Drivers/CMSIS/Include/core_cm0.h **** 
  31:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  32:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  35:Drivers/CMSIS/Include/core_cm0.h **** 
  36:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  37:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  38:Drivers/CMSIS/Include/core_cm0.h **** #endif
  39:Drivers/CMSIS/Include/core_cm0.h **** 
  40:Drivers/CMSIS/Include/core_cm0.h **** /**
  41:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  46:Drivers/CMSIS/Include/core_cm0.h **** 
  47:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  52:Drivers/CMSIS/Include/core_cm0.h ****  */
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h **** 
  55:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  56:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  57:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  58:Drivers/CMSIS/Include/core_cm0.h **** /**
  59:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  60:Drivers/CMSIS/Include/core_cm0.h ****   @{
  61:Drivers/CMSIS/Include/core_cm0.h ****  */
  62:Drivers/CMSIS/Include/core_cm0.h **** 
  63:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_version.h"
  64:Drivers/CMSIS/Include/core_cm0.h ****  
  65:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  66:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  69:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:Drivers/CMSIS/Include/core_cm0.h **** 
  71:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
  75:Drivers/CMSIS/Include/core_cm0.h **** */
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
  77:Drivers/CMSIS/Include/core_cm0.h **** 
  78:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
  79:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
  80:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  82:Drivers/CMSIS/Include/core_cm0.h **** 
  83:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
  85:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:Drivers/CMSIS/Include/core_cm0.h ****   #endif
ARM GAS  /tmp/ccMw3CGW.s 			page 23


  87:Drivers/CMSIS/Include/core_cm0.h **** 
  88:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  89:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  92:Drivers/CMSIS/Include/core_cm0.h **** 
  93:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  94:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
  95:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  97:Drivers/CMSIS/Include/core_cm0.h **** 
  98:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TI_ARM__ )
  99:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 100:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 102:Drivers/CMSIS/Include/core_cm0.h **** 
 103:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 104:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 105:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 107:Drivers/CMSIS/Include/core_cm0.h **** 
 108:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 109:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 110:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 112:Drivers/CMSIS/Include/core_cm0.h **** 
 113:Drivers/CMSIS/Include/core_cm0.h **** #endif
 114:Drivers/CMSIS/Include/core_cm0.h **** 
 115:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** 
 118:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 119:Drivers/CMSIS/Include/core_cm0.h **** }
 120:Drivers/CMSIS/Include/core_cm0.h **** #endif
 121:Drivers/CMSIS/Include/core_cm0.h **** 
 122:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 123:Drivers/CMSIS/Include/core_cm0.h **** 
 124:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 127:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 128:Drivers/CMSIS/Include/core_cm0.h **** 
 129:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 130:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 131:Drivers/CMSIS/Include/core_cm0.h **** #endif
 132:Drivers/CMSIS/Include/core_cm0.h **** 
 133:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 134:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 135:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 136:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 137:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 138:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 139:Drivers/CMSIS/Include/core_cm0.h **** 
 140:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 141:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 142:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 143:Drivers/CMSIS/Include/core_cm0.h ****   #endif
ARM GAS  /tmp/ccMw3CGW.s 			page 24


 144:Drivers/CMSIS/Include/core_cm0.h **** 
 145:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 146:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 147:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 148:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 149:Drivers/CMSIS/Include/core_cm0.h **** #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 152:Drivers/CMSIS/Include/core_cm0.h **** /**
 153:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 154:Drivers/CMSIS/Include/core_cm0.h **** 
 155:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 156:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 157:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 158:Drivers/CMSIS/Include/core_cm0.h **** */
 159:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 160:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 161:Drivers/CMSIS/Include/core_cm0.h **** #else
 162:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 163:Drivers/CMSIS/Include/core_cm0.h **** #endif
 164:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 165:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 166:Drivers/CMSIS/Include/core_cm0.h **** 
 167:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 168:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 169:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 170:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** 
 175:Drivers/CMSIS/Include/core_cm0.h **** 
 176:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 177:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 178:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 179:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 180:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 181:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 182:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 183:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 184:Drivers/CMSIS/Include/core_cm0.h **** /**
 185:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 186:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 187:Drivers/CMSIS/Include/core_cm0.h **** */
 188:Drivers/CMSIS/Include/core_cm0.h **** 
 189:Drivers/CMSIS/Include/core_cm0.h **** /**
 190:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 191:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 192:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 193:Drivers/CMSIS/Include/core_cm0.h ****   @{
 194:Drivers/CMSIS/Include/core_cm0.h ****  */
 195:Drivers/CMSIS/Include/core_cm0.h **** 
 196:Drivers/CMSIS/Include/core_cm0.h **** /**
 197:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 198:Drivers/CMSIS/Include/core_cm0.h ****  */
 199:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 200:Drivers/CMSIS/Include/core_cm0.h **** {
ARM GAS  /tmp/ccMw3CGW.s 			page 25


 201:Drivers/CMSIS/Include/core_cm0.h ****   struct
 202:Drivers/CMSIS/Include/core_cm0.h ****   {
 203:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 204:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 205:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 206:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 207:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 208:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 209:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 210:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 211:Drivers/CMSIS/Include/core_cm0.h **** 
 212:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 214:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 215:Drivers/CMSIS/Include/core_cm0.h **** 
 216:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 217:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 218:Drivers/CMSIS/Include/core_cm0.h **** 
 219:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 220:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 223:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 224:Drivers/CMSIS/Include/core_cm0.h **** 
 225:Drivers/CMSIS/Include/core_cm0.h **** 
 226:Drivers/CMSIS/Include/core_cm0.h **** /**
 227:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 228:Drivers/CMSIS/Include/core_cm0.h ****  */
 229:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 230:Drivers/CMSIS/Include/core_cm0.h **** {
 231:Drivers/CMSIS/Include/core_cm0.h ****   struct
 232:Drivers/CMSIS/Include/core_cm0.h ****   {
 233:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 234:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 235:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 236:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 237:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 238:Drivers/CMSIS/Include/core_cm0.h **** 
 239:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 240:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 241:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 242:Drivers/CMSIS/Include/core_cm0.h **** 
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 257:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
ARM GAS  /tmp/ccMw3CGW.s 			page 26


 258:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 259:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 260:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 261:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 262:Drivers/CMSIS/Include/core_cm0.h **** 
 263:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 264:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 268:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 274:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 275:Drivers/CMSIS/Include/core_cm0.h **** 
 276:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 277:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 278:Drivers/CMSIS/Include/core_cm0.h **** 
 279:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 280:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 281:Drivers/CMSIS/Include/core_cm0.h **** 
 282:Drivers/CMSIS/Include/core_cm0.h **** 
 283:Drivers/CMSIS/Include/core_cm0.h **** /**
 284:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 285:Drivers/CMSIS/Include/core_cm0.h ****  */
 286:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 287:Drivers/CMSIS/Include/core_cm0.h **** {
 288:Drivers/CMSIS/Include/core_cm0.h ****   struct
 289:Drivers/CMSIS/Include/core_cm0.h ****   {
 290:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 291:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 292:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 293:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 294:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 295:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 296:Drivers/CMSIS/Include/core_cm0.h **** 
 297:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 298:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 299:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 300:Drivers/CMSIS/Include/core_cm0.h **** 
 301:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 302:Drivers/CMSIS/Include/core_cm0.h **** 
 303:Drivers/CMSIS/Include/core_cm0.h **** 
 304:Drivers/CMSIS/Include/core_cm0.h **** /**
 305:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 306:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 307:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 308:Drivers/CMSIS/Include/core_cm0.h ****   @{
 309:Drivers/CMSIS/Include/core_cm0.h ****  */
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /**
 312:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 313:Drivers/CMSIS/Include/core_cm0.h ****  */
 314:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
ARM GAS  /tmp/ccMw3CGW.s 			page 27


 315:Drivers/CMSIS/Include/core_cm0.h **** {
 316:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 317:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 318:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 319:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 320:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 321:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 322:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 323:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 324:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 325:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 326:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 327:Drivers/CMSIS/Include/core_cm0.h **** 
 328:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 333:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 334:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 335:Drivers/CMSIS/Include/core_cm0.h ****   @{
 336:Drivers/CMSIS/Include/core_cm0.h ****  */
 337:Drivers/CMSIS/Include/core_cm0.h **** 
 338:Drivers/CMSIS/Include/core_cm0.h **** /**
 339:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 340:Drivers/CMSIS/Include/core_cm0.h ****  */
 341:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 342:Drivers/CMSIS/Include/core_cm0.h **** {
 343:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 344:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 345:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 346:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 347:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 348:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 349:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 350:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 351:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 352:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 353:Drivers/CMSIS/Include/core_cm0.h **** 
 354:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 355:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 356:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 357:Drivers/CMSIS/Include/core_cm0.h **** 
 358:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 359:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 360:Drivers/CMSIS/Include/core_cm0.h **** 
 361:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 362:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 363:Drivers/CMSIS/Include/core_cm0.h **** 
 364:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 365:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 366:Drivers/CMSIS/Include/core_cm0.h **** 
 367:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 368:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 369:Drivers/CMSIS/Include/core_cm0.h **** 
 370:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 371:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
ARM GAS  /tmp/ccMw3CGW.s 			page 28


 372:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 373:Drivers/CMSIS/Include/core_cm0.h **** 
 374:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 375:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 376:Drivers/CMSIS/Include/core_cm0.h **** 
 377:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 378:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 379:Drivers/CMSIS/Include/core_cm0.h **** 
 380:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 381:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 382:Drivers/CMSIS/Include/core_cm0.h **** 
 383:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 384:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 387:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 388:Drivers/CMSIS/Include/core_cm0.h **** 
 389:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 390:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 391:Drivers/CMSIS/Include/core_cm0.h **** 
 392:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 393:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 394:Drivers/CMSIS/Include/core_cm0.h **** 
 395:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 396:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 397:Drivers/CMSIS/Include/core_cm0.h **** 
 398:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 399:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 400:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** 
 405:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** 
 408:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** 
 411:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** 
 414:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** 
 421:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** 
 424:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
ARM GAS  /tmp/ccMw3CGW.s 			page 29


 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 434:Drivers/CMSIS/Include/core_cm0.h **** 
 435:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** 
 438:Drivers/CMSIS/Include/core_cm0.h **** /**
 439:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 440:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 441:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 442:Drivers/CMSIS/Include/core_cm0.h ****   @{
 443:Drivers/CMSIS/Include/core_cm0.h ****  */
 444:Drivers/CMSIS/Include/core_cm0.h **** 
 445:Drivers/CMSIS/Include/core_cm0.h **** /**
 446:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 447:Drivers/CMSIS/Include/core_cm0.h ****  */
 448:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 449:Drivers/CMSIS/Include/core_cm0.h **** {
 450:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 451:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 452:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 453:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 454:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 458:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 459:Drivers/CMSIS/Include/core_cm0.h **** 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 461:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 462:Drivers/CMSIS/Include/core_cm0.h **** 
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 471:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 472:Drivers/CMSIS/Include/core_cm0.h **** 
 473:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 475:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 476:Drivers/CMSIS/Include/core_cm0.h **** 
 477:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 478:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 479:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 480:Drivers/CMSIS/Include/core_cm0.h **** 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 482:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 483:Drivers/CMSIS/Include/core_cm0.h **** 
 484:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 485:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
ARM GAS  /tmp/ccMw3CGW.s 			page 30


 486:Drivers/CMSIS/Include/core_cm0.h **** 
 487:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 488:Drivers/CMSIS/Include/core_cm0.h **** 
 489:Drivers/CMSIS/Include/core_cm0.h **** 
 490:Drivers/CMSIS/Include/core_cm0.h **** /**
 491:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 492:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 493:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 494:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 495:Drivers/CMSIS/Include/core_cm0.h ****   @{
 496:Drivers/CMSIS/Include/core_cm0.h ****  */
 497:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 498:Drivers/CMSIS/Include/core_cm0.h **** 
 499:Drivers/CMSIS/Include/core_cm0.h **** 
 500:Drivers/CMSIS/Include/core_cm0.h **** /**
 501:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 502:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 503:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 504:Drivers/CMSIS/Include/core_cm0.h ****   @{
 505:Drivers/CMSIS/Include/core_cm0.h ****  */
 506:Drivers/CMSIS/Include/core_cm0.h **** 
 507:Drivers/CMSIS/Include/core_cm0.h **** /**
 508:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 509:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 510:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 511:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 512:Drivers/CMSIS/Include/core_cm0.h **** */
 513:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 514:Drivers/CMSIS/Include/core_cm0.h **** 
 515:Drivers/CMSIS/Include/core_cm0.h **** /**
 516:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 517:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 518:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 519:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 520:Drivers/CMSIS/Include/core_cm0.h **** */
 521:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 522:Drivers/CMSIS/Include/core_cm0.h **** 
 523:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** 
 526:Drivers/CMSIS/Include/core_cm0.h **** /**
 527:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 528:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 529:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 530:Drivers/CMSIS/Include/core_cm0.h ****   @{
 531:Drivers/CMSIS/Include/core_cm0.h ****  */
 532:Drivers/CMSIS/Include/core_cm0.h **** 
 533:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Core Hardware */
 534:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 535:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 536:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 537:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 538:Drivers/CMSIS/Include/core_cm0.h **** 
 539:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 540:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 541:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 542:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/ccMw3CGW.s 			page 31


 543:Drivers/CMSIS/Include/core_cm0.h **** 
 544:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 545:Drivers/CMSIS/Include/core_cm0.h **** 
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 549:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 550:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 551:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 552:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 553:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 554:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 557:Drivers/CMSIS/Include/core_cm0.h **** */
 558:Drivers/CMSIS/Include/core_cm0.h **** 
 559:Drivers/CMSIS/Include/core_cm0.h **** 
 560:Drivers/CMSIS/Include/core_cm0.h **** 
 561:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 562:Drivers/CMSIS/Include/core_cm0.h **** /**
 563:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 564:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 565:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 566:Drivers/CMSIS/Include/core_cm0.h ****   @{
 567:Drivers/CMSIS/Include/core_cm0.h ****  */
 568:Drivers/CMSIS/Include/core_cm0.h **** 
 569:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_NVIC_VIRTUAL
 570:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 571:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 572:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 573:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 574:Drivers/CMSIS/Include/core_cm0.h **** #else
 575:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
 576:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
 577:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 578:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 579:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 580:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 581:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 582:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 583:Drivers/CMSIS/Include/core_cm0.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
 584:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 585:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 586:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 587:Drivers/CMSIS/Include/core_cm0.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 588:Drivers/CMSIS/Include/core_cm0.h **** 
 589:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 590:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 591:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 592:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 593:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 594:Drivers/CMSIS/Include/core_cm0.h **** #else
 595:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetVector              __NVIC_SetVector
 596:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetVector              __NVIC_GetVector
 597:Drivers/CMSIS/Include/core_cm0.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 598:Drivers/CMSIS/Include/core_cm0.h **** 
 599:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_USER_IRQ_OFFSET          16
ARM GAS  /tmp/ccMw3CGW.s 			page 32


 600:Drivers/CMSIS/Include/core_cm0.h **** 
 601:Drivers/CMSIS/Include/core_cm0.h **** 
 602:Drivers/CMSIS/Include/core_cm0.h **** /* The following EXC_RETURN values are saved the LR on exception entry */
 603:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after ret
 604:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after retu
 605:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after retu
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under Armv6-M                  */
 609:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 610:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 611:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 612:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 613:Drivers/CMSIS/Include/core_cm0.h **** 
 614:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_SetPriorityGrouping(X) (void)(X)
 615:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_GetPriorityGrouping()  (0U)
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /**
 618:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable Interrupt
 619:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 620:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 621:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 622:Drivers/CMSIS/Include/core_cm0.h ****  */
 623:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 886              		.loc 2 623 22 view .LVU232
 887              	.LBB7:
 624:Drivers/CMSIS/Include/core_cm0.h **** {
 625:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 888              		.loc 2 625 3 view .LVU233
 626:Drivers/CMSIS/Include/core_cm0.h ****   {
 627:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 889              		.loc 2 627 5 view .LVU234
 890              		.loc 2 627 20 is_stmt 0 view .LVU235
 891 00cc 114B     		ldr	r3, .L39+40
 892 00ce 8022     		movs	r2, #128
 893 00d0 9202     		lsls	r2, r2, #10
 894 00d2 1A60     		str	r2, [r3]
 895              	.LVL53:
 896              		.loc 2 627 20 view .LVU236
 897              	.LBE7:
 898              	.LBE6:
 274:Src/motor.c   ****     NVIC_SetPriority(TIM6_DAC_IRQn,2);
 899              		.loc 1 274 5 is_stmt 1 view .LVU237
 900              	.LBB8:
 901              	.LBI8:
 628:Drivers/CMSIS/Include/core_cm0.h ****   }
 629:Drivers/CMSIS/Include/core_cm0.h **** }
 630:Drivers/CMSIS/Include/core_cm0.h **** 
 631:Drivers/CMSIS/Include/core_cm0.h **** 
 632:Drivers/CMSIS/Include/core_cm0.h **** /**
 633:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Enable status
 634:Drivers/CMSIS/Include/core_cm0.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 635:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 636:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt is not enabled.
 637:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt is enabled.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
ARM GAS  /tmp/ccMw3CGW.s 			page 33


 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 643:Drivers/CMSIS/Include/core_cm0.h ****   {
 644:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 645:Drivers/CMSIS/Include/core_cm0.h ****   }
 646:Drivers/CMSIS/Include/core_cm0.h ****   else
 647:Drivers/CMSIS/Include/core_cm0.h ****   {
 648:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 649:Drivers/CMSIS/Include/core_cm0.h ****   }
 650:Drivers/CMSIS/Include/core_cm0.h **** }
 651:Drivers/CMSIS/Include/core_cm0.h **** 
 652:Drivers/CMSIS/Include/core_cm0.h **** 
 653:Drivers/CMSIS/Include/core_cm0.h **** /**
 654:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable Interrupt
 655:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 656:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 657:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 658:Drivers/CMSIS/Include/core_cm0.h ****  */
 659:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 660:Drivers/CMSIS/Include/core_cm0.h **** {
 661:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 662:Drivers/CMSIS/Include/core_cm0.h ****   {
 663:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 664:Drivers/CMSIS/Include/core_cm0.h ****     __DSB();
 665:Drivers/CMSIS/Include/core_cm0.h ****     __ISB();
 666:Drivers/CMSIS/Include/core_cm0.h ****   }
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 674:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 675:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 676:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 677:Drivers/CMSIS/Include/core_cm0.h ****  */
 678:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 679:Drivers/CMSIS/Include/core_cm0.h **** {
 680:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 681:Drivers/CMSIS/Include/core_cm0.h ****   {
 682:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 683:Drivers/CMSIS/Include/core_cm0.h ****   }
 684:Drivers/CMSIS/Include/core_cm0.h ****   else
 685:Drivers/CMSIS/Include/core_cm0.h ****   {
 686:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 687:Drivers/CMSIS/Include/core_cm0.h ****   }
 688:Drivers/CMSIS/Include/core_cm0.h **** }
 689:Drivers/CMSIS/Include/core_cm0.h **** 
 690:Drivers/CMSIS/Include/core_cm0.h **** 
 691:Drivers/CMSIS/Include/core_cm0.h **** /**
 692:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 693:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 694:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 695:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 696:Drivers/CMSIS/Include/core_cm0.h ****  */
ARM GAS  /tmp/ccMw3CGW.s 			page 34


 697:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 698:Drivers/CMSIS/Include/core_cm0.h **** {
 699:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 700:Drivers/CMSIS/Include/core_cm0.h ****   {
 701:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 702:Drivers/CMSIS/Include/core_cm0.h ****   }
 703:Drivers/CMSIS/Include/core_cm0.h **** }
 704:Drivers/CMSIS/Include/core_cm0.h **** 
 705:Drivers/CMSIS/Include/core_cm0.h **** 
 706:Drivers/CMSIS/Include/core_cm0.h **** /**
 707:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 708:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 710:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 715:Drivers/CMSIS/Include/core_cm0.h ****   {
 716:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 717:Drivers/CMSIS/Include/core_cm0.h ****   }
 718:Drivers/CMSIS/Include/core_cm0.h **** }
 719:Drivers/CMSIS/Include/core_cm0.h **** 
 720:Drivers/CMSIS/Include/core_cm0.h **** 
 721:Drivers/CMSIS/Include/core_cm0.h **** /**
 722:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 723:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 724:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 725:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 726:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 727:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 728:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every processor exception.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 902              		.loc 2 730 22 view .LVU238
 903              	.LBB9:
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 904              		.loc 2 732 3 view .LVU239
 733:Drivers/CMSIS/Include/core_cm0.h ****   {
 734:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 905              		.loc 2 734 5 view .LVU240
 906              		.loc 2 734 52 is_stmt 0 view .LVU241
 907 00d4 C420     		movs	r0, #196
 908 00d6 8000     		lsls	r0, r0, #2
 909 00d8 1958     		ldr	r1, [r3, r0]
 910              		.loc 2 734 33 view .LVU242
 911 00da 0F4A     		ldr	r2, .L39+44
 912 00dc 1140     		ands	r1, r2
 913              		.loc 2 734 102 view .LVU243
 914 00de 8022     		movs	r2, #128
 915 00e0 1202     		lsls	r2, r2, #8
 916 00e2 0A43     		orrs	r2, r1
 917              		.loc 2 734 30 view .LVU244
 918 00e4 1A50     		str	r2, [r3, r0]
 919              	.LVL54:
 920              		.loc 2 734 30 view .LVU245
ARM GAS  /tmp/ccMw3CGW.s 			page 35


 921              	.LBE9:
 922              	.LBE8:
 275:Src/motor.c   **** }
 923              		.loc 1 275 1 view .LVU246
 924              		@ sp needed
 925 00e6 80BC     		pop	{r7}
 926 00e8 B846     		mov	r8, r7
 927 00ea F0BD     		pop	{r4, r5, r6, r7, pc}
 928              	.L40:
 929              		.align	2
 930              	.L39:
 931 00ec 00040048 		.word	1207960576
 932 00f0 FFFAFFFF 		.word	-1281
 933 00f4 FFFFFFAF 		.word	-1342177281
 934 00f8 00100240 		.word	1073876992
 935 00fc 00040040 		.word	1073742848
 936 0100 FFFF0000 		.word	65535
 937 0104 FF7F0000 		.word	32767
 938 0108 00400140 		.word	1073823744
 939 010c 00100040 		.word	1073745920
 940 0110 30750000 		.word	30000
 941 0114 00E100E0 		.word	-536813312
 942 0118 FF00FFFF 		.word	-65281
 943              		.cfi_endproc
 944              	.LFE54:
 946              		.section	.text.TIM6_DAC_IRQHandler,"ax",%progbits
 947              		.align	1
 948              		.global	TIM6_DAC_IRQHandler
 949              		.syntax unified
 950              		.code	16
 951              		.thumb_func
 953              	TIM6_DAC_IRQHandler:
 954              	.LFB55:
 276:Src/motor.c   **** 
 277:Src/motor.c   **** // Encoder interrupt to calculate motor speed, also manages PI controller
 278:Src/motor.c   **** void TIM6_DAC_IRQHandler(void) {
 955              		.loc 1 278 32 is_stmt 1 view -0
 956              		.cfi_startproc
 957              		@ args = 0, pretend = 0, frame = 0
 958              		@ frame_needed = 0, uses_anonymous_args = 0
 959              		@ link register save eliminated.
 279:Src/motor.c   ****     /* Calculate the motor speed in raw encoder counts
 280:Src/motor.c   ****      * Note the motor speed is signed! Motor can be run in reverse.
 281:Src/motor.c   ****      * Speed is measured by how far the counter moved from center point
 282:Src/motor.c   ****      */
 283:Src/motor.c   ****     motorl_speed = (TIM3->CNT - 0x7FFF);
 960              		.loc 1 283 5 view .LVU248
 961              		.loc 1 283 25 is_stmt 0 view .LVU249
 962 0000 0B4A     		ldr	r2, .L42
 963 0002 536A     		ldr	r3, [r2, #36]
 964              		.loc 1 283 31 view .LVU250
 965 0004 0B49     		ldr	r1, .L42+4
 966 0006 8C46     		mov	ip, r1
 967 0008 6344     		add	r3, r3, ip
 968 000a 1BB2     		sxth	r3, r3
 969              		.loc 1 283 18 view .LVU251
 970 000c 0A49     		ldr	r1, .L42+8
ARM GAS  /tmp/ccMw3CGW.s 			page 36


 971 000e 0B80     		strh	r3, [r1]
 284:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 972              		.loc 1 284 5 is_stmt 1 view .LVU252
 973              		.loc 1 284 15 is_stmt 0 view .LVU253
 974 0010 0A49     		ldr	r1, .L42+12
 975 0012 5162     		str	r1, [r2, #36]
 285:Src/motor.c   **** 	  motorr_speed = (TIM15->CNT - 0x7FFF);
 976              		.loc 1 285 4 is_stmt 1 view .LVU254
 977              		.loc 1 285 25 is_stmt 0 view .LVU255
 978 0014 0A4A     		ldr	r2, .L42+16
 979 0016 536A     		ldr	r3, [r2, #36]
 980              		.loc 1 285 31 view .LVU256
 981 0018 6344     		add	r3, r3, ip
 982 001a 1BB2     		sxth	r3, r3
 983              		.loc 1 285 17 view .LVU257
 984 001c 0948     		ldr	r0, .L42+20
 985 001e 0380     		strh	r3, [r0]
 286:Src/motor.c   ****     TIM15->CNT = 0x7FFF; // Reset back to center point
 986              		.loc 1 286 5 is_stmt 1 view .LVU258
 987              		.loc 1 286 16 is_stmt 0 view .LVU259
 988 0020 5162     		str	r1, [r2, #36]
 287:Src/motor.c   ****     
 288:Src/motor.c   ****     // Call the PI update function
 289:Src/motor.c   ****     TIM6->SR &= ~TIM_SR_UIF;        // Acknowledge the interrupt
 989              		.loc 1 289 5 is_stmt 1 view .LVU260
 990              		.loc 1 289 9 is_stmt 0 view .LVU261
 991 0022 094A     		ldr	r2, .L42+24
 992 0024 1369     		ldr	r3, [r2, #16]
 993              		.loc 1 289 14 view .LVU262
 994 0026 0121     		movs	r1, #1
 995 0028 8B43     		bics	r3, r1
 996 002a 1361     		str	r3, [r2, #16]
 290:Src/motor.c   **** }
 997              		.loc 1 290 1 view .LVU263
 998              		@ sp needed
 999 002c 7047     		bx	lr
 1000              	.L43:
 1001 002e C046     		.align	2
 1002              	.L42:
 1003 0030 00040040 		.word	1073742848
 1004 0034 0180FFFF 		.word	-32767
 1005 0038 00000000 		.word	motorl_speed
 1006 003c FF7F0000 		.word	32767
 1007 0040 00400140 		.word	1073823744
 1008 0044 00000000 		.word	motorr_speed
 1009 0048 00100040 		.word	1073745920
 1010              		.cfi_endproc
 1011              	.LFE55:
 1013              		.section	.text.ADC_init,"ax",%progbits
 1014              		.align	1
 1015              		.global	ADC_init
 1016              		.syntax unified
 1017              		.code	16
 1018              		.thumb_func
 1020              	ADC_init:
 1021              	.LFB56:
 291:Src/motor.c   **** 
ARM GAS  /tmp/ccMw3CGW.s 			page 37


 292:Src/motor.c   **** void ADC_init(void) {
 1022              		.loc 1 292 21 is_stmt 1 view -0
 1023              		.cfi_startproc
 1024              		@ args = 0, pretend = 0, frame = 0
 1025              		@ frame_needed = 0, uses_anonymous_args = 0
 1026              		@ link register save eliminated.
 293:Src/motor.c   **** 
 294:Src/motor.c   ****     // Configure PA1 for ADC input (used for current monitoring)
 295:Src/motor.c   ****     GPIOA->MODER |= (GPIO_MODER_MODER1_0 | GPIO_MODER_MODER1_1);
 1027              		.loc 1 295 5 view .LVU265
 1028              		.loc 1 295 10 is_stmt 0 view .LVU266
 1029 0000 9022     		movs	r2, #144
 1030 0002 D205     		lsls	r2, r2, #23
 1031 0004 1368     		ldr	r3, [r2]
 1032              		.loc 1 295 18 view .LVU267
 1033 0006 0C21     		movs	r1, #12
 1034 0008 0B43     		orrs	r3, r1
 1035 000a 1360     		str	r3, [r2]
 296:Src/motor.c   **** 
 297:Src/motor.c   ****     // Configure ADC to 8-bit continuous-run mode, (asynchronous clock mode)
 298:Src/motor.c   ****     RCC->APB2ENR |= RCC_APB2ENR_ADCEN;
 1036              		.loc 1 298 5 is_stmt 1 view .LVU268
 1037              		.loc 1 298 8 is_stmt 0 view .LVU269
 1038 000c 154A     		ldr	r2, .L48
 1039 000e 9169     		ldr	r1, [r2, #24]
 1040              		.loc 1 298 18 view .LVU270
 1041 0010 8023     		movs	r3, #128
 1042 0012 9B00     		lsls	r3, r3, #2
 1043 0014 0B43     		orrs	r3, r1
 1044 0016 9361     		str	r3, [r2, #24]
 299:Src/motor.c   **** 
 300:Src/motor.c   ****     ADC1->CFGR1 = 0;                        // Default resolution is 12-bit (RES[1:0] = 00 --> 12-b
 1045              		.loc 1 300 5 is_stmt 1 view .LVU271
 1046              		.loc 1 300 17 is_stmt 0 view .LVU272
 1047 0018 134B     		ldr	r3, .L48+4
 1048 001a 0021     		movs	r1, #0
 1049 001c D960     		str	r1, [r3, #12]
 301:Src/motor.c   ****     ADC1->CFGR1 |= ADC_CFGR1_CONT;          // Set to continuous mode
 1050              		.loc 1 301 5 is_stmt 1 view .LVU273
 1051              		.loc 1 301 9 is_stmt 0 view .LVU274
 1052 001e D868     		ldr	r0, [r3, #12]
 1053              		.loc 1 301 17 view .LVU275
 1054 0020 8022     		movs	r2, #128
 1055 0022 9201     		lsls	r2, r2, #6
 1056 0024 0243     		orrs	r2, r0
 1057 0026 DA60     		str	r2, [r3, #12]
 302:Src/motor.c   ****     ADC1->CHSELR |= ADC_CHSELR_CHSEL1;      // Enable channel 1
 1058              		.loc 1 302 5 is_stmt 1 view .LVU276
 1059              		.loc 1 302 9 is_stmt 0 view .LVU277
 1060 0028 9A6A     		ldr	r2, [r3, #40]
 1061              		.loc 1 302 18 view .LVU278
 1062 002a 0220     		movs	r0, #2
 1063 002c 0243     		orrs	r2, r0
 1064 002e 9A62     		str	r2, [r3, #40]
 303:Src/motor.c   **** 
 304:Src/motor.c   ****     ADC1->CR = 0;
 1065              		.loc 1 304 5 is_stmt 1 view .LVU279
ARM GAS  /tmp/ccMw3CGW.s 			page 38


 1066              		.loc 1 304 14 is_stmt 0 view .LVU280
 1067 0030 9960     		str	r1, [r3, #8]
 305:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADCAL;               // Perform self calibration
 1068              		.loc 1 305 5 is_stmt 1 view .LVU281
 1069              		.loc 1 305 9 is_stmt 0 view .LVU282
 1070 0032 9968     		ldr	r1, [r3, #8]
 1071              		.loc 1 305 14 view .LVU283
 1072 0034 8022     		movs	r2, #128
 1073 0036 1206     		lsls	r2, r2, #24
 1074 0038 0A43     		orrs	r2, r1
 1075 003a 9A60     		str	r2, [r3, #8]
 306:Src/motor.c   ****     while(ADC1->CR & ADC_CR_ADCAL);         // Delay until calibration is complete
 1076              		.loc 1 306 5 is_stmt 1 view .LVU284
 1077              	.L45:
 1078              		.loc 1 306 11 discriminator 1 view .LVU285
 1079              		.loc 1 306 15 is_stmt 0 discriminator 1 view .LVU286
 1080 003c 0A4B     		ldr	r3, .L48+4
 1081 003e 9B68     		ldr	r3, [r3, #8]
 1082              		.loc 1 306 11 discriminator 1 view .LVU287
 1083 0040 002B     		cmp	r3, #0
 1084 0042 FBDB     		blt	.L45
 307:Src/motor.c   **** 
 308:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADEN;                // Enable ADC
 1085              		.loc 1 308 5 is_stmt 1 view .LVU288
 1086              		.loc 1 308 9 is_stmt 0 view .LVU289
 1087 0044 084A     		ldr	r2, .L48+4
 1088 0046 9368     		ldr	r3, [r2, #8]
 1089              		.loc 1 308 14 view .LVU290
 1090 0048 0121     		movs	r1, #1
 1091 004a 0B43     		orrs	r3, r1
 1092 004c 9360     		str	r3, [r2, #8]
 309:Src/motor.c   ****     while(!(ADC1->ISR & ADC_ISR_ADRDY));    // Wait until ADC ready
 1093              		.loc 1 309 5 is_stmt 1 view .LVU291
 1094              	.L46:
 1095              		.loc 1 309 11 discriminator 1 view .LVU292
 1096              		.loc 1 309 17 is_stmt 0 discriminator 1 view .LVU293
 1097 004e 064B     		ldr	r3, .L48+4
 1098 0050 1B68     		ldr	r3, [r3]
 1099              		.loc 1 309 11 discriminator 1 view .LVU294
 1100 0052 DB07     		lsls	r3, r3, #31
 1101 0054 FBD5     		bpl	.L46
 310:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADSTART;             // Signal conversion start
 1102              		.loc 1 310 5 is_stmt 1 view .LVU295
 1103              		.loc 1 310 9 is_stmt 0 view .LVU296
 1104 0056 044A     		ldr	r2, .L48+4
 1105 0058 9368     		ldr	r3, [r2, #8]
 1106              		.loc 1 310 14 view .LVU297
 1107 005a 0421     		movs	r1, #4
 1108 005c 0B43     		orrs	r3, r1
 1109 005e 9360     		str	r3, [r2, #8]
 311:Src/motor.c   **** }
 1110              		.loc 1 311 1 view .LVU298
 1111              		@ sp needed
 1112 0060 7047     		bx	lr
 1113              	.L49:
 1114 0062 C046     		.align	2
 1115              	.L48:
ARM GAS  /tmp/ccMw3CGW.s 			page 39


 1116 0064 00100240 		.word	1073876992
 1117 0068 00240140 		.word	1073816576
 1118              		.cfi_endproc
 1119              	.LFE56:
 1121              		.section	.text.motor_init,"ax",%progbits
 1122              		.align	1
 1123              		.global	motor_init
 1124              		.syntax unified
 1125              		.code	16
 1126              		.thumb_func
 1128              	motor_init:
 1129              	.LFB43:
  18:Src/motor.c   ****     pwm_init();
 1130              		.loc 1 18 23 is_stmt 1 view -0
 1131              		.cfi_startproc
 1132              		@ args = 0, pretend = 0, frame = 0
 1133              		@ frame_needed = 0, uses_anonymous_args = 0
 1134 0000 10B5     		push	{r4, lr}
 1135              	.LCFI12:
 1136              		.cfi_def_cfa_offset 8
 1137              		.cfi_offset 4, -8
 1138              		.cfi_offset 14, -4
  19:Src/motor.c   ****     encoder_init();
 1139              		.loc 1 19 5 view .LVU300
 1140 0002 FFF7FEFF 		bl	pwm_init
 1141              	.LVL55:
  20:Src/motor.c   ****     ADC_init();
 1142              		.loc 1 20 5 view .LVU301
 1143 0006 FFF7FEFF 		bl	encoder_init
 1144              	.LVL56:
  21:Src/motor.c   **** }
 1145              		.loc 1 21 5 view .LVU302
 1146 000a FFF7FEFF 		bl	ADC_init
 1147              	.LVL57:
  22:Src/motor.c   **** 
 1148              		.loc 1 22 1 is_stmt 0 view .LVU303
 1149              		@ sp needed
 1150 000e 10BD     		pop	{r4, pc}
 1151              		.cfi_endproc
 1152              	.LFE43:
 1154              		.global	Ki
 1155              		.section	.data.Ki,"aw"
 1158              	Ki:
 1159 0000 01       		.byte	1
 1160              		.global	Kp
 1161              		.section	.data.Kp,"aw"
 1164              	Kp:
 1165 0000 01       		.byte	1
 1166              		.global	error
 1167              		.section	.bss.error,"aw",%nobits
 1168              		.align	1
 1171              	error:
 1172 0000 0000     		.space	2
 1173              		.global	adc_value
 1174              		.section	.bss.adc_value,"aw",%nobits
 1177              	adc_value:
 1178 0000 00       		.space	1
ARM GAS  /tmp/ccMw3CGW.s 			page 40


 1179              		.global	motorr_speed
 1180              		.section	.bss.motorr_speed,"aw",%nobits
 1181              		.align	1
 1184              	motorr_speed:
 1185 0000 0000     		.space	2
 1186              		.global	motorl_speed
 1187              		.section	.bss.motorl_speed,"aw",%nobits
 1188              		.align	1
 1191              	motorl_speed:
 1192 0000 0000     		.space	2
 1193              		.global	target_rpm
 1194              		.section	.bss.target_rpm,"aw",%nobits
 1195              		.align	1
 1198              	target_rpm:
 1199 0000 0000     		.space	2
 1200              		.global	duty_cycle
 1201              		.section	.bss.duty_cycle,"aw",%nobits
 1204              	duty_cycle:
 1205 0000 00       		.space	1
 1206              		.global	error_integral
 1207              		.section	.bss.error_integral,"aw",%nobits
 1208              		.align	1
 1211              	error_integral:
 1212 0000 0000     		.space	2
 1213              		.text
 1214              	.Letext0:
 1215              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1216              		.file 4 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
 1217              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1218              		.file 6 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h"
 1219              		.file 7 "Inc/pins.h"
 1220              		.file 8 "Inc/motor.h"
ARM GAS  /tmp/ccMw3CGW.s 			page 41


DEFINED SYMBOLS
                            *ABS*:00000000 motor.c
     /tmp/ccMw3CGW.s:19     .text.pwm_init:00000000 $t
     /tmp/ccMw3CGW.s:25     .text.pwm_init:00000000 pwm_init
     /tmp/ccMw3CGW.s:172    .text.pwm_init:00000094 $d
     /tmp/ccMw3CGW.s:181    .text.pwm_setDutyCycleL:00000000 $t
     /tmp/ccMw3CGW.s:187    .text.pwm_setDutyCycleL:00000000 pwm_setDutyCycleL
     /tmp/ccMw3CGW.s:224    .text.pwm_setDutyCycleL:00000018 $d
     /tmp/ccMw3CGW.s:229    .text.pwm_setDutyCycleR:00000000 $t
     /tmp/ccMw3CGW.s:235    .text.pwm_setDutyCycleR:00000000 pwm_setDutyCycleR
     /tmp/ccMw3CGW.s:274    .text.set_Motor_Direction:00000000 $t
     /tmp/ccMw3CGW.s:280    .text.set_Motor_Direction:00000000 set_Motor_Direction
     /tmp/ccMw3CGW.s:352    .text.set_Forward:00000000 $t
     /tmp/ccMw3CGW.s:358    .text.set_Forward:00000000 set_Forward
     /tmp/ccMw3CGW.s:393    .text.set_Forward:00000020 $d
     /tmp/ccMw3CGW.s:399    .text.set_Backward:00000000 $t
     /tmp/ccMw3CGW.s:405    .text.set_Backward:00000000 set_Backward
     /tmp/ccMw3CGW.s:440    .text.set_Backward:00000020 $d
     /tmp/ccMw3CGW.s:446    .text.set_Right:00000000 $t
     /tmp/ccMw3CGW.s:452    .text.set_Right:00000000 set_Right
     /tmp/ccMw3CGW.s:487    .text.set_Right:00000020 $d
     /tmp/ccMw3CGW.s:493    .text.set_Left:00000000 $t
     /tmp/ccMw3CGW.s:499    .text.set_Left:00000000 set_Left
     /tmp/ccMw3CGW.s:534    .text.set_Left:00000020 $d
     /tmp/ccMw3CGW.s:540    .text.motors_Off:00000000 $t
     /tmp/ccMw3CGW.s:546    .text.motors_Off:00000000 motors_Off
     /tmp/ccMw3CGW.s:572    .rodata.MoveMotors.str1.4:00000000 $d
     /tmp/ccMw3CGW.s:579    .text.MoveMotors:00000000 $t
     /tmp/ccMw3CGW.s:585    .text.MoveMotors:00000000 MoveMotors
     /tmp/ccMw3CGW.s:672    .text.MoveMotors:00000044 $d
     /tmp/ccMw3CGW.s:678    .text.encoder_init:00000000 $t
     /tmp/ccMw3CGW.s:684    .text.encoder_init:00000000 encoder_init
     /tmp/ccMw3CGW.s:931    .text.encoder_init:000000ec $d
     /tmp/ccMw3CGW.s:947    .text.TIM6_DAC_IRQHandler:00000000 $t
     /tmp/ccMw3CGW.s:953    .text.TIM6_DAC_IRQHandler:00000000 TIM6_DAC_IRQHandler
     /tmp/ccMw3CGW.s:1003   .text.TIM6_DAC_IRQHandler:00000030 $d
     /tmp/ccMw3CGW.s:1191   .bss.motorl_speed:00000000 motorl_speed
     /tmp/ccMw3CGW.s:1184   .bss.motorr_speed:00000000 motorr_speed
     /tmp/ccMw3CGW.s:1014   .text.ADC_init:00000000 $t
     /tmp/ccMw3CGW.s:1020   .text.ADC_init:00000000 ADC_init
     /tmp/ccMw3CGW.s:1116   .text.ADC_init:00000064 $d
     /tmp/ccMw3CGW.s:1122   .text.motor_init:00000000 $t
     /tmp/ccMw3CGW.s:1128   .text.motor_init:00000000 motor_init
     /tmp/ccMw3CGW.s:1158   .data.Ki:00000000 Ki
     /tmp/ccMw3CGW.s:1164   .data.Kp:00000000 Kp
     /tmp/ccMw3CGW.s:1171   .bss.error:00000000 error
     /tmp/ccMw3CGW.s:1168   .bss.error:00000000 $d
     /tmp/ccMw3CGW.s:1177   .bss.adc_value:00000000 adc_value
     /tmp/ccMw3CGW.s:1178   .bss.adc_value:00000000 $d
     /tmp/ccMw3CGW.s:1181   .bss.motorr_speed:00000000 $d
     /tmp/ccMw3CGW.s:1188   .bss.motorl_speed:00000000 $d
     /tmp/ccMw3CGW.s:1198   .bss.target_rpm:00000000 target_rpm
     /tmp/ccMw3CGW.s:1195   .bss.target_rpm:00000000 $d
     /tmp/ccMw3CGW.s:1204   .bss.duty_cycle:00000000 duty_cycle
     /tmp/ccMw3CGW.s:1205   .bss.duty_cycle:00000000 $d
     /tmp/ccMw3CGW.s:1211   .bss.error_integral:00000000 error_integral
     /tmp/ccMw3CGW.s:1208   .bss.error_integral:00000000 $d
ARM GAS  /tmp/ccMw3CGW.s 			page 42



UNDEFINED SYMBOLS
HAL_GPIO_WritePin
motor_left_pins
motor_right_pins
__aeabi_uidiv
