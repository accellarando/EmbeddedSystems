ARM GAS  /tmp/cclLk6It.s 			page 1


   1              		.cpu cortex-m0
   2              		.arch armv6s-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"motor.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "Src/motor.c"
  18              		.section	.text.pwm_init,"ax",%progbits
  19              		.align	1
  20              		.global	pwm_init
  21              		.syntax unified
  22              		.code	16
  23              		.thumb_func
  25              	pwm_init:
  26              	.LFB44:
   1:Src/motor.c   **** /* ------------------------------------------------------------------------------------------------
   2:Src/motor.c   ****  *  Motor Control and Initialization Functions
   3:Src/motor.c   ****  * ------------------------------------------------------------------------------------------------
   4:Src/motor.c   ****  */
   5:Src/motor.c   **** #include "motor.h"
   6:Src/motor.c   **** #include "main.h"
   7:Src/motor.c   **** #include <math.h>
   8:Src/motor.c   **** 
   9:Src/motor.c   **** volatile int16_t motorl_speed = 0;   	// Measured left motor speed
  10:Src/motor.c   **** volatile int16_t motorr_speed = 0;   	// Measured left motor speed
  11:Src/motor.c   **** volatile uint8_t target_dist = 0;
  12:Src/motor.c   **** volatile float current_dist = 0;
  13:Src/motor.c   **** volatile float absolute_dist = 0;
  14:Src/motor.c   **** volatile float heading = 0;
  15:Src/motor.c   **** volatile bool turning = false;
  16:Src/motor.c   **** 
  17:Src/motor.c   **** #define max(a,b) ((a>b) ? a : b)
  18:Src/motor.c   **** #define min(a,b) ((a>b) ? b : a)
  19:Src/motor.c   **** 
  20:Src/motor.c   **** #define PRINT_DEBUG 1
  21:Src/motor.c   **** #define STOP_ULTRASONIC 20 //cm
  22:Src/motor.c   **** 
  23:Src/motor.c   **** // Sets up the entire motor drive system
  24:Src/motor.c   **** void motor_init(void) {
  25:Src/motor.c   **** 	pwm_init();
  26:Src/motor.c   **** 	encoder_init();
  27:Src/motor.c   **** }
  28:Src/motor.c   **** 
  29:Src/motor.c   **** // Sets up the PWM and direction signals to drive the H-Bridge
  30:Src/motor.c   **** void pwm_init(void) {
  27              		.loc 1 30 21 view -0
  28              		.cfi_startproc
ARM GAS  /tmp/cclLk6It.s 			page 2


  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
  31:Src/motor.c   **** 	//RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
  32:Src/motor.c   **** 
  33:Src/motor.c   **** 	// Set up pin PA4 for H-bridge PWM output (TIMER 14 CH1)
  34:Src/motor.c   **** 	/*
  35:Src/motor.c   **** 	   GPIOA->MODER |= (1 << 9);
  36:Src/motor.c   **** 	   GPIOA->MODER &= ~(1 << 8);
  37:Src/motor.c   **** 
  38:Src/motor.c   **** 	// Set up pin PB3 for H-bridge PWM output (TIMER 2 CH2)
  39:Src/motor.c   **** 	GPIOB->MODER |= (1 << 7);
  40:Src/motor.c   **** 	GPIOB->MODER &= ~(1 << 6);
  41:Src/motor.c   **** 
  42:Src/motor.c   **** 	// Set PA4 to AF4,
  43:Src/motor.c   **** 	GPIOA->AFR[0] &= 0xFFF0FFFF; // clear PA4 bits,
  44:Src/motor.c   **** 	GPIOA->AFR[0] |= (1 << 18);
  45:Src/motor.c   **** 
  46:Src/motor.c   **** 	// Set PB3 to AF2,
  47:Src/motor.c   **** 	GPIOB->AFR[0] &= 0xFFFF0FFF; // clear PB3 bits,
  48:Src/motor.c   **** 	GPIOB->AFR[0] |= (1 << 13);
  49:Src/motor.c   **** 
  50:Src/motor.c   **** 	// Set up a PA5, PA8 as GPIO output pins for motor direction control
  51:Src/motor.c   **** 	GPIOA->MODER &= 0xFFFCF3FF; // clear PA5, PA6 bits,
  52:Src/motor.c   **** 	GPIOA->MODER |= (1 << 10) | (1 << 16);
  53:Src/motor.c   **** 
  54:Src/motor.c   **** 	// Set up a PB2, PB10 as GPIO output pins for motor direction control
  55:Src/motor.c   **** 	GPIOB->MODER &= 0xFFCFFFCF; // clear PB2, PB10 bits,
  56:Src/motor.c   **** 	GPIOB->MODER |= (1 << 4) | (1 << 20);
  57:Src/motor.c   **** 	*/
  58:Src/motor.c   **** 
  59:Src/motor.c   **** 	//Initialize one direction pin to high, the other low
  60:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_a.gpio, motor_left_pins.dir_a.pin.Pin, GPIO_PIN_SET);
  38              		.loc 1 60 2 view .LVU1
  39              		.loc 1 60 73 is_stmt 0 view .LVU2
  40 0002 244C     		ldr	r4, .L2
  41              		.loc 1 60 2 view .LVU3
  42 0004 A18B     		ldrh	r1, [r4, #28]
  43 0006 A069     		ldr	r0, [r4, #24]
  44 0008 0122     		movs	r2, #1
  45 000a FFF7FEFF 		bl	HAL_GPIO_WritePin
  46              	.LVL0:
  61:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_b.gpio, motor_left_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
  47              		.loc 1 61 2 is_stmt 1 view .LVU4
  48 000e A18E     		ldrh	r1, [r4, #52]
  49 0010 206B     		ldr	r0, [r4, #48]
  50 0012 0022     		movs	r2, #0
  51 0014 FFF7FEFF 		bl	HAL_GPIO_WritePin
  52              	.LVL1:
  62:Src/motor.c   **** 
  63:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_a.gpio, motor_right_pins.dir_a.pin.Pin, GPIO_PIN_SET);
ARM GAS  /tmp/cclLk6It.s 			page 3


  53              		.loc 1 63 2 view .LVU5
  54              		.loc 1 63 75 is_stmt 0 view .LVU6
  55 0018 1F4C     		ldr	r4, .L2+4
  56              		.loc 1 63 2 view .LVU7
  57 001a A18B     		ldrh	r1, [r4, #28]
  58 001c A069     		ldr	r0, [r4, #24]
  59 001e 0122     		movs	r2, #1
  60 0020 FFF7FEFF 		bl	HAL_GPIO_WritePin
  61              	.LVL2:
  64:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_b.gpio, motor_right_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
  62              		.loc 1 64 2 is_stmt 1 view .LVU8
  63 0024 A18E     		ldrh	r1, [r4, #52]
  64 0026 206B     		ldr	r0, [r4, #48]
  65 0028 0022     		movs	r2, #0
  66 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
  67              	.LVL3:
  65:Src/motor.c   **** 
  66:Src/motor.c   **** 	// Set up PWM timer
  67:Src/motor.c   **** 	RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;
  68              		.loc 1 67 2 view .LVU9
  69              		.loc 1 67 5 is_stmt 0 view .LVU10
  70 002e 1B4B     		ldr	r3, .L2+8
  71 0030 D969     		ldr	r1, [r3, #28]
  72              		.loc 1 67 15 view .LVU11
  73 0032 8022     		movs	r2, #128
  74 0034 5200     		lsls	r2, r2, #1
  75 0036 0A43     		orrs	r2, r1
  76 0038 DA61     		str	r2, [r3, #28]
  68:Src/motor.c   **** 	TIM14->CR1 = 0;                         // Clear control registers
  77              		.loc 1 68 2 is_stmt 1 view .LVU12
  78              		.loc 1 68 13 is_stmt 0 view .LVU13
  79 003a 194A     		ldr	r2, .L2+12
  80 003c 0021     		movs	r1, #0
  81 003e 1160     		str	r1, [r2]
  69:Src/motor.c   **** 	TIM14->CCMR1 = 0;                       // (prevents having to manually clear bits)
  82              		.loc 1 69 2 is_stmt 1 view .LVU14
  83              		.loc 1 69 15 is_stmt 0 view .LVU15
  84 0040 9161     		str	r1, [r2, #24]
  70:Src/motor.c   **** 	TIM14->CCER = 0;
  85              		.loc 1 70 2 is_stmt 1 view .LVU16
  86              		.loc 1 70 14 is_stmt 0 view .LVU17
  87 0042 1162     		str	r1, [r2, #32]
  71:Src/motor.c   **** 
  72:Src/motor.c   **** 	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
  88              		.loc 1 72 2 is_stmt 1 view .LVU18
  89              		.loc 1 72 5 is_stmt 0 view .LVU19
  90 0044 DC69     		ldr	r4, [r3, #28]
  91              		.loc 1 72 15 view .LVU20
  92 0046 0120     		movs	r0, #1
  93 0048 0443     		orrs	r4, r0
  94 004a DC61     		str	r4, [r3, #28]
  73:Src/motor.c   **** 	TIM2->CR1 = 0;                         // Clear control registers
  95              		.loc 1 73 2 is_stmt 1 view .LVU21
  96              		.loc 1 73 12 is_stmt 0 view .LVU22
  97 004c 8023     		movs	r3, #128
  98 004e DB05     		lsls	r3, r3, #23
  99 0050 1960     		str	r1, [r3]
ARM GAS  /tmp/cclLk6It.s 			page 4


  74:Src/motor.c   **** 	TIM2->CCMR1 = 0;                       // (prevents having to manually clear bits)
 100              		.loc 1 74 2 is_stmt 1 view .LVU23
 101              		.loc 1 74 14 is_stmt 0 view .LVU24
 102 0052 9961     		str	r1, [r3, #24]
  75:Src/motor.c   **** 	TIM2->CCER = 0;
 103              		.loc 1 75 2 is_stmt 1 view .LVU25
 104              		.loc 1 75 13 is_stmt 0 view .LVU26
 105 0054 1962     		str	r1, [r3, #32]
  76:Src/motor.c   **** 
  77:Src/motor.c   **** 	// Set output-compare CH1 to PWM1 mode and enable CCR1 preload buffer
  78:Src/motor.c   **** 	TIM14->CCMR1 |= (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE);
 106              		.loc 1 78 2 is_stmt 1 view .LVU27
 107              		.loc 1 78 7 is_stmt 0 view .LVU28
 108 0056 9469     		ldr	r4, [r2, #24]
 109              		.loc 1 78 15 view .LVU29
 110 0058 6825     		movs	r5, #104
 111 005a 2C43     		orrs	r4, r5
 112 005c 9461     		str	r4, [r2, #24]
  79:Src/motor.c   **** 	TIM14->CCER |= TIM_CCER_CC1E;           // Enable capture-compare channel 1
 113              		.loc 1 79 2 is_stmt 1 view .LVU30
 114              		.loc 1 79 7 is_stmt 0 view .LVU31
 115 005e 146A     		ldr	r4, [r2, #32]
 116              		.loc 1 79 14 view .LVU32
 117 0060 0443     		orrs	r4, r0
 118 0062 1462     		str	r4, [r2, #32]
  80:Src/motor.c   **** 	TIM14->PSC = 1;                         // Run timer on 24Mhz
 119              		.loc 1 80 2 is_stmt 1 view .LVU33
 120              		.loc 1 80 13 is_stmt 0 view .LVU34
 121 0064 9062     		str	r0, [r2, #40]
  81:Src/motor.c   **** 	TIM14->ARR = 1200;                      // PWM at 20kHz
 122              		.loc 1 81 2 is_stmt 1 view .LVU35
 123              		.loc 1 81 13 is_stmt 0 view .LVU36
 124 0066 9625     		movs	r5, #150
 125 0068 ED00     		lsls	r5, r5, #3
 126 006a D562     		str	r5, [r2, #44]
  82:Src/motor.c   **** 	TIM14->CCR1 = 0;                        // Start PWM at 0% duty cycle
 127              		.loc 1 82 2 is_stmt 1 view .LVU37
 128              		.loc 1 82 14 is_stmt 0 view .LVU38
 129 006c 5163     		str	r1, [r2, #52]
  83:Src/motor.c   **** 
  84:Src/motor.c   **** 	TIM14->CR1 |= TIM_CR1_CEN;              // Enable timer
 130              		.loc 1 84 2 is_stmt 1 view .LVU39
 131              		.loc 1 84 7 is_stmt 0 view .LVU40
 132 006e 1468     		ldr	r4, [r2]
 133              		.loc 1 84 13 view .LVU41
 134 0070 0443     		orrs	r4, r0
 135 0072 1460     		str	r4, [r2]
  85:Src/motor.c   **** 
  86:Src/motor.c   **** 	TIM2->CCMR1 |= (TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2PE);
 136              		.loc 1 86 2 is_stmt 1 view .LVU42
 137              		.loc 1 86 6 is_stmt 0 view .LVU43
 138 0074 9C69     		ldr	r4, [r3, #24]
 139              		.loc 1 86 14 view .LVU44
 140 0076 D022     		movs	r2, #208
 141 0078 D201     		lsls	r2, r2, #7
 142 007a 2243     		orrs	r2, r4
 143 007c 9A61     		str	r2, [r3, #24]
ARM GAS  /tmp/cclLk6It.s 			page 5


  87:Src/motor.c   **** 	TIM2->CCER |= TIM_CCER_CC2E;           // Enable capture-compare channel 2
 144              		.loc 1 87 2 is_stmt 1 view .LVU45
 145              		.loc 1 87 6 is_stmt 0 view .LVU46
 146 007e 1A6A     		ldr	r2, [r3, #32]
 147              		.loc 1 87 13 view .LVU47
 148 0080 1024     		movs	r4, #16
 149 0082 2243     		orrs	r2, r4
 150 0084 1A62     		str	r2, [r3, #32]
  88:Src/motor.c   **** 	TIM2->PSC = 1;                         // Run timer on 24Mhz
 151              		.loc 1 88 2 is_stmt 1 view .LVU48
 152              		.loc 1 88 12 is_stmt 0 view .LVU49
 153 0086 9862     		str	r0, [r3, #40]
  89:Src/motor.c   **** 	TIM2->ARR = 1200;                      // PWM at 20kHz
 154              		.loc 1 89 2 is_stmt 1 view .LVU50
 155              		.loc 1 89 12 is_stmt 0 view .LVU51
 156 0088 DD62     		str	r5, [r3, #44]
  90:Src/motor.c   **** 	TIM2->CCR2 = 0;                        // Start PWM at 0% duty cycle
 157              		.loc 1 90 2 is_stmt 1 view .LVU52
 158              		.loc 1 90 13 is_stmt 0 view .LVU53
 159 008a 9963     		str	r1, [r3, #56]
  91:Src/motor.c   **** 
  92:Src/motor.c   **** 	TIM2->CR1 |= TIM_CR1_CEN;              // Enable timer
 160              		.loc 1 92 2 is_stmt 1 view .LVU54
 161              		.loc 1 92 6 is_stmt 0 view .LVU55
 162 008c 1A68     		ldr	r2, [r3]
 163              		.loc 1 92 12 view .LVU56
 164 008e 0243     		orrs	r2, r0
 165 0090 1A60     		str	r2, [r3]
  93:Src/motor.c   **** }
 166              		.loc 1 93 1 view .LVU57
 167              		@ sp needed
 168 0092 70BD     		pop	{r4, r5, r6, pc}
 169              	.L3:
 170              		.align	2
 171              	.L2:
 172 0094 00000000 		.word	motor_left_pins
 173 0098 00000000 		.word	motor_right_pins
 174 009c 00100240 		.word	1073876992
 175 00a0 00200040 		.word	1073750016
 176              		.cfi_endproc
 177              	.LFE44:
 179              		.global	__aeabi_uidiv
 180              		.section	.text.pwm_setDutyCycleL,"ax",%progbits
 181              		.align	1
 182              		.global	pwm_setDutyCycleL
 183              		.syntax unified
 184              		.code	16
 185              		.thumb_func
 187              	pwm_setDutyCycleL:
 188              	.LVL4:
 189              	.LFB45:
  94:Src/motor.c   **** 
  95:Src/motor.c   **** // Set the duty cycle of the PWM Left, accepts (0-100)
  96:Src/motor.c   **** void pwm_setDutyCycleL(uint8_t duty) {
 190              		.loc 1 96 38 is_stmt 1 view -0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cclLk6It.s 			page 6


 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		.loc 1 96 38 is_stmt 0 view .LVU59
 195 0000 10B5     		push	{r4, lr}
 196              	.LCFI1:
 197              		.cfi_def_cfa_offset 8
 198              		.cfi_offset 4, -8
 199              		.cfi_offset 14, -4
  97:Src/motor.c   **** 	if(duty <= 100) {
 200              		.loc 1 97 2 is_stmt 1 view .LVU60
 201              		.loc 1 97 4 is_stmt 0 view .LVU61
 202 0002 6428     		cmp	r0, #100
 203 0004 06D8     		bhi	.L4
  98:Src/motor.c   **** 		TIM14->CCR1 = ((uint32_t)duty*TIM14->ARR)/100;  // Use linear transform to produce CCR1 value
 204              		.loc 1 98 3 is_stmt 1 view .LVU62
 205              		.loc 1 98 38 is_stmt 0 view .LVU63
 206 0006 044C     		ldr	r4, .L6
 207 0008 E36A     		ldr	r3, [r4, #44]
 208              		.loc 1 98 32 view .LVU64
 209 000a 5843     		muls	r0, r3
 210              	.LVL5:
 211              		.loc 1 98 44 view .LVU65
 212 000c 6421     		movs	r1, #100
 213 000e FFF7FEFF 		bl	__aeabi_uidiv
 214              	.LVL6:
 215              		.loc 1 98 15 view .LVU66
 216 0012 6063     		str	r0, [r4, #52]
 217              	.L4:
  99:Src/motor.c   **** 														// (CCR1 == "pulse" parameter in PWM struct used by peripheral library)
 100:Src/motor.c   **** 	}
 101:Src/motor.c   **** }
 218              		.loc 1 101 1 view .LVU67
 219              		@ sp needed
 220 0014 10BD     		pop	{r4, pc}
 221              	.L7:
 222 0016 C046     		.align	2
 223              	.L6:
 224 0018 00200040 		.word	1073750016
 225              		.cfi_endproc
 226              	.LFE45:
 228              		.section	.text.pwm_setDutyCycleR,"ax",%progbits
 229              		.align	1
 230              		.global	pwm_setDutyCycleR
 231              		.syntax unified
 232              		.code	16
 233              		.thumb_func
 235              	pwm_setDutyCycleR:
 236              	.LVL7:
 237              	.LFB46:
 102:Src/motor.c   **** 
 103:Src/motor.c   **** // Set the duty cycle of the PWM Right, accepts (0-100)
 104:Src/motor.c   **** void pwm_setDutyCycleR(uint8_t duty) {
 238              		.loc 1 104 38 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		.loc 1 104 38 is_stmt 0 view .LVU69
 243 0000 10B5     		push	{r4, lr}
ARM GAS  /tmp/cclLk6It.s 			page 7


 244              	.LCFI2:
 245              		.cfi_def_cfa_offset 8
 246              		.cfi_offset 4, -8
 247              		.cfi_offset 14, -4
 105:Src/motor.c   **** 	if(duty <= 100) {
 248              		.loc 1 105 2 is_stmt 1 view .LVU70
 249              		.loc 1 105 4 is_stmt 0 view .LVU71
 250 0002 6428     		cmp	r0, #100
 251 0004 07D8     		bhi	.L8
 106:Src/motor.c   **** 		TIM2->CCR2 = ((uint32_t)duty*TIM2->ARR)/100;  // Use linear transform to produce CCR1 value
 252              		.loc 1 106 3 is_stmt 1 view .LVU72
 253              		.loc 1 106 36 is_stmt 0 view .LVU73
 254 0006 8024     		movs	r4, #128
 255 0008 E405     		lsls	r4, r4, #23
 256 000a E36A     		ldr	r3, [r4, #44]
 257              		.loc 1 106 31 view .LVU74
 258 000c 5843     		muls	r0, r3
 259              	.LVL8:
 260              		.loc 1 106 42 view .LVU75
 261 000e 6421     		movs	r1, #100
 262 0010 FFF7FEFF 		bl	__aeabi_uidiv
 263              	.LVL9:
 264              		.loc 1 106 14 view .LVU76
 265 0014 A063     		str	r0, [r4, #56]
 266              	.L8:
 107:Src/motor.c   **** 													  // (CCR2 == "pulse" parameter in PWM struct used by peripheral library)
 108:Src/motor.c   **** 	}
 109:Src/motor.c   **** }
 267              		.loc 1 109 1 view .LVU77
 268              		@ sp needed
 269 0016 10BD     		pop	{r4, pc}
 270              		.cfi_endproc
 271              	.LFE46:
 273              		.section	.text.set_Motor_Direction,"ax",%progbits
 274              		.align	1
 275              		.global	set_Motor_Direction
 276              		.syntax unified
 277              		.code	16
 278              		.thumb_func
 280              	set_Motor_Direction:
 281              	.LVL10:
 282              	.LFB47:
 110:Src/motor.c   **** 
 111:Src/motor.c   **** /*
 112:Src/motor.c   ****  * This sets an individual motor's direction.
 113:Src/motor.c   ****  * Note: use MoveMotors to change multiple motor values, eg to turn.
 114:Src/motor.c   ****  */
 115:Src/motor.c   **** void set_Motor_Direction(Direction dir, motor_pins_t* pins){
 283              		.loc 1 115 60 is_stmt 1 view -0
 284              		.cfi_startproc
 285              		@ args = 0, pretend = 0, frame = 0
 286              		@ frame_needed = 0, uses_anonymous_args = 0
 287              		.loc 1 115 60 is_stmt 0 view .LVU79
 288 0000 10B5     		push	{r4, lr}
 289              	.LCFI3:
 290              		.cfi_def_cfa_offset 8
 291              		.cfi_offset 4, -8
ARM GAS  /tmp/cclLk6It.s 			page 8


 292              		.cfi_offset 14, -4
 293 0002 0C00     		movs	r4, r1
 116:Src/motor.c   **** 	switch(dir){
 294              		.loc 1 116 2 is_stmt 1 view .LVU80
 295 0004 0028     		cmp	r0, #0
 296 0006 02D0     		beq	.L11
 297 0008 0328     		cmp	r0, #3
 298 000a 0BD0     		beq	.L12
 299              	.LVL11:
 300              	.L10:
 117:Src/motor.c   **** 		case FORWARD:
 118:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_SET);
 119:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 120:Src/motor.c   **** 			break;
 121:Src/motor.c   **** 		case BACKWARD:
 122:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_RESET);
 123:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 124:Src/motor.c   **** 			break;
 125:Src/motor.c   **** 		default:
 126:Src/motor.c   **** 			;
 127:Src/motor.c   **** 	}
 128:Src/motor.c   **** }
 301              		.loc 1 128 1 is_stmt 0 view .LVU81
 302              		@ sp needed
 303              	.LVL12:
 304              		.loc 1 128 1 view .LVU82
 305 000c 10BD     		pop	{r4, pc}
 306              	.LVL13:
 307              	.L11:
 118:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 308              		.loc 1 118 4 is_stmt 1 view .LVU83
 309 000e 898B     		ldrh	r1, [r1, #28]
 310              	.LVL14:
 118:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 311              		.loc 1 118 4 is_stmt 0 view .LVU84
 312 0010 A069     		ldr	r0, [r4, #24]
 313              	.LVL15:
 118:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 314              		.loc 1 118 4 view .LVU85
 315 0012 0122     		movs	r2, #1
 316 0014 FFF7FEFF 		bl	HAL_GPIO_WritePin
 317              	.LVL16:
 119:Src/motor.c   **** 			break;
 318              		.loc 1 119 4 is_stmt 1 view .LVU86
 319 0018 A18E     		ldrh	r1, [r4, #52]
 320 001a 206B     		ldr	r0, [r4, #48]
 321 001c 0022     		movs	r2, #0
 322 001e FFF7FEFF 		bl	HAL_GPIO_WritePin
 323              	.LVL17:
 120:Src/motor.c   **** 		case BACKWARD:
 324              		.loc 1 120 4 view .LVU87
 325 0022 F3E7     		b	.L10
 326              	.LVL18:
 327              	.L12:
 122:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 328              		.loc 1 122 4 view .LVU88
 329 0024 898B     		ldrh	r1, [r1, #28]
ARM GAS  /tmp/cclLk6It.s 			page 9


 330              	.LVL19:
 122:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 331              		.loc 1 122 4 is_stmt 0 view .LVU89
 332 0026 A069     		ldr	r0, [r4, #24]
 333              	.LVL20:
 122:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 334              		.loc 1 122 4 view .LVU90
 335 0028 0022     		movs	r2, #0
 336 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
 337              	.LVL21:
 123:Src/motor.c   **** 			break;
 338              		.loc 1 123 4 is_stmt 1 view .LVU91
 339 002e A18E     		ldrh	r1, [r4, #52]
 340 0030 206B     		ldr	r0, [r4, #48]
 341 0032 0122     		movs	r2, #1
 342 0034 FFF7FEFF 		bl	HAL_GPIO_WritePin
 343              	.LVL22:
 124:Src/motor.c   **** 		default:
 344              		.loc 1 124 4 view .LVU92
 126:Src/motor.c   **** 	}
 345              		.loc 1 126 4 view .LVU93
 346              		.loc 1 128 1 is_stmt 0 view .LVU94
 347 0038 E8E7     		b	.L10
 348              		.cfi_endproc
 349              	.LFE47:
 351              		.section	.text.set_Forward,"ax",%progbits
 352              		.align	1
 353              		.global	set_Forward
 354              		.syntax unified
 355              		.code	16
 356              		.thumb_func
 358              	set_Forward:
 359              	.LFB48:
 129:Src/motor.c   **** 
 130:Src/motor.c   **** //Experimentation led to this 91 number for driving straight.
 131:Src/motor.c   **** volatile uint8_t pwm_right = 100;
 132:Src/motor.c   **** volatile uint8_t pwm_left = 100;
 133:Src/motor.c   **** 
 134:Src/motor.c   **** void set_Forward(){
 360              		.loc 1 134 19 is_stmt 1 view -0
 361              		.cfi_startproc
 362              		@ args = 0, pretend = 0, frame = 0
 363              		@ frame_needed = 0, uses_anonymous_args = 0
 364 0000 10B5     		push	{r4, lr}
 365              	.LCFI4:
 366              		.cfi_def_cfa_offset 8
 367              		.cfi_offset 4, -8
 368              		.cfi_offset 14, -4
 135:Src/motor.c   **** 	//left go forward
 136:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
 369              		.loc 1 136 2 view .LVU96
 370 0002 0949     		ldr	r1, .L15
 371 0004 0020     		movs	r0, #0
 372 0006 FFF7FEFF 		bl	set_Motor_Direction
 373              	.LVL23:
 137:Src/motor.c   **** 
 138:Src/motor.c   **** 	//right go forward
ARM GAS  /tmp/cclLk6It.s 			page 10


 139:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 374              		.loc 1 139 2 view .LVU97
 375 000a 0849     		ldr	r1, .L15+4
 376 000c 0020     		movs	r0, #0
 377 000e FFF7FEFF 		bl	set_Motor_Direction
 378              	.LVL24:
 140:Src/motor.c   **** 
 141:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
 379              		.loc 1 141 2 view .LVU98
 380 0012 074B     		ldr	r3, .L15+8
 381 0014 1878     		ldrb	r0, [r3]
 382 0016 C0B2     		uxtb	r0, r0
 383 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 384              	.LVL25:
 142:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 385              		.loc 1 142 2 view .LVU99
 386 001c 054B     		ldr	r3, .L15+12
 387 001e 1878     		ldrb	r0, [r3]
 388 0020 C0B2     		uxtb	r0, r0
 389 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 390              	.LVL26:
 143:Src/motor.c   **** 
 144:Src/motor.c   **** 
 145:Src/motor.c   **** 	/* the old way
 146:Src/motor.c   **** 	   GPIOA->ODR |= (1 << 5);
 147:Src/motor.c   **** 	   GPIOA->ODR &= ~(1 << 8);
 148:Src/motor.c   **** 	   GPIOB->ODR |= (1 << 10);
 149:Src/motor.c   **** 	   GPIOB->ODR &= ~(1 << 2);
 150:Src/motor.c   **** 	   */
 151:Src/motor.c   **** }
 391              		.loc 1 151 1 is_stmt 0 view .LVU100
 392              		@ sp needed
 393 0026 10BD     		pop	{r4, pc}
 394              	.L16:
 395              		.align	2
 396              	.L15:
 397 0028 00000000 		.word	motor_left_pins
 398 002c 00000000 		.word	motor_right_pins
 399 0030 00000000 		.word	pwm_right
 400 0034 00000000 		.word	pwm_left
 401              		.cfi_endproc
 402              	.LFE48:
 404              		.section	.text.set_Backward,"ax",%progbits
 405              		.align	1
 406              		.global	set_Backward
 407              		.syntax unified
 408              		.code	16
 409              		.thumb_func
 411              	set_Backward:
 412              	.LFB49:
 152:Src/motor.c   **** 
 153:Src/motor.c   **** void set_Backward(){
 413              		.loc 1 153 20 is_stmt 1 view -0
 414              		.cfi_startproc
 415              		@ args = 0, pretend = 0, frame = 0
 416              		@ frame_needed = 0, uses_anonymous_args = 0
 417 0000 10B5     		push	{r4, lr}
ARM GAS  /tmp/cclLk6It.s 			page 11


 418              	.LCFI5:
 419              		.cfi_def_cfa_offset 8
 420              		.cfi_offset 4, -8
 421              		.cfi_offset 14, -4
 154:Src/motor.c   **** 	//left go backward
 155:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 422              		.loc 1 155 2 view .LVU102
 423 0002 0949     		ldr	r1, .L18
 424 0004 0320     		movs	r0, #3
 425 0006 FFF7FEFF 		bl	set_Motor_Direction
 426              	.LVL27:
 156:Src/motor.c   **** 
 157:Src/motor.c   **** 	//right go backward
 158:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 427              		.loc 1 158 2 view .LVU103
 428 000a 0849     		ldr	r1, .L18+4
 429 000c 0320     		movs	r0, #3
 430 000e FFF7FEFF 		bl	set_Motor_Direction
 431              	.LVL28:
 159:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
 432              		.loc 1 159 2 view .LVU104
 433 0012 074B     		ldr	r3, .L18+8
 434 0014 1878     		ldrb	r0, [r3]
 435 0016 C0B2     		uxtb	r0, r0
 436 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 437              	.LVL29:
 160:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 438              		.loc 1 160 2 view .LVU105
 439 001c 054B     		ldr	r3, .L18+12
 440 001e 1878     		ldrb	r0, [r3]
 441 0020 C0B2     		uxtb	r0, r0
 442 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 443              	.LVL30:
 161:Src/motor.c   **** 	/* the old way
 162:Src/motor.c   **** 	   GPIOA->ODR |= (1 << 8);
 163:Src/motor.c   **** 	   GPIOA->ODR &= ~(1 << 5);
 164:Src/motor.c   **** 	   GPIOB->ODR |= (1 << 2);
 165:Src/motor.c   **** 	   GPIOB->ODR &= ~(1 << 10);
 166:Src/motor.c   **** 	   */
 167:Src/motor.c   **** }
 444              		.loc 1 167 1 is_stmt 0 view .LVU106
 445              		@ sp needed
 446 0026 10BD     		pop	{r4, pc}
 447              	.L19:
 448              		.align	2
 449              	.L18:
 450 0028 00000000 		.word	motor_left_pins
 451 002c 00000000 		.word	motor_right_pins
 452 0030 00000000 		.word	pwm_right
 453 0034 00000000 		.word	pwm_left
 454              		.cfi_endproc
 455              	.LFE49:
 457              		.section	.text.set_Right,"ax",%progbits
 458              		.align	1
 459              		.global	set_Right
 460              		.syntax unified
 461              		.code	16
ARM GAS  /tmp/cclLk6It.s 			page 12


 462              		.thumb_func
 464              	set_Right:
 465              	.LFB50:
 168:Src/motor.c   **** 
 169:Src/motor.c   **** void set_Right(){
 466              		.loc 1 169 17 is_stmt 1 view -0
 467              		.cfi_startproc
 468              		@ args = 0, pretend = 0, frame = 0
 469              		@ frame_needed = 0, uses_anonymous_args = 0
 470 0000 10B5     		push	{r4, lr}
 471              	.LCFI6:
 472              		.cfi_def_cfa_offset 8
 473              		.cfi_offset 4, -8
 474              		.cfi_offset 14, -4
 170:Src/motor.c   **** 	//left go forward
 171:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
 475              		.loc 1 171 2 view .LVU108
 476 0002 0949     		ldr	r1, .L21
 477 0004 0020     		movs	r0, #0
 478 0006 FFF7FEFF 		bl	set_Motor_Direction
 479              	.LVL31:
 172:Src/motor.c   **** 
 173:Src/motor.c   **** 	//right go backward
 174:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 480              		.loc 1 174 2 view .LVU109
 481 000a 0849     		ldr	r1, .L21+4
 482 000c 0320     		movs	r0, #3
 483 000e FFF7FEFF 		bl	set_Motor_Direction
 484              	.LVL32:
 175:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
 485              		.loc 1 175 2 view .LVU110
 486 0012 074B     		ldr	r3, .L21+8
 487 0014 1878     		ldrb	r0, [r3]
 488 0016 C0B2     		uxtb	r0, r0
 489 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 490              	.LVL33:
 176:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 491              		.loc 1 176 2 view .LVU111
 492 001c 054B     		ldr	r3, .L21+12
 493 001e 1878     		ldrb	r0, [r3]
 494 0020 C0B2     		uxtb	r0, r0
 495 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 496              	.LVL34:
 177:Src/motor.c   **** 	/* old way
 178:Src/motor.c   **** 	   GPIOA->ODR |= (1 << 5);
 179:Src/motor.c   **** 	   GPIOA->ODR &= ~(1 << 8);
 180:Src/motor.c   **** 	   GPIOB->ODR |= (1 << 2);
 181:Src/motor.c   **** 	   GPIOB->ODR &= ~(1 << 10);
 182:Src/motor.c   **** 	   */
 183:Src/motor.c   **** }
 497              		.loc 1 183 1 is_stmt 0 view .LVU112
 498              		@ sp needed
 499 0026 10BD     		pop	{r4, pc}
 500              	.L22:
 501              		.align	2
 502              	.L21:
 503 0028 00000000 		.word	motor_left_pins
ARM GAS  /tmp/cclLk6It.s 			page 13


 504 002c 00000000 		.word	motor_right_pins
 505 0030 00000000 		.word	pwm_right
 506 0034 00000000 		.word	pwm_left
 507              		.cfi_endproc
 508              	.LFE50:
 510              		.section	.text.set_Left,"ax",%progbits
 511              		.align	1
 512              		.global	set_Left
 513              		.syntax unified
 514              		.code	16
 515              		.thumb_func
 517              	set_Left:
 518              	.LFB51:
 184:Src/motor.c   **** 
 185:Src/motor.c   **** void set_Left(){
 519              		.loc 1 185 16 is_stmt 1 view -0
 520              		.cfi_startproc
 521              		@ args = 0, pretend = 0, frame = 0
 522              		@ frame_needed = 0, uses_anonymous_args = 0
 523 0000 10B5     		push	{r4, lr}
 524              	.LCFI7:
 525              		.cfi_def_cfa_offset 8
 526              		.cfi_offset 4, -8
 527              		.cfi_offset 14, -4
 186:Src/motor.c   **** 	//left go backward
 187:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 528              		.loc 1 187 2 view .LVU114
 529 0002 0949     		ldr	r1, .L24
 530 0004 0320     		movs	r0, #3
 531 0006 FFF7FEFF 		bl	set_Motor_Direction
 532              	.LVL35:
 188:Src/motor.c   **** 
 189:Src/motor.c   **** 	//right go forward
 190:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 533              		.loc 1 190 2 view .LVU115
 534 000a 0849     		ldr	r1, .L24+4
 535 000c 0020     		movs	r0, #0
 536 000e FFF7FEFF 		bl	set_Motor_Direction
 537              	.LVL36:
 191:Src/motor.c   **** 
 192:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
 538              		.loc 1 192 2 view .LVU116
 539 0012 074B     		ldr	r3, .L24+8
 540 0014 1878     		ldrb	r0, [r3]
 541 0016 C0B2     		uxtb	r0, r0
 542 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 543              	.LVL37:
 193:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 544              		.loc 1 193 2 view .LVU117
 545 001c 054B     		ldr	r3, .L24+12
 546 001e 1878     		ldrb	r0, [r3]
 547 0020 C0B2     		uxtb	r0, r0
 548 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 549              	.LVL38:
 194:Src/motor.c   **** 	/*
 195:Src/motor.c   **** 	   GPIOA->ODR |= (1 << 8);
 196:Src/motor.c   **** 	   GPIOA->ODR &= ~(1 << 5);
ARM GAS  /tmp/cclLk6It.s 			page 14


 197:Src/motor.c   **** 	   GPIOB->ODR |= (1 << 10);
 198:Src/motor.c   **** 	   GPIOB->ODR &= ~(1 << 2);
 199:Src/motor.c   **** 	   */
 200:Src/motor.c   **** }
 550              		.loc 1 200 1 is_stmt 0 view .LVU118
 551              		@ sp needed
 552 0026 10BD     		pop	{r4, pc}
 553              	.L25:
 554              		.align	2
 555              	.L24:
 556 0028 00000000 		.word	motor_left_pins
 557 002c 00000000 		.word	motor_right_pins
 558 0030 00000000 		.word	pwm_right
 559 0034 00000000 		.word	pwm_left
 560              		.cfi_endproc
 561              	.LFE51:
 563              		.section	.text.motors_Off,"ax",%progbits
 564              		.align	1
 565              		.global	motors_Off
 566              		.syntax unified
 567              		.code	16
 568              		.thumb_func
 570              	motors_Off:
 571              	.LFB52:
 201:Src/motor.c   **** 
 202:Src/motor.c   **** void motors_Off(){
 572              		.loc 1 202 18 is_stmt 1 view -0
 573              		.cfi_startproc
 574              		@ args = 0, pretend = 0, frame = 0
 575              		@ frame_needed = 0, uses_anonymous_args = 0
 576 0000 10B5     		push	{r4, lr}
 577              	.LCFI8:
 578              		.cfi_def_cfa_offset 8
 579              		.cfi_offset 4, -8
 580              		.cfi_offset 14, -4
 203:Src/motor.c   **** 	pwm_setDutyCycleR(0);
 581              		.loc 1 203 2 view .LVU120
 582 0002 0020     		movs	r0, #0
 583 0004 FFF7FEFF 		bl	pwm_setDutyCycleR
 584              	.LVL39:
 204:Src/motor.c   **** 	pwm_setDutyCycleL(0);
 585              		.loc 1 204 2 view .LVU121
 586 0008 0020     		movs	r0, #0
 587 000a FFF7FEFF 		bl	pwm_setDutyCycleL
 588              	.LVL40:
 205:Src/motor.c   **** }
 589              		.loc 1 205 1 is_stmt 0 view .LVU122
 590              		@ sp needed
 591 000e 10BD     		pop	{r4, pc}
 592              		.cfi_endproc
 593              	.LFE52:
 595              		.section	.rodata.MoveMotors.str1.4,"aMS",%progbits,1
 596              		.align	2
 597              	.LC18:
 598 0000 4D6F7665 		.ascii	"MoveMotors executed!\012\000"
 598      4D6F746F 
 598      72732065 
ARM GAS  /tmp/cclLk6It.s 			page 15


 598      78656375 
 598      74656421 
 599 0016 0000     		.align	2
 600              	.LC20:
 601 0018 496E7661 		.ascii	"Invalid command to MoveMotors!\012\000"
 601      6C696420 
 601      636F6D6D 
 601      616E6420 
 601      746F204D 
 602              		.global	__aeabi_i2d
 603              		.global	__aeabi_ddiv
 604              		.global	__aeabi_d2uiz
 605              		.global	__aeabi_dmul
 606              		.global	__aeabi_f2d
 607              		.global	__aeabi_dadd
 608              		.global	__aeabi_d2f
 609              		.global	__aeabi_dsub
 610              		.section	.text.MoveMotors,"ax",%progbits
 611              		.align	1
 612              		.global	MoveMotors
 613              		.syntax unified
 614              		.code	16
 615              		.thumb_func
 617              	MoveMotors:
 618              	.LVL41:
 619              	.LFB53:
 206:Src/motor.c   **** 
 207:Src/motor.c   **** uint8_t* MoveMotors(MotorCommand* cmd){
 620              		.loc 1 207 39 is_stmt 1 view -0
 621              		.cfi_startproc
 622              		@ args = 0, pretend = 0, frame = 0
 623              		@ frame_needed = 0, uses_anonymous_args = 0
 624              		.loc 1 207 39 is_stmt 0 view .LVU124
 625 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 626              	.LCFI9:
 627              		.cfi_def_cfa_offset 24
 628              		.cfi_offset 3, -24
 629              		.cfi_offset 4, -20
 630              		.cfi_offset 5, -16
 631              		.cfi_offset 6, -12
 632              		.cfi_offset 7, -8
 633              		.cfi_offset 14, -4
 634 0002 0400     		movs	r4, r0
 208:Src/motor.c   **** 	motors_Off();
 635              		.loc 1 208 2 is_stmt 1 view .LVU125
 636 0004 FFF7FEFF 		bl	motors_Off
 637              	.LVL42:
 209:Src/motor.c   **** 	pwm_right = 100;
 638              		.loc 1 209 2 view .LVU126
 639              		.loc 1 209 12 is_stmt 0 view .LVU127
 640 0008 3C4B     		ldr	r3, .L38
 641 000a 6422     		movs	r2, #100
 642 000c 1A70     		strb	r2, [r3]
 210:Src/motor.c   **** 	uint8_t* err = "MoveMotors executed!\n";
 643              		.loc 1 210 2 is_stmt 1 view .LVU128
 644              	.LVL43:
 211:Src/motor.c   **** 	switch(cmd->dir){
ARM GAS  /tmp/cclLk6It.s 			page 16


 645              		.loc 1 211 2 view .LVU129
 646              		.loc 1 211 12 is_stmt 0 view .LVU130
 647 000e 2378     		ldrb	r3, [r4]
 648              		.loc 1 211 2 view .LVU131
 649 0010 022B     		cmp	r3, #2
 650 0012 4AD0     		beq	.L28
 651 0014 2ED8     		bhi	.L29
 652 0016 002B     		cmp	r3, #0
 653 0018 37D0     		beq	.L30
 654 001a 012B     		cmp	r3, #1
 655 001c 28D1     		bne	.L36
 212:Src/motor.c   **** 		case FORWARD:
 213:Src/motor.c   **** 			turning = false;
 214:Src/motor.c   **** 			if(!cmd->amount)
 215:Src/motor.c   **** 				target_dist = -1;
 216:Src/motor.c   **** 			else
 217:Src/motor.c   **** 				target_dist = cmd->amount;
 218:Src/motor.c   **** 			set_Forward();
 219:Src/motor.c   **** 			break;
 220:Src/motor.c   **** 		case LEFT:
 221:Src/motor.c   **** 			turning = true;
 656              		.loc 1 221 4 is_stmt 1 view .LVU132
 657              		.loc 1 221 12 is_stmt 0 view .LVU133
 658 001e 384B     		ldr	r3, .L38+4
 659 0020 0122     		movs	r2, #1
 660 0022 1A70     		strb	r2, [r3]
 222:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 661              		.loc 1 222 4 is_stmt 1 view .LVU134
 662              		.loc 1 222 32 is_stmt 0 view .LVU135
 663 0024 6078     		ldrb	r0, [r4, #1]
 664              		.loc 1 222 41 view .LVU136
 665 0026 FFF7FEFF 		bl	__aeabi_i2d
 666              	.LVL44:
 667 002a 0400     		movs	r4, r0
 668              	.LVL45:
 669              		.loc 1 222 41 view .LVU137
 670 002c 0D00     		movs	r5, r1
 671 002e 0022     		movs	r2, #0
 672 0030 344B     		ldr	r3, .L38+8
 673 0032 FFF7FEFF 		bl	__aeabi_ddiv
 674              	.LVL46:
 675              		.loc 1 222 18 view .LVU138
 676 0036 FFF7FEFF 		bl	__aeabi_d2uiz
 677              	.LVL47:
 678 003a C0B2     		uxtb	r0, r0
 679              		.loc 1 222 16 view .LVU139
 680 003c 324B     		ldr	r3, .L38+12
 681 003e 1870     		strb	r0, [r3]
 223:Src/motor.c   **** 			heading += cmd->amount * 0.0174533; //convert to radians
 682              		.loc 1 223 4 is_stmt 1 view .LVU140
 683              		.loc 1 223 12 is_stmt 0 view .LVU141
 684 0040 324E     		ldr	r6, .L38+16
 685 0042 3768     		ldr	r7, [r6]
 686              		.loc 1 223 27 view .LVU142
 687 0044 324A     		ldr	r2, .L38+20
 688 0046 334B     		ldr	r3, .L38+24
 689 0048 2000     		movs	r0, r4
ARM GAS  /tmp/cclLk6It.s 			page 17


 690 004a 2900     		movs	r1, r5
 691 004c FFF7FEFF 		bl	__aeabi_dmul
 692              	.LVL48:
 693 0050 0400     		movs	r4, r0
 694 0052 0D00     		movs	r5, r1
 695              		.loc 1 223 12 view .LVU143
 696 0054 381C     		adds	r0, r7, #0
 697 0056 FFF7FEFF 		bl	__aeabi_f2d
 698              	.LVL49:
 699 005a 2200     		movs	r2, r4
 700 005c 2B00     		movs	r3, r5
 701 005e FFF7FEFF 		bl	__aeabi_dadd
 702              	.LVL50:
 703 0062 FFF7FEFF 		bl	__aeabi_d2f
 704              	.LVL51:
 705 0066 3060     		str	r0, [r6]
 224:Src/motor.c   **** 			set_Left();
 706              		.loc 1 224 4 is_stmt 1 view .LVU144
 707 0068 FFF7FEFF 		bl	set_Left
 708              	.LVL52:
 225:Src/motor.c   **** 			break;
 709              		.loc 1 225 4 view .LVU145
 210:Src/motor.c   **** 	switch(cmd->dir){
 710              		.loc 1 210 11 is_stmt 0 view .LVU146
 711 006c 2A48     		ldr	r0, .L38+28
 712              		.loc 1 225 4 view .LVU147
 713 006e 0BE0     		b	.L27
 714              	.LVL53:
 715              	.L36:
 211:Src/motor.c   **** 		case FORWARD:
 716              		.loc 1 211 2 view .LVU148
 717 0070 2A48     		ldr	r0, .L38+32
 718 0072 09E0     		b	.L27
 719              	.L29:
 720 0074 042B     		cmp	r3, #4
 721 0076 06D1     		bne	.L37
 226:Src/motor.c   **** 		case RIGHT:
 227:Src/motor.c   **** 			turning = true;
 228:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 229:Src/motor.c   **** 			heading -= cmd->amount * 0.0174533; //convert to radians
 230:Src/motor.c   **** 			set_Right();
 231:Src/motor.c   **** 			break;
 232:Src/motor.c   **** 		case OFF:
 233:Src/motor.c   **** 			target_dist = 1;
 722              		.loc 1 233 4 is_stmt 1 view .LVU149
 723              		.loc 1 233 16 is_stmt 0 view .LVU150
 724 0078 234B     		ldr	r3, .L38+12
 725 007a 0122     		movs	r2, #1
 726 007c 1A70     		strb	r2, [r3]
 234:Src/motor.c   **** 			motors_Off();
 727              		.loc 1 234 4 is_stmt 1 view .LVU151
 728 007e FFF7FEFF 		bl	motors_Off
 729              	.LVL54:
 235:Src/motor.c   **** 			break;
 730              		.loc 1 235 4 view .LVU152
 210:Src/motor.c   **** 	switch(cmd->dir){
 731              		.loc 1 210 11 is_stmt 0 view .LVU153
ARM GAS  /tmp/cclLk6It.s 			page 18


 732 0082 2548     		ldr	r0, .L38+28
 733              	.LVL55:
 236:Src/motor.c   **** 		default:
 237:Src/motor.c   **** 			err = "Invalid command to MoveMotors!\n";
 238:Src/motor.c   **** 	}
 239:Src/motor.c   **** 	//THIS IS BAD. if you send an x it won't stop motors until this delay finishes!
 240:Src/motor.c   **** 	//Switch to a polling structure instead for final
 241:Src/motor.c   **** 	/* while(get_distance() < target_dist) */
 242:Src/motor.c   **** 	/* 	; */
 243:Src/motor.c   **** 	/* motors_Off(); */
 244:Src/motor.c   **** 	return err;
 734              		.loc 1 244 2 is_stmt 1 view .LVU154
 735              		.loc 1 244 9 is_stmt 0 view .LVU155
 736 0084 00E0     		b	.L27
 737              	.LVL56:
 738              	.L37:
 211:Src/motor.c   **** 		case FORWARD:
 739              		.loc 1 211 2 view .LVU156
 740 0086 2548     		ldr	r0, .L38+32
 741              	.LVL57:
 742              	.L27:
 245:Src/motor.c   **** }
 743              		.loc 1 245 1 view .LVU157
 744              		@ sp needed
 745 0088 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 746              	.LVL58:
 747              	.L30:
 213:Src/motor.c   **** 			if(!cmd->amount)
 748              		.loc 1 213 4 is_stmt 1 view .LVU158
 213:Src/motor.c   **** 			if(!cmd->amount)
 749              		.loc 1 213 12 is_stmt 0 view .LVU159
 750 008a 1D4B     		ldr	r3, .L38+4
 751 008c 0022     		movs	r2, #0
 752 008e 1A70     		strb	r2, [r3]
 214:Src/motor.c   **** 				target_dist = -1;
 753              		.loc 1 214 4 is_stmt 1 view .LVU160
 214:Src/motor.c   **** 				target_dist = -1;
 754              		.loc 1 214 11 is_stmt 0 view .LVU161
 755 0090 6378     		ldrb	r3, [r4, #1]
 214:Src/motor.c   **** 				target_dist = -1;
 756              		.loc 1 214 6 view .LVU162
 757 0092 002B     		cmp	r3, #0
 758 0094 06D1     		bne	.L34
 215:Src/motor.c   **** 			else
 759              		.loc 1 215 5 is_stmt 1 view .LVU163
 215:Src/motor.c   **** 			else
 760              		.loc 1 215 17 is_stmt 0 view .LVU164
 761 0096 1C4B     		ldr	r3, .L38+12
 762 0098 FF32     		adds	r2, r2, #255
 763 009a 1A70     		strb	r2, [r3]
 764              	.L35:
 218:Src/motor.c   **** 			break;
 765              		.loc 1 218 4 is_stmt 1 view .LVU165
 766 009c FFF7FEFF 		bl	set_Forward
 767              	.LVL59:
 219:Src/motor.c   **** 		case LEFT:
 768              		.loc 1 219 4 view .LVU166
ARM GAS  /tmp/cclLk6It.s 			page 19


 210:Src/motor.c   **** 	switch(cmd->dir){
 769              		.loc 1 210 11 is_stmt 0 view .LVU167
 770 00a0 1D48     		ldr	r0, .L38+28
 219:Src/motor.c   **** 		case LEFT:
 771              		.loc 1 219 4 view .LVU168
 772 00a2 F1E7     		b	.L27
 773              	.L34:
 217:Src/motor.c   **** 			set_Forward();
 774              		.loc 1 217 5 is_stmt 1 view .LVU169
 217:Src/motor.c   **** 			set_Forward();
 775              		.loc 1 217 17 is_stmt 0 view .LVU170
 776 00a4 184A     		ldr	r2, .L38+12
 777 00a6 1370     		strb	r3, [r2]
 778 00a8 F8E7     		b	.L35
 779              	.L28:
 227:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 780              		.loc 1 227 4 is_stmt 1 view .LVU171
 227:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 781              		.loc 1 227 12 is_stmt 0 view .LVU172
 782 00aa 154B     		ldr	r3, .L38+4
 783 00ac 0122     		movs	r2, #1
 784 00ae 1A70     		strb	r2, [r3]
 228:Src/motor.c   **** 			heading -= cmd->amount * 0.0174533; //convert to radians
 785              		.loc 1 228 4 is_stmt 1 view .LVU173
 228:Src/motor.c   **** 			heading -= cmd->amount * 0.0174533; //convert to radians
 786              		.loc 1 228 32 is_stmt 0 view .LVU174
 787 00b0 6078     		ldrb	r0, [r4, #1]
 228:Src/motor.c   **** 			heading -= cmd->amount * 0.0174533; //convert to radians
 788              		.loc 1 228 41 view .LVU175
 789 00b2 FFF7FEFF 		bl	__aeabi_i2d
 790              	.LVL60:
 791 00b6 0400     		movs	r4, r0
 792              	.LVL61:
 228:Src/motor.c   **** 			heading -= cmd->amount * 0.0174533; //convert to radians
 793              		.loc 1 228 41 view .LVU176
 794 00b8 0D00     		movs	r5, r1
 795 00ba 0022     		movs	r2, #0
 796 00bc 114B     		ldr	r3, .L38+8
 797 00be FFF7FEFF 		bl	__aeabi_ddiv
 798              	.LVL62:
 228:Src/motor.c   **** 			heading -= cmd->amount * 0.0174533; //convert to radians
 799              		.loc 1 228 18 view .LVU177
 800 00c2 FFF7FEFF 		bl	__aeabi_d2uiz
 801              	.LVL63:
 802 00c6 C0B2     		uxtb	r0, r0
 228:Src/motor.c   **** 			heading -= cmd->amount * 0.0174533; //convert to radians
 803              		.loc 1 228 16 view .LVU178
 804 00c8 0F4B     		ldr	r3, .L38+12
 805 00ca 1870     		strb	r0, [r3]
 229:Src/motor.c   **** 			set_Right();
 806              		.loc 1 229 4 is_stmt 1 view .LVU179
 229:Src/motor.c   **** 			set_Right();
 807              		.loc 1 229 12 is_stmt 0 view .LVU180
 808 00cc 0F4E     		ldr	r6, .L38+16
 809 00ce 3768     		ldr	r7, [r6]
 229:Src/motor.c   **** 			set_Right();
 810              		.loc 1 229 27 view .LVU181
ARM GAS  /tmp/cclLk6It.s 			page 20


 811 00d0 0F4A     		ldr	r2, .L38+20
 812 00d2 104B     		ldr	r3, .L38+24
 813 00d4 2000     		movs	r0, r4
 814 00d6 2900     		movs	r1, r5
 815 00d8 FFF7FEFF 		bl	__aeabi_dmul
 816              	.LVL64:
 817 00dc 0400     		movs	r4, r0
 818 00de 0D00     		movs	r5, r1
 229:Src/motor.c   **** 			set_Right();
 819              		.loc 1 229 12 view .LVU182
 820 00e0 381C     		adds	r0, r7, #0
 821 00e2 FFF7FEFF 		bl	__aeabi_f2d
 822              	.LVL65:
 823 00e6 2200     		movs	r2, r4
 824 00e8 2B00     		movs	r3, r5
 825 00ea FFF7FEFF 		bl	__aeabi_dsub
 826              	.LVL66:
 827 00ee FFF7FEFF 		bl	__aeabi_d2f
 828              	.LVL67:
 829 00f2 3060     		str	r0, [r6]
 230:Src/motor.c   **** 			break;
 830              		.loc 1 230 4 is_stmt 1 view .LVU183
 831 00f4 FFF7FEFF 		bl	set_Right
 832              	.LVL68:
 231:Src/motor.c   **** 		case OFF:
 833              		.loc 1 231 4 view .LVU184
 210:Src/motor.c   **** 	switch(cmd->dir){
 834              		.loc 1 210 11 is_stmt 0 view .LVU185
 835 00f8 0748     		ldr	r0, .L38+28
 231:Src/motor.c   **** 		case OFF:
 836              		.loc 1 231 4 view .LVU186
 837 00fa C5E7     		b	.L27
 838              	.L39:
 839              		.align	2
 840              	.L38:
 841 00fc 00000000 		.word	pwm_right
 842 0100 00000000 		.word	turning
 843 0104 00002740 		.word	1076297728
 844 0108 00000000 		.word	target_dist
 845 010c 00000000 		.word	heading
 846 0110 5F40D422 		.word	584335455
 847 0114 47DF913F 		.word	1066524487
 848 0118 00000000 		.word	.LC18
 849 011c 18000000 		.word	.LC20
 850              		.cfi_endproc
 851              	.LFE53:
 853              		.section	.text.encoder_init,"ax",%progbits
 854              		.align	1
 855              		.global	encoder_init
 856              		.syntax unified
 857              		.code	16
 858              		.thumb_func
 860              	encoder_init:
 861              	.LFB54:
 246:Src/motor.c   **** 
 247:Src/motor.c   **** // Sets up encoder interface to read motor speed
 248:Src/motor.c   **** void encoder_init(void) {
ARM GAS  /tmp/cclLk6It.s 			page 21


 862              		.loc 1 248 25 is_stmt 1 view -0
 863              		.cfi_startproc
 864              		@ args = 0, pretend = 0, frame = 0
 865              		@ frame_needed = 0, uses_anonymous_args = 0
 866 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 867              	.LCFI10:
 868              		.cfi_def_cfa_offset 20
 869              		.cfi_offset 4, -20
 870              		.cfi_offset 5, -16
 871              		.cfi_offset 6, -12
 872              		.cfi_offset 7, -8
 873              		.cfi_offset 14, -4
 249:Src/motor.c   **** 
 250:Src/motor.c   **** 	// Set up encoder input pins (TIMER 3 CH1 and CH2)
 251:Src/motor.c   **** 	/*
 252:Src/motor.c   **** 	   GPIOB->MODER &= ~(GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0);
 253:Src/motor.c   **** 	   GPIOB->MODER |= (GPIO_MODER_MODER4_1 | GPIO_MODER_MODER5_1);
 254:Src/motor.c   **** 	   GPIOB->AFR[0] |= ( (1 << 16) | (1 << 20) );
 255:Src/motor.c   **** 
 256:Src/motor.c   **** 	// Set up encoder input pins (TIMER 15 CH1 and CH2)
 257:Src/motor.c   **** 	GPIOB->MODER &= ~(GPIO_MODER_MODER14_0 | GPIO_MODER_MODER15_0);
 258:Src/motor.c   **** 	GPIOB->MODER |= (GPIO_MODER_MODER14_1 | GPIO_MODER_MODER15_1);
 259:Src/motor.c   **** 	GPIOB->AFR[1] |= ( (1 << 24) | (1 << 28) );
 260:Src/motor.c   **** 	*/
 261:Src/motor.c   **** 
 262:Src/motor.c   **** 	// Set up encoder interface (TIM3 encoder input mode)
 263:Src/motor.c   **** 	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
 874              		.loc 1 263 2 view .LVU188
 875              		.loc 1 263 5 is_stmt 0 view .LVU189
 876 0002 2849     		ldr	r1, .L41
 877 0004 CB69     		ldr	r3, [r1, #28]
 878              		.loc 1 263 15 view .LVU190
 879 0006 0222     		movs	r2, #2
 880 0008 1343     		orrs	r3, r2
 881 000a CB61     		str	r3, [r1, #28]
 264:Src/motor.c   **** 	RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;
 882              		.loc 1 264 2 is_stmt 1 view .LVU191
 883              		.loc 1 264 5 is_stmt 0 view .LVU192
 884 000c 8A69     		ldr	r2, [r1, #24]
 885              		.loc 1 264 15 view .LVU193
 886 000e 8023     		movs	r3, #128
 887 0010 1B01     		lsls	r3, r3, #4
 888 0012 1343     		orrs	r3, r2
 889 0014 8B61     		str	r3, [r1, #24]
 265:Src/motor.c   **** 	TIM3->CCMR1 = 0;
 890              		.loc 1 265 2 is_stmt 1 view .LVU194
 891              		.loc 1 265 14 is_stmt 0 view .LVU195
 892 0016 244B     		ldr	r3, .L41+4
 893 0018 0022     		movs	r2, #0
 894 001a 9A61     		str	r2, [r3, #24]
 266:Src/motor.c   **** 	TIM3->CCER = 0;
 895              		.loc 1 266 2 is_stmt 1 view .LVU196
 896              		.loc 1 266 13 is_stmt 0 view .LVU197
 897 001c 1A62     		str	r2, [r3, #32]
 267:Src/motor.c   **** 	TIM3->SMCR = 0;
 898              		.loc 1 267 2 is_stmt 1 view .LVU198
 899              		.loc 1 267 13 is_stmt 0 view .LVU199
ARM GAS  /tmp/cclLk6It.s 			page 22


 900 001e 9A60     		str	r2, [r3, #8]
 268:Src/motor.c   **** 	TIM3->CR1 = 0;
 901              		.loc 1 268 2 is_stmt 1 view .LVU200
 902              		.loc 1 268 12 is_stmt 0 view .LVU201
 903 0020 1A60     		str	r2, [r3]
 269:Src/motor.c   **** 
 270:Src/motor.c   **** 	TIM3->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected to 
 904              		.loc 1 270 2 is_stmt 1 view .LVU202
 905              		.loc 1 270 6 is_stmt 0 view .LVU203
 906 0022 9869     		ldr	r0, [r3, #24]
 907              		.loc 1 270 14 view .LVU204
 908 0024 0224     		movs	r4, #2
 909 0026 FF34     		adds	r4, r4, #255
 910 0028 2043     		orrs	r0, r4
 911 002a 9861     		str	r0, [r3, #24]
 271:Src/motor.c   **** 	TIM3->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and fall
 912              		.loc 1 271 2 is_stmt 1 view .LVU205
 913              		.loc 1 271 6 is_stmt 0 view .LVU206
 914 002c 9868     		ldr	r0, [r3, #8]
 915              		.loc 1 271 13 view .LVU207
 916 002e 0325     		movs	r5, #3
 917 0030 AC46     		mov	ip, r5
 918 0032 2843     		orrs	r0, r5
 919 0034 9860     		str	r0, [r3, #8]
 272:Src/motor.c   **** 	TIM3->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest possib
 920              		.loc 1 272 2 is_stmt 1 view .LVU208
 921              		.loc 1 272 12 is_stmt 0 view .LVU209
 922 0036 1D4F     		ldr	r7, .L41+8
 923 0038 DF62     		str	r7, [r3, #44]
 273:Src/motor.c   **** 	TIM3->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negative 
 924              		.loc 1 273 2 is_stmt 1 view .LVU210
 925              		.loc 1 273 12 is_stmt 0 view .LVU211
 926 003a 1D4E     		ldr	r6, .L41+12
 927 003c 5E62     		str	r6, [r3, #36]
 274:Src/motor.c   **** 															// (Could also cast unsigned register to signed number to get negative numbers if it
 275:Src/motor.c   **** 															//  just another option, the mid-bias is a bit simpler to understand though.)
 276:Src/motor.c   **** 	TIM3->CR1 |= TIM_CR1_CEN;                               // Enable timer
 928              		.loc 1 276 2 is_stmt 1 view .LVU212
 929              		.loc 1 276 6 is_stmt 0 view .LVU213
 930 003e 1D68     		ldr	r5, [r3]
 931              		.loc 1 276 12 view .LVU214
 932 0040 0120     		movs	r0, #1
 933 0042 0543     		orrs	r5, r0
 934 0044 1D60     		str	r5, [r3]
 277:Src/motor.c   **** 
 278:Src/motor.c   **** 	TIM1->CCMR1 = 0;
 935              		.loc 1 278 2 is_stmt 1 view .LVU215
 936              		.loc 1 278 14 is_stmt 0 view .LVU216
 937 0046 1B4B     		ldr	r3, .L41+16
 938 0048 9A61     		str	r2, [r3, #24]
 279:Src/motor.c   **** 	TIM1->CCER = 0;
 939              		.loc 1 279 2 is_stmt 1 view .LVU217
 940              		.loc 1 279 13 is_stmt 0 view .LVU218
 941 004a 1A62     		str	r2, [r3, #32]
 280:Src/motor.c   **** 	TIM1->SMCR = 0;
 942              		.loc 1 280 2 is_stmt 1 view .LVU219
 943              		.loc 1 280 13 is_stmt 0 view .LVU220
ARM GAS  /tmp/cclLk6It.s 			page 23


 944 004c 9A60     		str	r2, [r3, #8]
 281:Src/motor.c   **** 	TIM1->CR1 = 0;
 945              		.loc 1 281 2 is_stmt 1 view .LVU221
 946              		.loc 1 281 12 is_stmt 0 view .LVU222
 947 004e 1A60     		str	r2, [r3]
 282:Src/motor.c   **** 	TIM1->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected to 
 948              		.loc 1 282 2 is_stmt 1 view .LVU223
 949              		.loc 1 282 6 is_stmt 0 view .LVU224
 950 0050 9A69     		ldr	r2, [r3, #24]
 951              		.loc 1 282 14 view .LVU225
 952 0052 1443     		orrs	r4, r2
 953 0054 9C61     		str	r4, [r3, #24]
 283:Src/motor.c   **** 	TIM1->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and fall
 954              		.loc 1 283 2 is_stmt 1 view .LVU226
 955              		.loc 1 283 6 is_stmt 0 view .LVU227
 956 0056 9A68     		ldr	r2, [r3, #8]
 957              		.loc 1 283 13 view .LVU228
 958 0058 6446     		mov	r4, ip
 959 005a 2243     		orrs	r2, r4
 960 005c 9A60     		str	r2, [r3, #8]
 284:Src/motor.c   **** 	TIM1->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest possib
 961              		.loc 1 284 2 is_stmt 1 view .LVU229
 962              		.loc 1 284 12 is_stmt 0 view .LVU230
 963 005e DF62     		str	r7, [r3, #44]
 285:Src/motor.c   **** 	TIM1->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negative 
 964              		.loc 1 285 2 is_stmt 1 view .LVU231
 965              		.loc 1 285 12 is_stmt 0 view .LVU232
 966 0060 5E62     		str	r6, [r3, #36]
 286:Src/motor.c   **** 															// (Could also cast unsigned register to signed number to get negative numbers if it
 287:Src/motor.c   **** 															//  just another option, the mid-bias is a bit simpler to understand though.)
 288:Src/motor.c   **** 	TIM1->CR1 |= TIM_CR1_CEN;     
 967              		.loc 1 288 2 is_stmt 1 view .LVU233
 968              		.loc 1 288 6 is_stmt 0 view .LVU234
 969 0062 1A68     		ldr	r2, [r3]
 970              		.loc 1 288 12 view .LVU235
 971 0064 0243     		orrs	r2, r0
 972 0066 1A60     		str	r2, [r3]
 289:Src/motor.c   **** 
 290:Src/motor.c   **** 	// Configure a second timer (TIM6) to fire an ISR on update event
 291:Src/motor.c   **** 	// Used to periodically check and update speed variable
 292:Src/motor.c   **** 	RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
 973              		.loc 1 292 2 is_stmt 1 view .LVU236
 974              		.loc 1 292 5 is_stmt 0 view .LVU237
 975 0068 CB69     		ldr	r3, [r1, #28]
 976              		.loc 1 292 15 view .LVU238
 977 006a 1022     		movs	r2, #16
 978 006c 1343     		orrs	r3, r2
 979 006e CB61     		str	r3, [r1, #28]
 293:Src/motor.c   **** 
 294:Src/motor.c   **** 	// Select PSC and ARR values that give an appropriate interrupt rate
 295:Src/motor.c   **** 	TIM6->PSC = 11;
 980              		.loc 1 295 2 is_stmt 1 view .LVU239
 981              		.loc 1 295 12 is_stmt 0 view .LVU240
 982 0070 114B     		ldr	r3, .L41+20
 983 0072 053A     		subs	r2, r2, #5
 984 0074 9A62     		str	r2, [r3, #40]
 296:Src/motor.c   **** 	TIM6->ARR = 30000;
ARM GAS  /tmp/cclLk6It.s 			page 24


 985              		.loc 1 296 2 is_stmt 1 view .LVU241
 986              		.loc 1 296 12 is_stmt 0 view .LVU242
 987 0076 114A     		ldr	r2, .L41+24
 988 0078 DA62     		str	r2, [r3, #44]
 297:Src/motor.c   **** 
 298:Src/motor.c   **** 	TIM6->DIER |= TIM_DIER_UIE;             // Enable update event interrupt
 989              		.loc 1 298 2 is_stmt 1 view .LVU243
 990              		.loc 1 298 6 is_stmt 0 view .LVU244
 991 007a DA68     		ldr	r2, [r3, #12]
 992              		.loc 1 298 13 view .LVU245
 993 007c 0243     		orrs	r2, r0
 994 007e DA60     		str	r2, [r3, #12]
 299:Src/motor.c   **** 	TIM6->CR1 |= TIM_CR1_CEN;               // Enable Timer
 995              		.loc 1 299 2 is_stmt 1 view .LVU246
 996              		.loc 1 299 6 is_stmt 0 view .LVU247
 997 0080 1A68     		ldr	r2, [r3]
 998              		.loc 1 299 12 view .LVU248
 999 0082 0243     		orrs	r2, r0
 1000 0084 1A60     		str	r2, [r3]
 300:Src/motor.c   **** 
 301:Src/motor.c   **** 	NVIC_EnableIRQ(TIM6_DAC_IRQn);          // Enable interrupt in NVIC
 1001              		.loc 1 301 2 is_stmt 1 view .LVU249
 1002              	.LVL69:
 1003              	.LBB6:
 1004              	.LBI6:
 1005              		.file 2 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V5.0.5
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     28. May 2018
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /*
   8:Drivers/CMSIS/Include/core_cm0.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/core_cm0.h ****  *
  10:Drivers/CMSIS/Include/core_cm0.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/core_cm0.h ****  *
  12:Drivers/CMSIS/Include/core_cm0.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/core_cm0.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/core_cm0.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/core_cm0.h ****  *
  16:Drivers/CMSIS/Include/core_cm0.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/core_cm0.h ****  *
  18:Drivers/CMSIS/Include/core_cm0.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/core_cm0.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/core_cm0.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/core_cm0.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/core_cm0.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/core_cm0.h ****  */
  24:Drivers/CMSIS/Include/core_cm0.h **** 
  25:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  26:Drivers/CMSIS/Include/core_cm0.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__clang__)
  28:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  29:Drivers/CMSIS/Include/core_cm0.h **** #endif
  30:Drivers/CMSIS/Include/core_cm0.h **** 
  31:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
ARM GAS  /tmp/cclLk6It.s 			page 25


  32:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  35:Drivers/CMSIS/Include/core_cm0.h **** 
  36:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  37:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  38:Drivers/CMSIS/Include/core_cm0.h **** #endif
  39:Drivers/CMSIS/Include/core_cm0.h **** 
  40:Drivers/CMSIS/Include/core_cm0.h **** /**
  41:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  46:Drivers/CMSIS/Include/core_cm0.h **** 
  47:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  52:Drivers/CMSIS/Include/core_cm0.h ****  */
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h **** 
  55:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  56:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  57:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  58:Drivers/CMSIS/Include/core_cm0.h **** /**
  59:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  60:Drivers/CMSIS/Include/core_cm0.h ****   @{
  61:Drivers/CMSIS/Include/core_cm0.h ****  */
  62:Drivers/CMSIS/Include/core_cm0.h **** 
  63:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_version.h"
  64:Drivers/CMSIS/Include/core_cm0.h ****  
  65:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  66:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  69:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:Drivers/CMSIS/Include/core_cm0.h **** 
  71:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
  75:Drivers/CMSIS/Include/core_cm0.h **** */
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
  77:Drivers/CMSIS/Include/core_cm0.h **** 
  78:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
  79:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
  80:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  82:Drivers/CMSIS/Include/core_cm0.h **** 
  83:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
  85:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  87:Drivers/CMSIS/Include/core_cm0.h **** 
  88:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
ARM GAS  /tmp/cclLk6It.s 			page 26


  89:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  92:Drivers/CMSIS/Include/core_cm0.h **** 
  93:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  94:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
  95:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  97:Drivers/CMSIS/Include/core_cm0.h **** 
  98:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TI_ARM__ )
  99:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 100:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 102:Drivers/CMSIS/Include/core_cm0.h **** 
 103:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 104:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 105:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 107:Drivers/CMSIS/Include/core_cm0.h **** 
 108:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 109:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 110:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 112:Drivers/CMSIS/Include/core_cm0.h **** 
 113:Drivers/CMSIS/Include/core_cm0.h **** #endif
 114:Drivers/CMSIS/Include/core_cm0.h **** 
 115:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** 
 118:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 119:Drivers/CMSIS/Include/core_cm0.h **** }
 120:Drivers/CMSIS/Include/core_cm0.h **** #endif
 121:Drivers/CMSIS/Include/core_cm0.h **** 
 122:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 123:Drivers/CMSIS/Include/core_cm0.h **** 
 124:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 127:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 128:Drivers/CMSIS/Include/core_cm0.h **** 
 129:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 130:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 131:Drivers/CMSIS/Include/core_cm0.h **** #endif
 132:Drivers/CMSIS/Include/core_cm0.h **** 
 133:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 134:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 135:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 136:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 137:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 138:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 139:Drivers/CMSIS/Include/core_cm0.h **** 
 140:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 141:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 142:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 143:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 144:Drivers/CMSIS/Include/core_cm0.h **** 
 145:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
ARM GAS  /tmp/cclLk6It.s 			page 27


 146:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 147:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 148:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 149:Drivers/CMSIS/Include/core_cm0.h **** #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 152:Drivers/CMSIS/Include/core_cm0.h **** /**
 153:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 154:Drivers/CMSIS/Include/core_cm0.h **** 
 155:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 156:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 157:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 158:Drivers/CMSIS/Include/core_cm0.h **** */
 159:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 160:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 161:Drivers/CMSIS/Include/core_cm0.h **** #else
 162:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 163:Drivers/CMSIS/Include/core_cm0.h **** #endif
 164:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 165:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 166:Drivers/CMSIS/Include/core_cm0.h **** 
 167:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 168:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 169:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 170:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** 
 175:Drivers/CMSIS/Include/core_cm0.h **** 
 176:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 177:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 178:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 179:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 180:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 181:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 182:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 183:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 184:Drivers/CMSIS/Include/core_cm0.h **** /**
 185:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 186:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 187:Drivers/CMSIS/Include/core_cm0.h **** */
 188:Drivers/CMSIS/Include/core_cm0.h **** 
 189:Drivers/CMSIS/Include/core_cm0.h **** /**
 190:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 191:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 192:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 193:Drivers/CMSIS/Include/core_cm0.h ****   @{
 194:Drivers/CMSIS/Include/core_cm0.h ****  */
 195:Drivers/CMSIS/Include/core_cm0.h **** 
 196:Drivers/CMSIS/Include/core_cm0.h **** /**
 197:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 198:Drivers/CMSIS/Include/core_cm0.h ****  */
 199:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 200:Drivers/CMSIS/Include/core_cm0.h **** {
 201:Drivers/CMSIS/Include/core_cm0.h ****   struct
 202:Drivers/CMSIS/Include/core_cm0.h ****   {
ARM GAS  /tmp/cclLk6It.s 			page 28


 203:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 204:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 205:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 206:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 207:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 208:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 209:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 210:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 211:Drivers/CMSIS/Include/core_cm0.h **** 
 212:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 214:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 215:Drivers/CMSIS/Include/core_cm0.h **** 
 216:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 217:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 218:Drivers/CMSIS/Include/core_cm0.h **** 
 219:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 220:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 223:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 224:Drivers/CMSIS/Include/core_cm0.h **** 
 225:Drivers/CMSIS/Include/core_cm0.h **** 
 226:Drivers/CMSIS/Include/core_cm0.h **** /**
 227:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 228:Drivers/CMSIS/Include/core_cm0.h ****  */
 229:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 230:Drivers/CMSIS/Include/core_cm0.h **** {
 231:Drivers/CMSIS/Include/core_cm0.h ****   struct
 232:Drivers/CMSIS/Include/core_cm0.h ****   {
 233:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 234:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 235:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 236:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 237:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 238:Drivers/CMSIS/Include/core_cm0.h **** 
 239:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 240:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 241:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 242:Drivers/CMSIS/Include/core_cm0.h **** 
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 257:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 258:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 259:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
ARM GAS  /tmp/cclLk6It.s 			page 29


 260:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 261:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 262:Drivers/CMSIS/Include/core_cm0.h **** 
 263:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 264:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 268:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 274:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 275:Drivers/CMSIS/Include/core_cm0.h **** 
 276:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 277:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 278:Drivers/CMSIS/Include/core_cm0.h **** 
 279:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 280:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 281:Drivers/CMSIS/Include/core_cm0.h **** 
 282:Drivers/CMSIS/Include/core_cm0.h **** 
 283:Drivers/CMSIS/Include/core_cm0.h **** /**
 284:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 285:Drivers/CMSIS/Include/core_cm0.h ****  */
 286:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 287:Drivers/CMSIS/Include/core_cm0.h **** {
 288:Drivers/CMSIS/Include/core_cm0.h ****   struct
 289:Drivers/CMSIS/Include/core_cm0.h ****   {
 290:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 291:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 292:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 293:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 294:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 295:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 296:Drivers/CMSIS/Include/core_cm0.h **** 
 297:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 298:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 299:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 300:Drivers/CMSIS/Include/core_cm0.h **** 
 301:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 302:Drivers/CMSIS/Include/core_cm0.h **** 
 303:Drivers/CMSIS/Include/core_cm0.h **** 
 304:Drivers/CMSIS/Include/core_cm0.h **** /**
 305:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 306:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 307:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 308:Drivers/CMSIS/Include/core_cm0.h ****   @{
 309:Drivers/CMSIS/Include/core_cm0.h ****  */
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /**
 312:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 313:Drivers/CMSIS/Include/core_cm0.h ****  */
 314:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 315:Drivers/CMSIS/Include/core_cm0.h **** {
 316:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
ARM GAS  /tmp/cclLk6It.s 			page 30


 317:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 318:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 319:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 320:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 321:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 322:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 323:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 324:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 325:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 326:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 327:Drivers/CMSIS/Include/core_cm0.h **** 
 328:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 333:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 334:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 335:Drivers/CMSIS/Include/core_cm0.h ****   @{
 336:Drivers/CMSIS/Include/core_cm0.h ****  */
 337:Drivers/CMSIS/Include/core_cm0.h **** 
 338:Drivers/CMSIS/Include/core_cm0.h **** /**
 339:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 340:Drivers/CMSIS/Include/core_cm0.h ****  */
 341:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 342:Drivers/CMSIS/Include/core_cm0.h **** {
 343:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 344:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 345:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 346:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 347:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 348:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 349:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 350:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 351:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 352:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 353:Drivers/CMSIS/Include/core_cm0.h **** 
 354:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 355:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 356:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 357:Drivers/CMSIS/Include/core_cm0.h **** 
 358:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 359:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 360:Drivers/CMSIS/Include/core_cm0.h **** 
 361:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 362:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 363:Drivers/CMSIS/Include/core_cm0.h **** 
 364:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 365:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 366:Drivers/CMSIS/Include/core_cm0.h **** 
 367:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 368:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 369:Drivers/CMSIS/Include/core_cm0.h **** 
 370:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 371:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 372:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 373:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cclLk6It.s 			page 31


 374:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 375:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 376:Drivers/CMSIS/Include/core_cm0.h **** 
 377:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 378:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 379:Drivers/CMSIS/Include/core_cm0.h **** 
 380:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 381:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 382:Drivers/CMSIS/Include/core_cm0.h **** 
 383:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 384:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 387:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 388:Drivers/CMSIS/Include/core_cm0.h **** 
 389:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 390:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 391:Drivers/CMSIS/Include/core_cm0.h **** 
 392:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 393:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 394:Drivers/CMSIS/Include/core_cm0.h **** 
 395:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 396:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 397:Drivers/CMSIS/Include/core_cm0.h **** 
 398:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 399:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 400:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** 
 405:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** 
 408:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** 
 411:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** 
 414:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** 
 421:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** 
 424:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cclLk6It.s 			page 32


 431:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 434:Drivers/CMSIS/Include/core_cm0.h **** 
 435:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** 
 438:Drivers/CMSIS/Include/core_cm0.h **** /**
 439:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 440:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 441:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 442:Drivers/CMSIS/Include/core_cm0.h ****   @{
 443:Drivers/CMSIS/Include/core_cm0.h ****  */
 444:Drivers/CMSIS/Include/core_cm0.h **** 
 445:Drivers/CMSIS/Include/core_cm0.h **** /**
 446:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 447:Drivers/CMSIS/Include/core_cm0.h ****  */
 448:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 449:Drivers/CMSIS/Include/core_cm0.h **** {
 450:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 451:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 452:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 453:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 454:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 458:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 459:Drivers/CMSIS/Include/core_cm0.h **** 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 461:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 462:Drivers/CMSIS/Include/core_cm0.h **** 
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 471:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 472:Drivers/CMSIS/Include/core_cm0.h **** 
 473:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 475:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 476:Drivers/CMSIS/Include/core_cm0.h **** 
 477:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 478:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 479:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 480:Drivers/CMSIS/Include/core_cm0.h **** 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 482:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 483:Drivers/CMSIS/Include/core_cm0.h **** 
 484:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 485:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 486:Drivers/CMSIS/Include/core_cm0.h **** 
 487:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
ARM GAS  /tmp/cclLk6It.s 			page 33


 488:Drivers/CMSIS/Include/core_cm0.h **** 
 489:Drivers/CMSIS/Include/core_cm0.h **** 
 490:Drivers/CMSIS/Include/core_cm0.h **** /**
 491:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 492:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 493:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 494:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 495:Drivers/CMSIS/Include/core_cm0.h ****   @{
 496:Drivers/CMSIS/Include/core_cm0.h ****  */
 497:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 498:Drivers/CMSIS/Include/core_cm0.h **** 
 499:Drivers/CMSIS/Include/core_cm0.h **** 
 500:Drivers/CMSIS/Include/core_cm0.h **** /**
 501:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 502:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 503:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 504:Drivers/CMSIS/Include/core_cm0.h ****   @{
 505:Drivers/CMSIS/Include/core_cm0.h ****  */
 506:Drivers/CMSIS/Include/core_cm0.h **** 
 507:Drivers/CMSIS/Include/core_cm0.h **** /**
 508:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 509:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 510:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 511:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 512:Drivers/CMSIS/Include/core_cm0.h **** */
 513:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 514:Drivers/CMSIS/Include/core_cm0.h **** 
 515:Drivers/CMSIS/Include/core_cm0.h **** /**
 516:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 517:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 518:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 519:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 520:Drivers/CMSIS/Include/core_cm0.h **** */
 521:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 522:Drivers/CMSIS/Include/core_cm0.h **** 
 523:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** 
 526:Drivers/CMSIS/Include/core_cm0.h **** /**
 527:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 528:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 529:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 530:Drivers/CMSIS/Include/core_cm0.h ****   @{
 531:Drivers/CMSIS/Include/core_cm0.h ****  */
 532:Drivers/CMSIS/Include/core_cm0.h **** 
 533:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Core Hardware */
 534:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 535:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 536:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 537:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 538:Drivers/CMSIS/Include/core_cm0.h **** 
 539:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 540:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 541:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 542:Drivers/CMSIS/Include/core_cm0.h **** 
 543:Drivers/CMSIS/Include/core_cm0.h **** 
 544:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
ARM GAS  /tmp/cclLk6It.s 			page 34


 545:Drivers/CMSIS/Include/core_cm0.h **** 
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 549:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 550:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 551:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 552:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 553:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 554:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 557:Drivers/CMSIS/Include/core_cm0.h **** */
 558:Drivers/CMSIS/Include/core_cm0.h **** 
 559:Drivers/CMSIS/Include/core_cm0.h **** 
 560:Drivers/CMSIS/Include/core_cm0.h **** 
 561:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 562:Drivers/CMSIS/Include/core_cm0.h **** /**
 563:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 564:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 565:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 566:Drivers/CMSIS/Include/core_cm0.h ****   @{
 567:Drivers/CMSIS/Include/core_cm0.h ****  */
 568:Drivers/CMSIS/Include/core_cm0.h **** 
 569:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_NVIC_VIRTUAL
 570:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 571:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 572:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 573:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 574:Drivers/CMSIS/Include/core_cm0.h **** #else
 575:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
 576:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
 577:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 578:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 579:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 580:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 581:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 582:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 583:Drivers/CMSIS/Include/core_cm0.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
 584:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 585:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 586:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 587:Drivers/CMSIS/Include/core_cm0.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 588:Drivers/CMSIS/Include/core_cm0.h **** 
 589:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 590:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 591:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 592:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 593:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 594:Drivers/CMSIS/Include/core_cm0.h **** #else
 595:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetVector              __NVIC_SetVector
 596:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetVector              __NVIC_GetVector
 597:Drivers/CMSIS/Include/core_cm0.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 598:Drivers/CMSIS/Include/core_cm0.h **** 
 599:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_USER_IRQ_OFFSET          16
 600:Drivers/CMSIS/Include/core_cm0.h **** 
 601:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cclLk6It.s 			page 35


 602:Drivers/CMSIS/Include/core_cm0.h **** /* The following EXC_RETURN values are saved the LR on exception entry */
 603:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after ret
 604:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after retu
 605:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after retu
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under Armv6-M                  */
 609:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 610:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 611:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 612:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 613:Drivers/CMSIS/Include/core_cm0.h **** 
 614:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_SetPriorityGrouping(X) (void)(X)
 615:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_GetPriorityGrouping()  (0U)
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /**
 618:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable Interrupt
 619:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 620:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 621:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 622:Drivers/CMSIS/Include/core_cm0.h ****  */
 623:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 1006              		.loc 2 623 22 view .LVU250
 1007              	.LBB7:
 624:Drivers/CMSIS/Include/core_cm0.h **** {
 625:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 1008              		.loc 2 625 3 view .LVU251
 626:Drivers/CMSIS/Include/core_cm0.h ****   {
 627:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1009              		.loc 2 627 5 view .LVU252
 1010              		.loc 2 627 20 is_stmt 0 view .LVU253
 1011 0086 0E4B     		ldr	r3, .L41+28
 1012 0088 8022     		movs	r2, #128
 1013 008a 9202     		lsls	r2, r2, #10
 1014 008c 1A60     		str	r2, [r3]
 1015              	.LVL70:
 1016              		.loc 2 627 20 view .LVU254
 1017              	.LBE7:
 1018              	.LBE6:
 302:Src/motor.c   **** 	NVIC_SetPriority(TIM6_DAC_IRQn,3);
 1019              		.loc 1 302 2 is_stmt 1 view .LVU255
 1020              	.LBB8:
 1021              	.LBI8:
 628:Drivers/CMSIS/Include/core_cm0.h ****   }
 629:Drivers/CMSIS/Include/core_cm0.h **** }
 630:Drivers/CMSIS/Include/core_cm0.h **** 
 631:Drivers/CMSIS/Include/core_cm0.h **** 
 632:Drivers/CMSIS/Include/core_cm0.h **** /**
 633:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Enable status
 634:Drivers/CMSIS/Include/core_cm0.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 635:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 636:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt is not enabled.
 637:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt is enabled.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
ARM GAS  /tmp/cclLk6It.s 			page 36


 642:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 643:Drivers/CMSIS/Include/core_cm0.h ****   {
 644:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 645:Drivers/CMSIS/Include/core_cm0.h ****   }
 646:Drivers/CMSIS/Include/core_cm0.h ****   else
 647:Drivers/CMSIS/Include/core_cm0.h ****   {
 648:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 649:Drivers/CMSIS/Include/core_cm0.h ****   }
 650:Drivers/CMSIS/Include/core_cm0.h **** }
 651:Drivers/CMSIS/Include/core_cm0.h **** 
 652:Drivers/CMSIS/Include/core_cm0.h **** 
 653:Drivers/CMSIS/Include/core_cm0.h **** /**
 654:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable Interrupt
 655:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 656:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 657:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 658:Drivers/CMSIS/Include/core_cm0.h ****  */
 659:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 660:Drivers/CMSIS/Include/core_cm0.h **** {
 661:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 662:Drivers/CMSIS/Include/core_cm0.h ****   {
 663:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 664:Drivers/CMSIS/Include/core_cm0.h ****     __DSB();
 665:Drivers/CMSIS/Include/core_cm0.h ****     __ISB();
 666:Drivers/CMSIS/Include/core_cm0.h ****   }
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 674:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 675:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 676:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 677:Drivers/CMSIS/Include/core_cm0.h ****  */
 678:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 679:Drivers/CMSIS/Include/core_cm0.h **** {
 680:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 681:Drivers/CMSIS/Include/core_cm0.h ****   {
 682:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 683:Drivers/CMSIS/Include/core_cm0.h ****   }
 684:Drivers/CMSIS/Include/core_cm0.h ****   else
 685:Drivers/CMSIS/Include/core_cm0.h ****   {
 686:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 687:Drivers/CMSIS/Include/core_cm0.h ****   }
 688:Drivers/CMSIS/Include/core_cm0.h **** }
 689:Drivers/CMSIS/Include/core_cm0.h **** 
 690:Drivers/CMSIS/Include/core_cm0.h **** 
 691:Drivers/CMSIS/Include/core_cm0.h **** /**
 692:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 693:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 694:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 695:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 696:Drivers/CMSIS/Include/core_cm0.h ****  */
 697:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 698:Drivers/CMSIS/Include/core_cm0.h **** {
ARM GAS  /tmp/cclLk6It.s 			page 37


 699:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 700:Drivers/CMSIS/Include/core_cm0.h ****   {
 701:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 702:Drivers/CMSIS/Include/core_cm0.h ****   }
 703:Drivers/CMSIS/Include/core_cm0.h **** }
 704:Drivers/CMSIS/Include/core_cm0.h **** 
 705:Drivers/CMSIS/Include/core_cm0.h **** 
 706:Drivers/CMSIS/Include/core_cm0.h **** /**
 707:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 708:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 710:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 715:Drivers/CMSIS/Include/core_cm0.h ****   {
 716:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 717:Drivers/CMSIS/Include/core_cm0.h ****   }
 718:Drivers/CMSIS/Include/core_cm0.h **** }
 719:Drivers/CMSIS/Include/core_cm0.h **** 
 720:Drivers/CMSIS/Include/core_cm0.h **** 
 721:Drivers/CMSIS/Include/core_cm0.h **** /**
 722:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 723:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 724:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 725:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 726:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 727:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 728:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every processor exception.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 1022              		.loc 2 730 22 view .LVU256
 1023              	.LBB9:
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 1024              		.loc 2 732 3 view .LVU257
 733:Drivers/CMSIS/Include/core_cm0.h ****   {
 734:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 1025              		.loc 2 734 5 view .LVU258
 1026              		.loc 2 734 52 is_stmt 0 view .LVU259
 1027 008e C420     		movs	r0, #196
 1028 0090 8000     		lsls	r0, r0, #2
 1029 0092 1958     		ldr	r1, [r3, r0]
 1030              		.loc 2 734 33 view .LVU260
 1031 0094 0B4A     		ldr	r2, .L41+32
 1032 0096 1140     		ands	r1, r2
 1033              		.loc 2 734 102 view .LVU261
 1034 0098 C022     		movs	r2, #192
 1035 009a 1202     		lsls	r2, r2, #8
 1036 009c 0A43     		orrs	r2, r1
 1037              		.loc 2 734 30 view .LVU262
 1038 009e 1A50     		str	r2, [r3, r0]
 1039              	.LVL71:
 1040              		.loc 2 734 30 view .LVU263
 1041              	.LBE9:
 1042              	.LBE8:
ARM GAS  /tmp/cclLk6It.s 			page 38


 303:Src/motor.c   **** }
 1043              		.loc 1 303 1 view .LVU264
 1044              		@ sp needed
 1045 00a0 F0BD     		pop	{r4, r5, r6, r7, pc}
 1046              	.L42:
 1047 00a2 C046     		.align	2
 1048              	.L41:
 1049 00a4 00100240 		.word	1073876992
 1050 00a8 00040040 		.word	1073742848
 1051 00ac FFFF0000 		.word	65535
 1052 00b0 FF7F0000 		.word	32767
 1053 00b4 002C0140 		.word	1073818624
 1054 00b8 00100040 		.word	1073745920
 1055 00bc 30750000 		.word	30000
 1056 00c0 00E100E0 		.word	-536813312
 1057 00c4 FF00FFFF 		.word	-65281
 1058              		.cfi_endproc
 1059              	.LFE54:
 1061              		.section	.text.motor_init,"ax",%progbits
 1062              		.align	1
 1063              		.global	motor_init
 1064              		.syntax unified
 1065              		.code	16
 1066              		.thumb_func
 1068              	motor_init:
 1069              	.LFB43:
  24:Src/motor.c   **** 	pwm_init();
 1070              		.loc 1 24 23 is_stmt 1 view -0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074 0000 10B5     		push	{r4, lr}
 1075              	.LCFI11:
 1076              		.cfi_def_cfa_offset 8
 1077              		.cfi_offset 4, -8
 1078              		.cfi_offset 14, -4
  25:Src/motor.c   **** 	encoder_init();
 1079              		.loc 1 25 2 view .LVU266
 1080 0002 FFF7FEFF 		bl	pwm_init
 1081              	.LVL72:
  26:Src/motor.c   **** }
 1082              		.loc 1 26 2 view .LVU267
 1083 0006 FFF7FEFF 		bl	encoder_init
 1084              	.LVL73:
  27:Src/motor.c   **** 
 1085              		.loc 1 27 1 is_stmt 0 view .LVU268
 1086              		@ sp needed
 1087 000a 10BD     		pop	{r4, pc}
 1088              		.cfi_endproc
 1089              	.LFE43:
 1091              		.section	.text.ObjectDetected,"ax",%progbits
 1092              		.align	1
 1093              		.global	ObjectDetected
 1094              		.syntax unified
 1095              		.code	16
 1096              		.thumb_func
 1098              	ObjectDetected:
ARM GAS  /tmp/cclLk6It.s 			page 39


 1099              	.LFB55:
 304:Src/motor.c   **** 
 305:Src/motor.c   **** // Encoder interrupt to calculate motor speed, also manages PI controller
 306:Src/motor.c   **** #define ULTRASONIC_SAMPLES 2
 307:Src/motor.c   **** 
 308:Src/motor.c   **** uint8_t ObjectDetected(){
 1100              		.loc 1 308 25 is_stmt 1 view -0
 1101              		.cfi_startproc
 1102              		@ args = 0, pretend = 0, frame = 0
 1103              		@ frame_needed = 0, uses_anonymous_args = 0
 1104 0000 70B5     		push	{r4, r5, r6, lr}
 1105              	.LCFI12:
 1106              		.cfi_def_cfa_offset 16
 1107              		.cfi_offset 4, -16
 1108              		.cfi_offset 5, -12
 1109              		.cfi_offset 6, -8
 1110              		.cfi_offset 14, -4
 309:Src/motor.c   **** 	uint32_t us_left_sum = 0;
 1111              		.loc 1 309 2 view .LVU270
 1112              	.LVL74:
 310:Src/motor.c   **** 	uint32_t us_right_sum = 0;
 1113              		.loc 1 310 2 view .LVU271
 311:Src/motor.c   **** 
 312:Src/motor.c   **** 	for(uint8_t i=0;i<ULTRASONIC_SAMPLES;i++){
 1114              		.loc 1 312 2 view .LVU272
 1115              	.LBB10:
 1116              		.loc 1 312 6 view .LVU273
 1117              		.loc 1 312 14 is_stmt 0 view .LVU274
 1118 0002 0024     		movs	r4, #0
 1119              	.LBE10:
 310:Src/motor.c   **** 	uint32_t us_right_sum = 0;
 1120              		.loc 1 310 11 view .LVU275
 1121 0004 0025     		movs	r5, #0
 309:Src/motor.c   **** 	uint32_t us_right_sum = 0;
 1122              		.loc 1 309 11 view .LVU276
 1123 0006 0026     		movs	r6, #0
 1124              	.LBB11:
 1125              		.loc 1 312 2 view .LVU277
 1126 0008 09E0     		b	.L45
 1127              	.LVL75:
 1128              	.L46:
 313:Src/motor.c   **** 		us_left_sum += GetUltrasonic(&ultrasonic_left_pins);
 1129              		.loc 1 313 3 is_stmt 1 discriminator 3 view .LVU278
 1130              		.loc 1 313 18 is_stmt 0 discriminator 3 view .LVU279
 1131 000a 0C48     		ldr	r0, .L50
 1132 000c FFF7FEFF 		bl	GetUltrasonic
 1133              	.LVL76:
 1134              		.loc 1 313 15 discriminator 3 view .LVU280
 1135 0010 3618     		adds	r6, r6, r0
 1136              	.LVL77:
 314:Src/motor.c   **** 		us_right_sum += GetUltrasonic(&ultrasonic_right_pins);
 1137              		.loc 1 314 3 is_stmt 1 discriminator 3 view .LVU281
 1138              		.loc 1 314 19 is_stmt 0 discriminator 3 view .LVU282
 1139 0012 0B48     		ldr	r0, .L50+4
 1140 0014 FFF7FEFF 		bl	GetUltrasonic
 1141              	.LVL78:
 1142              		.loc 1 314 16 discriminator 3 view .LVU283
ARM GAS  /tmp/cclLk6It.s 			page 40


 1143 0018 2D18     		adds	r5, r5, r0
 1144              	.LVL79:
 312:Src/motor.c   **** 		us_left_sum += GetUltrasonic(&ultrasonic_left_pins);
 1145              		.loc 1 312 40 is_stmt 1 discriminator 3 view .LVU284
 1146 001a 0134     		adds	r4, r4, #1
 1147              	.LVL80:
 312:Src/motor.c   **** 		us_left_sum += GetUltrasonic(&ultrasonic_left_pins);
 1148              		.loc 1 312 40 is_stmt 0 discriminator 3 view .LVU285
 1149 001c E4B2     		uxtb	r4, r4
 1150              	.LVL81:
 1151              	.L45:
 312:Src/motor.c   **** 		us_left_sum += GetUltrasonic(&ultrasonic_left_pins);
 1152              		.loc 1 312 19 is_stmt 1 discriminator 1 view .LVU286
 1153 001e 012C     		cmp	r4, #1
 1154 0020 F3D9     		bls	.L46
 1155              	.LBE11:
 315:Src/motor.c   **** 	}
 316:Src/motor.c   **** 
 317:Src/motor.c   **** 	us_left_sum >>= 1; //div by 2
 1156              		.loc 1 317 2 view .LVU287
 1157              	.LVL82:
 318:Src/motor.c   **** 	us_right_sum >>= 1;
 1158              		.loc 1 318 2 view .LVU288
 1159              		.loc 1 318 15 is_stmt 0 view .LVU289
 1160 0022 6D08     		lsrs	r5, r5, #1
 1161              	.LVL83:
 319:Src/motor.c   **** 
 320:Src/motor.c   **** 	return (us_left_sum < STOP_ULTRASONIC) || (us_right_sum < STOP_ULTRASONIC);
 1162              		.loc 1 320 2 is_stmt 1 view .LVU290
 1163              		.loc 1 320 41 is_stmt 0 view .LVU291
 1164 0024 272E     		cmp	r6, #39
 1165 0026 03D9     		bls	.L48
 1166              		.loc 1 320 41 discriminator 2 view .LVU292
 1167 0028 132D     		cmp	r5, #19
 1168 002a 04D8     		bhi	.L49
 1169              		.loc 1 320 41 view .LVU293
 1170 002c 0120     		movs	r0, #1
 1171 002e 00E0     		b	.L47
 1172              	.L48:
 1173 0030 0120     		movs	r0, #1
 1174              	.L47:
 1175              		.loc 1 320 41 discriminator 6 view .LVU294
 1176 0032 C0B2     		uxtb	r0, r0
 321:Src/motor.c   **** }
 1177              		.loc 1 321 1 discriminator 6 view .LVU295
 1178              		@ sp needed
 1179              	.LVL84:
 1180              	.LVL85:
 1181              	.LVL86:
 1182              		.loc 1 321 1 discriminator 6 view .LVU296
 1183 0034 70BD     		pop	{r4, r5, r6, pc}
 1184              	.LVL87:
 1185              	.L49:
 320:Src/motor.c   **** }
 1186              		.loc 1 320 41 view .LVU297
 1187 0036 0020     		movs	r0, #0
 1188 0038 FBE7     		b	.L47
ARM GAS  /tmp/cclLk6It.s 			page 41


 1189              	.L51:
 1190 003a C046     		.align	2
 1191              	.L50:
 1192 003c 00000000 		.word	ultrasonic_left_pins
 1193 0040 00000000 		.word	ultrasonic_right_pins
 1194              		.cfi_endproc
 1195              	.LFE55:
 1197              		.global	__aeabi_i2f
 1198              		.global	__aeabi_fdiv
 1199              		.global	__aeabi_fmul
 1200              		.global	__aeabi_f2iz
 1201              		.section	.rodata.TIM6_DAC_IRQHandler.str1.4,"aMS",%progbits,1
 1202              		.align	2
 1203              	.LC31:
 1204 0000 70776D5F 		.ascii	"pwm_right: %d\012\000"
 1204      72696768 
 1204      743A2025 
 1204      640A00
 1205 000f 00       		.align	2
 1206              	.LC33:
 1207 0010 6D6F746F 		.ascii	"motorr: %d\012\000"
 1207      72723A20 
 1207      25640A00 
 1208              		.global	__aeabi_fadd
 1209              		.align	2
 1210              	.LC37:
 1211 001c 63757272 		.ascii	"current_dist: %d\012\000"
 1211      656E745F 
 1211      64697374 
 1211      3A202564 
 1211      0A00
 1212              		.global	__aeabi_f2uiz
 1213 002e 0000     		.align	2
 1214              	.LC39:
 1215 0030 48697420 		.ascii	"Hit distance target\012\000"
 1215      64697374 
 1215      616E6365 
 1215      20746172 
 1215      6765740A 
 1216 0045 000000   		.align	2
 1217              	.LC42:
 1218 0048 4F626A65 		.ascii	"Object detected\012\000"
 1218      63742064 
 1218      65746563 
 1218      7465640A 
 1218      00
 1219 0059 000000   		.align	2
 1220              	.LC46:
 1221 005c 68656164 		.ascii	"heading: %d\012\000"
 1221      696E673A 
 1221      2025640A 
 1221      00
 1222              		.section	.text.TIM6_DAC_IRQHandler,"ax",%progbits
 1223              		.align	1
 1224              		.global	TIM6_DAC_IRQHandler
 1225              		.syntax unified
 1226              		.code	16
ARM GAS  /tmp/cclLk6It.s 			page 42


 1227              		.thumb_func
 1229              	TIM6_DAC_IRQHandler:
 1230              	.LFB56:
 322:Src/motor.c   **** 
 323:Src/motor.c   **** void TIM6_DAC_IRQHandler(void) {
 1231              		.loc 1 323 32 is_stmt 1 view -0
 1232              		.cfi_startproc
 1233              		@ args = 0, pretend = 0, frame = 32
 1234              		@ frame_needed = 0, uses_anonymous_args = 0
 1235 0000 30B5     		push	{r4, r5, lr}
 1236              	.LCFI13:
 1237              		.cfi_def_cfa_offset 12
 1238              		.cfi_offset 4, -12
 1239              		.cfi_offset 5, -8
 1240              		.cfi_offset 14, -4
 1241 0002 89B0     		sub	sp, sp, #36
 1242              	.LCFI14:
 1243              		.cfi_def_cfa_offset 48
 324:Src/motor.c   **** 	/* Calculate the motor speed in raw encoder counts
 325:Src/motor.c   **** 	 * Note the motor speed is signed! Motor can be run in reverse.
 326:Src/motor.c   **** 	 * Speed is measured by how far the counter moved from center point
 327:Src/motor.c   **** 	 */
 328:Src/motor.c   **** 	uint8_t usart_buffer[32];
 1244              		.loc 1 328 2 view .LVU299
 329:Src/motor.c   **** 
 330:Src/motor.c   **** 
 331:Src/motor.c   **** 	motorl_speed = (TIM3->CNT - 0x7FFF);
 1245              		.loc 1 331 2 view .LVU300
 1246              		.loc 1 331 22 is_stmt 0 view .LVU301
 1247 0004 7049     		ldr	r1, .L63
 1248 0006 4B6A     		ldr	r3, [r1, #36]
 1249              		.loc 1 331 28 view .LVU302
 1250 0008 704A     		ldr	r2, .L63+4
 1251 000a 9446     		mov	ip, r2
 1252 000c 6344     		add	r3, r3, ip
 1253 000e 1BB2     		sxth	r3, r3
 1254              		.loc 1 331 15 view .LVU303
 1255 0010 6F4A     		ldr	r2, .L63+8
 1256 0012 1380     		strh	r3, [r2]
 332:Src/motor.c   **** 	/* sprintf(usart_buffer, "motorl: %d\n", motorl_speed); */
 333:Src/motor.c   **** 	/* USART_SendString(usart_buffer); */
 334:Src/motor.c   **** 	TIM3->CNT = 0x7FFF; // Reset back to center point
 1257              		.loc 1 334 2 is_stmt 1 view .LVU304
 1258              		.loc 1 334 12 is_stmt 0 view .LVU305
 1259 0014 6F48     		ldr	r0, .L63+12
 1260 0016 4862     		str	r0, [r1, #36]
 335:Src/motor.c   **** 	motorr_speed = (TIM1->CNT - 0x7FFF);
 1261              		.loc 1 335 2 is_stmt 1 view .LVU306
 1262              		.loc 1 335 22 is_stmt 0 view .LVU307
 1263 0018 6F49     		ldr	r1, .L63+16
 1264 001a 4B6A     		ldr	r3, [r1, #36]
 1265              		.loc 1 335 28 view .LVU308
 1266 001c 6344     		add	r3, r3, ip
 1267 001e 1BB2     		sxth	r3, r3
 1268              		.loc 1 335 15 view .LVU309
 1269 0020 6E4C     		ldr	r4, .L63+20
 1270 0022 2380     		strh	r3, [r4]
ARM GAS  /tmp/cclLk6It.s 			page 43


 336:Src/motor.c   **** 	TIM1->CNT = 0x7FFF; // Reset back to center point
 1271              		.loc 1 336 2 is_stmt 1 view .LVU310
 1272              		.loc 1 336 12 is_stmt 0 view .LVU311
 1273 0024 4862     		str	r0, [r1, #36]
 337:Src/motor.c   **** 
 338:Src/motor.c   **** 	if(abs(motorl_speed)>50){
 1274              		.loc 1 338 2 is_stmt 1 view .LVU312
 1275              		.loc 1 338 5 is_stmt 0 view .LVU313
 1276 0026 1388     		ldrh	r3, [r2]
 1277 0028 1BB2     		sxth	r3, r3
 1278 002a DA17     		asrs	r2, r3, #31
 1279 002c 9B18     		adds	r3, r3, r2
 1280 002e 5340     		eors	r3, r2
 1281 0030 9BB2     		uxth	r3, r3
 1282              		.loc 1 338 4 view .LVU314
 1283 0032 322B     		cmp	r3, #50
 1284 0034 49D9     		bls	.L53
 1285              	.LBB12:
 339:Src/motor.c   **** 		float ratio = ((float) abs(motorl_speed))/ ((float) abs(motorr_speed));
 1286              		.loc 1 339 3 is_stmt 1 view .LVU315
 1287              		.loc 1 339 26 is_stmt 0 view .LVU316
 1288 0036 664B     		ldr	r3, .L63+8
 1289 0038 1888     		ldrh	r0, [r3]
 1290 003a 00B2     		sxth	r0, r0
 1291 003c C317     		asrs	r3, r0, #31
 1292 003e C018     		adds	r0, r0, r3
 1293 0040 5840     		eors	r0, r3
 1294 0042 80B2     		uxth	r0, r0
 1295              		.loc 1 339 18 view .LVU317
 1296 0044 FFF7FEFF 		bl	__aeabi_i2f
 1297              	.LVL88:
 1298 0048 041C     		adds	r4, r0, #0
 1299              		.loc 1 339 55 view .LVU318
 1300 004a 644B     		ldr	r3, .L63+20
 1301 004c 1B88     		ldrh	r3, [r3]
 1302 004e 1BB2     		sxth	r3, r3
 1303 0050 DA17     		asrs	r2, r3, #31
 1304 0052 9B18     		adds	r3, r3, r2
 1305 0054 5340     		eors	r3, r2
 1306 0056 98B2     		uxth	r0, r3
 1307              		.loc 1 339 47 view .LVU319
 1308 0058 FFF7FEFF 		bl	__aeabi_i2f
 1309              	.LVL89:
 1310 005c 011C     		adds	r1, r0, #0
 1311              		.loc 1 339 9 view .LVU320
 1312 005e 201C     		adds	r0, r4, #0
 1313 0060 FFF7FEFF 		bl	__aeabi_fdiv
 1314              	.LVL90:
 1315 0064 041C     		adds	r4, r0, #0
 1316              	.LVL91:
 340:Src/motor.c   **** 		pwm_right = min((int)(pwm_right * ratio), 100);
 1317              		.loc 1 340 3 is_stmt 1 view .LVU321
 1318              		.loc 1 340 15 is_stmt 0 view .LVU322
 1319 0066 5E4B     		ldr	r3, .L63+24
 1320 0068 1878     		ldrb	r0, [r3]
 1321              	.LVL92:
 1322              		.loc 1 340 15 view .LVU323
ARM GAS  /tmp/cclLk6It.s 			page 44


 1323 006a C0B2     		uxtb	r0, r0
 1324 006c FFF7FEFF 		bl	__aeabi_i2f
 1325              	.LVL93:
 1326 0070 211C     		adds	r1, r4, #0
 1327 0072 FFF7FEFF 		bl	__aeabi_fmul
 1328              	.LVL94:
 1329 0076 FFF7FEFF 		bl	__aeabi_f2iz
 1330              	.LVL95:
 1331              		.loc 1 340 13 view .LVU324
 1332 007a 6428     		cmp	r0, #100
 1333 007c 0BDC     		bgt	.L59
 1334              		.loc 1 340 15 discriminator 1 view .LVU325
 1335 007e 584B     		ldr	r3, .L63+24
 1336 0080 1878     		ldrb	r0, [r3]
 1337 0082 C0B2     		uxtb	r0, r0
 1338 0084 FFF7FEFF 		bl	__aeabi_i2f
 1339              	.LVL96:
 1340 0088 211C     		adds	r1, r4, #0
 1341 008a FFF7FEFF 		bl	__aeabi_fmul
 1342              	.LVL97:
 1343 008e FFF7FEFF 		bl	__aeabi_f2iz
 1344              	.LVL98:
 1345              		.loc 1 340 13 discriminator 1 view .LVU326
 1346 0092 C0B2     		uxtb	r0, r0
 1347 0094 00E0     		b	.L54
 1348              	.L59:
 1349              		.loc 1 340 13 view .LVU327
 1350 0096 6420     		movs	r0, #100
 1351              	.L54:
 1352              		.loc 1 340 13 discriminator 4 view .LVU328
 1353 0098 514C     		ldr	r4, .L63+24
 1354              	.LVL99:
 1355              		.loc 1 340 13 discriminator 4 view .LVU329
 1356 009a 2070     		strb	r0, [r4]
 341:Src/motor.c   **** 		pwm_setDutyCycleR(pwm_right);
 1357              		.loc 1 341 3 is_stmt 1 discriminator 4 view .LVU330
 1358 009c 2078     		ldrb	r0, [r4]
 1359 009e C0B2     		uxtb	r0, r0
 1360 00a0 FFF7FEFF 		bl	pwm_setDutyCycleR
 1361              	.LVL100:
 342:Src/motor.c   **** #if PRINT_DEBUG
 343:Src/motor.c   **** 		sprintf(usart_buffer, "pwm_right: %d\n", pwm_right);
 1362              		.loc 1 343 3 discriminator 4 view .LVU331
 1363 00a4 2278     		ldrb	r2, [r4]
 1364 00a6 D2B2     		uxtb	r2, r2
 1365 00a8 4E49     		ldr	r1, .L63+28
 1366 00aa 6846     		mov	r0, sp
 1367 00ac FFF7FEFF 		bl	sprintf
 1368              	.LVL101:
 344:Src/motor.c   **** 		USART_SendString(usart_buffer);
 1369              		.loc 1 344 3 discriminator 4 view .LVU332
 1370 00b0 6846     		mov	r0, sp
 1371 00b2 FFF7FEFF 		bl	USART_SendString
 1372              	.LVL102:
 345:Src/motor.c   **** 		sprintf(usart_buffer, "motorr: %d\n", motorr_speed);
 1373              		.loc 1 345 3 discriminator 4 view .LVU333
 1374 00b6 494B     		ldr	r3, .L63+20
ARM GAS  /tmp/cclLk6It.s 			page 45


 1375 00b8 1A88     		ldrh	r2, [r3]
 1376 00ba 12B2     		sxth	r2, r2
 1377 00bc 4A49     		ldr	r1, .L63+32
 1378 00be 6846     		mov	r0, sp
 1379 00c0 FFF7FEFF 		bl	sprintf
 1380              	.LVL103:
 346:Src/motor.c   **** 		USART_SendString(usart_buffer);
 1381              		.loc 1 346 3 discriminator 4 view .LVU334
 1382 00c4 6846     		mov	r0, sp
 1383 00c6 FFF7FEFF 		bl	USART_SendString
 1384              	.LVL104:
 1385              	.L53:
 1386              		.loc 1 346 3 is_stmt 0 discriminator 4 view .LVU335
 1387              	.LBE12:
 347:Src/motor.c   **** #endif
 348:Src/motor.c   **** 	}
 349:Src/motor.c   **** 
 350:Src/motor.c   **** 	if(target_dist > 0){
 1388              		.loc 1 350 2 is_stmt 1 view .LVU336
 1389              		.loc 1 350 17 is_stmt 0 view .LVU337
 1390 00ca 484B     		ldr	r3, .L63+36
 1391 00cc 1B78     		ldrb	r3, [r3]
 1392              		.loc 1 350 4 view .LVU338
 1393 00ce 002B     		cmp	r3, #0
 1394 00d0 06D1     		bne	.L60
 1395              	.L55:
 351:Src/motor.c   **** 		current_dist += (float)abs(motorl_speed)/132;
 352:Src/motor.c   **** #if PRINT_DEBUG
 353:Src/motor.c   **** 		sprintf(usart_buffer, "current_dist: %d\n", (int)current_dist);
 354:Src/motor.c   **** 		USART_SendString(usart_buffer);
 355:Src/motor.c   **** #endif
 356:Src/motor.c   **** 		uint8_t obj = 0;
 357:Src/motor.c   **** 		if (((uint8_t)current_dist >= target_dist) || (!turning && (obj = ObjectDetected()))){
 358:Src/motor.c   **** 			if(obj)
 359:Src/motor.c   **** 				USART_SendString("Object detected\n");
 360:Src/motor.c   **** 			else
 361:Src/motor.c   **** 				USART_SendString("Hit distance target\n");
 362:Src/motor.c   **** 			motors_Off();
 363:Src/motor.c   **** 			motorl_speed = (TIM3->CNT - 0x7FFF);
 364:Src/motor.c   **** 			TIM3->CNT = 0x7FFF; // Reset back to center point
 365:Src/motor.c   **** 			motorr_speed = (TIM1->CNT - 0x7FFF);
 366:Src/motor.c   **** 			TIM1->CNT = 0x7FFF; // Reset back to center point
 367:Src/motor.c   **** 			pwm_right = 0;
 368:Src/motor.c   **** 			if(!turning){
 369:Src/motor.c   **** 				absolute_dist += current_dist * (float)cos((double)heading);
 370:Src/motor.c   **** 				sprintf(usart_buffer, "heading: %d\n", (int)heading);
 371:Src/motor.c   **** 				USART_SendString(usart_buffer);
 372:Src/motor.c   **** 			}
 373:Src/motor.c   **** 			target_dist = 0;
 374:Src/motor.c   **** 			current_dist = 0;
 375:Src/motor.c   **** 		}
 376:Src/motor.c   **** 	}
 377:Src/motor.c   **** 
 378:Src/motor.c   **** 	// Call the PI update function
 379:Src/motor.c   **** 	TIM6->SR &= ~TIM_SR_UIF;        // Acknowledge the interrupt
 1396              		.loc 1 379 2 is_stmt 1 view .LVU339
 1397              		.loc 1 379 6 is_stmt 0 view .LVU340
ARM GAS  /tmp/cclLk6It.s 			page 46


 1398 00d2 474A     		ldr	r2, .L63+40
 1399 00d4 1369     		ldr	r3, [r2, #16]
 1400              		.loc 1 379 11 view .LVU341
 1401 00d6 0121     		movs	r1, #1
 1402 00d8 8B43     		bics	r3, r1
 1403 00da 1361     		str	r3, [r2, #16]
 380:Src/motor.c   **** }
 1404              		.loc 1 380 1 view .LVU342
 1405 00dc 09B0     		add	sp, sp, #36
 1406              		@ sp needed
 1407 00de 30BD     		pop	{r4, r5, pc}
 1408              	.L60:
 1409              	.LBB13:
 351:Src/motor.c   **** 		current_dist += (float)abs(motorl_speed)/132;
 1410              		.loc 1 351 3 is_stmt 1 view .LVU343
 351:Src/motor.c   **** 		current_dist += (float)abs(motorl_speed)/132;
 1411              		.loc 1 351 26 is_stmt 0 view .LVU344
 1412 00e0 3B4B     		ldr	r3, .L63+8
 1413 00e2 1888     		ldrh	r0, [r3]
 1414 00e4 00B2     		sxth	r0, r0
 1415 00e6 C317     		asrs	r3, r0, #31
 1416 00e8 C018     		adds	r0, r0, r3
 1417 00ea 5840     		eors	r0, r3
 1418 00ec 80B2     		uxth	r0, r0
 351:Src/motor.c   **** 		current_dist += (float)abs(motorl_speed)/132;
 1419              		.loc 1 351 19 view .LVU345
 1420 00ee FFF7FEFF 		bl	__aeabi_i2f
 1421              	.LVL105:
 351:Src/motor.c   **** 		current_dist += (float)abs(motorl_speed)/132;
 1422              		.loc 1 351 43 view .LVU346
 1423 00f2 4049     		ldr	r1, .L63+44
 1424 00f4 FFF7FEFF 		bl	__aeabi_fdiv
 1425              	.LVL106:
 1426 00f8 011C     		adds	r1, r0, #0
 351:Src/motor.c   **** 		current_dist += (float)abs(motorl_speed)/132;
 1427              		.loc 1 351 16 view .LVU347
 1428 00fa 3F4C     		ldr	r4, .L63+48
 1429 00fc 2068     		ldr	r0, [r4]
 1430 00fe FFF7FEFF 		bl	__aeabi_fadd
 1431              	.LVL107:
 1432 0102 2060     		str	r0, [r4]
 353:Src/motor.c   **** 		USART_SendString(usart_buffer);
 1433              		.loc 1 353 3 is_stmt 1 view .LVU348
 1434 0104 2068     		ldr	r0, [r4]
 1435 0106 FFF7FEFF 		bl	__aeabi_f2iz
 1436              	.LVL108:
 1437 010a 0200     		movs	r2, r0
 1438 010c 3B49     		ldr	r1, .L63+52
 1439 010e 6846     		mov	r0, sp
 1440 0110 FFF7FEFF 		bl	sprintf
 1441              	.LVL109:
 354:Src/motor.c   **** #endif
 1442              		.loc 1 354 3 view .LVU349
 1443 0114 6846     		mov	r0, sp
 1444 0116 FFF7FEFF 		bl	USART_SendString
 1445              	.LVL110:
 356:Src/motor.c   **** 		if (((uint8_t)current_dist >= target_dist) || (!turning && (obj = ObjectDetected()))){
ARM GAS  /tmp/cclLk6It.s 			page 47


 1446              		.loc 1 356 3 view .LVU350
 357:Src/motor.c   **** 			if(obj)
 1447              		.loc 1 357 3 view .LVU351
 357:Src/motor.c   **** 			if(obj)
 1448              		.loc 1 357 8 is_stmt 0 view .LVU352
 1449 011a 2068     		ldr	r0, [r4]
 1450 011c FFF7FEFF 		bl	__aeabi_f2uiz
 1451              	.LVL111:
 1452 0120 C0B2     		uxtb	r0, r0
 357:Src/motor.c   **** 			if(obj)
 1453              		.loc 1 357 30 view .LVU353
 1454 0122 324B     		ldr	r3, .L63+36
 1455 0124 1B78     		ldrb	r3, [r3]
 1456 0126 DBB2     		uxtb	r3, r3
 357:Src/motor.c   **** 			if(obj)
 1457              		.loc 1 357 6 view .LVU354
 1458 0128 9842     		cmp	r0, r3
 1459 012a 0BD2     		bcs	.L61
 357:Src/motor.c   **** 			if(obj)
 1460              		.loc 1 357 50 discriminator 1 view .LVU355
 1461 012c 344B     		ldr	r3, .L63+56
 1462 012e 1B78     		ldrb	r3, [r3]
 357:Src/motor.c   **** 			if(obj)
 1463              		.loc 1 357 46 discriminator 1 view .LVU356
 1464 0130 002B     		cmp	r3, #0
 1465 0132 CED1     		bne	.L55
 357:Src/motor.c   **** 			if(obj)
 1466              		.loc 1 357 69 discriminator 2 view .LVU357
 1467 0134 FFF7FEFF 		bl	ObjectDetected
 1468              	.LVL112:
 357:Src/motor.c   **** 			if(obj)
 1469              		.loc 1 357 59 discriminator 2 view .LVU358
 1470 0138 0028     		cmp	r0, #0
 1471 013a CAD0     		beq	.L55
 358:Src/motor.c   **** 				USART_SendString("Object detected\n");
 1472              		.loc 1 358 4 is_stmt 1 view .LVU359
 359:Src/motor.c   **** 			else
 1473              		.loc 1 359 5 view .LVU360
 1474 013c 3148     		ldr	r0, .L63+60
 1475              	.LVL113:
 359:Src/motor.c   **** 			else
 1476              		.loc 1 359 5 is_stmt 0 view .LVU361
 1477 013e FFF7FEFF 		bl	USART_SendString
 1478              	.LVL114:
 1479 0142 02E0     		b	.L57
 1480              	.LVL115:
 1481              	.L61:
 358:Src/motor.c   **** 				USART_SendString("Object detected\n");
 1482              		.loc 1 358 4 is_stmt 1 view .LVU362
 361:Src/motor.c   **** 			motors_Off();
 1483              		.loc 1 361 5 view .LVU363
 1484 0144 3048     		ldr	r0, .L63+64
 1485 0146 FFF7FEFF 		bl	USART_SendString
 1486              	.LVL116:
 1487              	.L57:
 362:Src/motor.c   **** 			motorl_speed = (TIM3->CNT - 0x7FFF);
 1488              		.loc 1 362 4 view .LVU364
ARM GAS  /tmp/cclLk6It.s 			page 48


 1489 014a FFF7FEFF 		bl	motors_Off
 1490              	.LVL117:
 363:Src/motor.c   **** 			TIM3->CNT = 0x7FFF; // Reset back to center point
 1491              		.loc 1 363 4 view .LVU365
 363:Src/motor.c   **** 			TIM3->CNT = 0x7FFF; // Reset back to center point
 1492              		.loc 1 363 24 is_stmt 0 view .LVU366
 1493 014e 1E4A     		ldr	r2, .L63
 1494 0150 536A     		ldr	r3, [r2, #36]
 363:Src/motor.c   **** 			TIM3->CNT = 0x7FFF; // Reset back to center point
 1495              		.loc 1 363 30 view .LVU367
 1496 0152 1E49     		ldr	r1, .L63+4
 1497 0154 8C46     		mov	ip, r1
 1498 0156 6344     		add	r3, r3, ip
 1499 0158 1BB2     		sxth	r3, r3
 363:Src/motor.c   **** 			TIM3->CNT = 0x7FFF; // Reset back to center point
 1500              		.loc 1 363 17 view .LVU368
 1501 015a 1D49     		ldr	r1, .L63+8
 1502 015c 0B80     		strh	r3, [r1]
 364:Src/motor.c   **** 			motorr_speed = (TIM1->CNT - 0x7FFF);
 1503              		.loc 1 364 4 is_stmt 1 view .LVU369
 364:Src/motor.c   **** 			motorr_speed = (TIM1->CNT - 0x7FFF);
 1504              		.loc 1 364 14 is_stmt 0 view .LVU370
 1505 015e 1D49     		ldr	r1, .L63+12
 1506 0160 5162     		str	r1, [r2, #36]
 365:Src/motor.c   **** 			TIM1->CNT = 0x7FFF; // Reset back to center point
 1507              		.loc 1 365 4 is_stmt 1 view .LVU371
 365:Src/motor.c   **** 			TIM1->CNT = 0x7FFF; // Reset back to center point
 1508              		.loc 1 365 24 is_stmt 0 view .LVU372
 1509 0162 1D4A     		ldr	r2, .L63+16
 1510 0164 536A     		ldr	r3, [r2, #36]
 365:Src/motor.c   **** 			TIM1->CNT = 0x7FFF; // Reset back to center point
 1511              		.loc 1 365 30 view .LVU373
 1512 0166 6344     		add	r3, r3, ip
 1513 0168 1BB2     		sxth	r3, r3
 365:Src/motor.c   **** 			TIM1->CNT = 0x7FFF; // Reset back to center point
 1514              		.loc 1 365 17 view .LVU374
 1515 016a 1C48     		ldr	r0, .L63+20
 1516 016c 0380     		strh	r3, [r0]
 366:Src/motor.c   **** 			pwm_right = 0;
 1517              		.loc 1 366 4 is_stmt 1 view .LVU375
 366:Src/motor.c   **** 			pwm_right = 0;
 1518              		.loc 1 366 14 is_stmt 0 view .LVU376
 1519 016e 5162     		str	r1, [r2, #36]
 367:Src/motor.c   **** 			if(!turning){
 1520              		.loc 1 367 4 is_stmt 1 view .LVU377
 367:Src/motor.c   **** 			if(!turning){
 1521              		.loc 1 367 14 is_stmt 0 view .LVU378
 1522 0170 1B4B     		ldr	r3, .L63+24
 1523 0172 0022     		movs	r2, #0
 1524 0174 1A70     		strb	r2, [r3]
 368:Src/motor.c   **** 				absolute_dist += current_dist * (float)cos((double)heading);
 1525              		.loc 1 368 4 is_stmt 1 view .LVU379
 368:Src/motor.c   **** 				absolute_dist += current_dist * (float)cos((double)heading);
 1526              		.loc 1 368 7 is_stmt 0 view .LVU380
 1527 0176 224B     		ldr	r3, .L63+56
 1528 0178 1B78     		ldrb	r3, [r3]
 368:Src/motor.c   **** 				absolute_dist += current_dist * (float)cos((double)heading);
ARM GAS  /tmp/cclLk6It.s 			page 49


 1529              		.loc 1 368 6 view .LVU381
 1530 017a 002B     		cmp	r3, #0
 1531 017c 06D0     		beq	.L62
 1532              	.L58:
 373:Src/motor.c   **** 			current_dist = 0;
 1533              		.loc 1 373 4 is_stmt 1 view .LVU382
 373:Src/motor.c   **** 			current_dist = 0;
 1534              		.loc 1 373 16 is_stmt 0 view .LVU383
 1535 017e 1B4B     		ldr	r3, .L63+36
 1536 0180 0022     		movs	r2, #0
 1537 0182 1A70     		strb	r2, [r3]
 374:Src/motor.c   **** 		}
 1538              		.loc 1 374 4 is_stmt 1 view .LVU384
 374:Src/motor.c   **** 		}
 1539              		.loc 1 374 17 is_stmt 0 view .LVU385
 1540 0184 1C4B     		ldr	r3, .L63+48
 1541 0186 0022     		movs	r2, #0
 1542 0188 1A60     		str	r2, [r3]
 1543 018a A2E7     		b	.L55
 1544              	.L62:
 369:Src/motor.c   **** 				sprintf(usart_buffer, "heading: %d\n", (int)heading);
 1545              		.loc 1 369 5 is_stmt 1 view .LVU386
 369:Src/motor.c   **** 				sprintf(usart_buffer, "heading: %d\n", (int)heading);
 1546              		.loc 1 369 44 is_stmt 0 view .LVU387
 1547 018c 1F4C     		ldr	r4, .L63+68
 1548 018e 2068     		ldr	r0, [r4]
 1549 0190 FFF7FEFF 		bl	__aeabi_f2d
 1550              	.LVL118:
 1551 0194 FFF7FEFF 		bl	cos
 1552              	.LVL119:
 369:Src/motor.c   **** 				sprintf(usart_buffer, "heading: %d\n", (int)heading);
 1553              		.loc 1 369 37 view .LVU388
 1554 0198 FFF7FEFF 		bl	__aeabi_d2f
 1555              	.LVL120:
 369:Src/motor.c   **** 				sprintf(usart_buffer, "heading: %d\n", (int)heading);
 1556              		.loc 1 369 35 view .LVU389
 1557 019c 164B     		ldr	r3, .L63+48
 1558 019e 1968     		ldr	r1, [r3]
 1559 01a0 FFF7FEFF 		bl	__aeabi_fmul
 1560              	.LVL121:
 1561 01a4 011C     		adds	r1, r0, #0
 369:Src/motor.c   **** 				sprintf(usart_buffer, "heading: %d\n", (int)heading);
 1562              		.loc 1 369 19 view .LVU390
 1563 01a6 1A4D     		ldr	r5, .L63+72
 1564 01a8 2868     		ldr	r0, [r5]
 1565 01aa FFF7FEFF 		bl	__aeabi_fadd
 1566              	.LVL122:
 1567 01ae 2860     		str	r0, [r5]
 370:Src/motor.c   **** 				USART_SendString(usart_buffer);
 1568              		.loc 1 370 5 is_stmt 1 view .LVU391
 1569 01b0 2068     		ldr	r0, [r4]
 1570 01b2 FFF7FEFF 		bl	__aeabi_f2iz
 1571              	.LVL123:
 1572 01b6 0200     		movs	r2, r0
 1573 01b8 1649     		ldr	r1, .L63+76
 1574 01ba 6846     		mov	r0, sp
 1575 01bc FFF7FEFF 		bl	sprintf
ARM GAS  /tmp/cclLk6It.s 			page 50


 1576              	.LVL124:
 371:Src/motor.c   **** 			}
 1577              		.loc 1 371 5 view .LVU392
 1578 01c0 6846     		mov	r0, sp
 1579 01c2 FFF7FEFF 		bl	USART_SendString
 1580              	.LVL125:
 1581 01c6 DAE7     		b	.L58
 1582              	.L64:
 1583              		.align	2
 1584              	.L63:
 1585 01c8 00040040 		.word	1073742848
 1586 01cc 0180FFFF 		.word	-32767
 1587 01d0 00000000 		.word	motorl_speed
 1588 01d4 FF7F0000 		.word	32767
 1589 01d8 002C0140 		.word	1073818624
 1590 01dc 00000000 		.word	motorr_speed
 1591 01e0 00000000 		.word	pwm_right
 1592 01e4 00000000 		.word	.LC31
 1593 01e8 10000000 		.word	.LC33
 1594 01ec 00000000 		.word	target_dist
 1595 01f0 00100040 		.word	1073745920
 1596 01f4 00000443 		.word	1124335616
 1597 01f8 00000000 		.word	current_dist
 1598 01fc 1C000000 		.word	.LC37
 1599 0200 00000000 		.word	turning
 1600 0204 48000000 		.word	.LC42
 1601 0208 30000000 		.word	.LC39
 1602 020c 00000000 		.word	heading
 1603 0210 00000000 		.word	absolute_dist
 1604 0214 5C000000 		.word	.LC46
 1605              	.LBE13:
 1606              		.cfi_endproc
 1607              	.LFE56:
 1609              		.section	.text.get_distance,"ax",%progbits
 1610              		.align	1
 1611              		.global	get_distance
 1612              		.syntax unified
 1613              		.code	16
 1614              		.thumb_func
 1616              	get_distance:
 1617              	.LFB57:
 381:Src/motor.c   **** 
 382:Src/motor.c   **** float get_distance(void){
 1618              		.loc 1 382 25 view -0
 1619              		.cfi_startproc
 1620              		@ args = 0, pretend = 0, frame = 0
 1621              		@ frame_needed = 0, uses_anonymous_args = 0
 1622              		@ link register save eliminated.
 383:Src/motor.c   **** 	return absolute_dist;
 1623              		.loc 1 383 2 view .LVU394
 1624              		.loc 1 383 9 is_stmt 0 view .LVU395
 1625 0000 014B     		ldr	r3, .L66
 1626 0002 1868     		ldr	r0, [r3]
 384:Src/motor.c   **** }
 1627              		.loc 1 384 1 view .LVU396
 1628              		@ sp needed
 1629 0004 7047     		bx	lr
ARM GAS  /tmp/cclLk6It.s 			page 51


 1630              	.L67:
 1631 0006 C046     		.align	2
 1632              	.L66:
 1633 0008 00000000 		.word	absolute_dist
 1634              		.cfi_endproc
 1635              	.LFE57:
 1637              		.global	__aeabi_d2iz
 1638              		.global	__aeabi_idivmod
 1639              		.section	.text.get_heading,"ax",%progbits
 1640              		.align	1
 1641              		.global	get_heading
 1642              		.syntax unified
 1643              		.code	16
 1644              		.thumb_func
 1646              	get_heading:
 1647              	.LFB58:
 385:Src/motor.c   **** 
 386:Src/motor.c   **** int32_t get_heading(){
 1648              		.loc 1 386 22 is_stmt 1 view -0
 1649              		.cfi_startproc
 1650              		@ args = 0, pretend = 0, frame = 0
 1651              		@ frame_needed = 0, uses_anonymous_args = 0
 1652 0000 10B5     		push	{r4, lr}
 1653              	.LCFI15:
 1654              		.cfi_def_cfa_offset 8
 1655              		.cfi_offset 4, -8
 1656              		.cfi_offset 14, -4
 387:Src/motor.c   **** 	return (int32_t)(heading * 57.3) % 360;
 1657              		.loc 1 387 2 view .LVU398
 1658              		.loc 1 387 27 is_stmt 0 view .LVU399
 1659 0002 084B     		ldr	r3, .L69
 1660 0004 1868     		ldr	r0, [r3]
 1661 0006 FFF7FEFF 		bl	__aeabi_f2d
 1662              	.LVL126:
 1663 000a 074A     		ldr	r2, .L69+4
 1664 000c 074B     		ldr	r3, .L69+8
 1665 000e FFF7FEFF 		bl	__aeabi_dmul
 1666              	.LVL127:
 1667              		.loc 1 387 9 view .LVU400
 1668 0012 FFF7FEFF 		bl	__aeabi_d2iz
 1669              	.LVL128:
 1670              		.loc 1 387 35 view .LVU401
 1671 0016 B421     		movs	r1, #180
 1672 0018 4900     		lsls	r1, r1, #1
 1673 001a FFF7FEFF 		bl	__aeabi_idivmod
 1674              	.LVL129:
 1675 001e 0800     		movs	r0, r1
 388:Src/motor.c   **** }
 1676              		.loc 1 388 1 view .LVU402
 1677              		@ sp needed
 1678 0020 10BD     		pop	{r4, pc}
 1679              	.L70:
 1680 0022 C046     		.align	2
 1681              	.L69:
 1682 0024 00000000 		.word	heading
 1683 0028 66666666 		.word	1717986918
 1684 002c 66A64C40 		.word	1078765158
ARM GAS  /tmp/cclLk6It.s 			page 52


 1685              		.cfi_endproc
 1686              	.LFE58:
 1688              		.global	pwm_left
 1689              		.section	.data.pwm_left,"aw"
 1692              	pwm_left:
 1693 0000 64       		.byte	100
 1694              		.global	pwm_right
 1695              		.section	.data.pwm_right,"aw"
 1698              	pwm_right:
 1699 0000 64       		.byte	100
 1700              		.global	turning
 1701              		.section	.bss.turning,"aw",%nobits
 1704              	turning:
 1705 0000 00       		.space	1
 1706              		.global	heading
 1707              		.section	.bss.heading,"aw",%nobits
 1708              		.align	2
 1711              	heading:
 1712 0000 00000000 		.space	4
 1713              		.global	absolute_dist
 1714              		.section	.bss.absolute_dist,"aw",%nobits
 1715              		.align	2
 1718              	absolute_dist:
 1719 0000 00000000 		.space	4
 1720              		.global	current_dist
 1721              		.section	.bss.current_dist,"aw",%nobits
 1722              		.align	2
 1725              	current_dist:
 1726 0000 00000000 		.space	4
 1727              		.global	target_dist
 1728              		.section	.bss.target_dist,"aw",%nobits
 1731              	target_dist:
 1732 0000 00       		.space	1
 1733              		.global	motorr_speed
 1734              		.section	.bss.motorr_speed,"aw",%nobits
 1735              		.align	1
 1738              	motorr_speed:
 1739 0000 0000     		.space	2
 1740              		.global	motorl_speed
 1741              		.section	.bss.motorl_speed,"aw",%nobits
 1742              		.align	1
 1745              	motorl_speed:
 1746 0000 0000     		.space	2
 1747              		.text
 1748              	.Letext0:
 1749              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1750              		.file 4 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
 1751              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1752              		.file 6 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h"
 1753              		.file 7 "Inc/pins.h"
 1754              		.file 8 "Inc/motor.h"
 1755              		.file 9 "/usr/arm-none-eabi/include/stdio.h"
 1756              		.file 10 "Inc/main.h"
 1757              		.file 11 "/usr/arm-none-eabi/include/math.h"
ARM GAS  /tmp/cclLk6It.s 			page 53


DEFINED SYMBOLS
                            *ABS*:00000000 motor.c
     /tmp/cclLk6It.s:19     .text.pwm_init:00000000 $t
     /tmp/cclLk6It.s:25     .text.pwm_init:00000000 pwm_init
     /tmp/cclLk6It.s:172    .text.pwm_init:00000094 $d
     /tmp/cclLk6It.s:181    .text.pwm_setDutyCycleL:00000000 $t
     /tmp/cclLk6It.s:187    .text.pwm_setDutyCycleL:00000000 pwm_setDutyCycleL
     /tmp/cclLk6It.s:224    .text.pwm_setDutyCycleL:00000018 $d
     /tmp/cclLk6It.s:229    .text.pwm_setDutyCycleR:00000000 $t
     /tmp/cclLk6It.s:235    .text.pwm_setDutyCycleR:00000000 pwm_setDutyCycleR
     /tmp/cclLk6It.s:274    .text.set_Motor_Direction:00000000 $t
     /tmp/cclLk6It.s:280    .text.set_Motor_Direction:00000000 set_Motor_Direction
     /tmp/cclLk6It.s:352    .text.set_Forward:00000000 $t
     /tmp/cclLk6It.s:358    .text.set_Forward:00000000 set_Forward
     /tmp/cclLk6It.s:397    .text.set_Forward:00000028 $d
     /tmp/cclLk6It.s:1698   .data.pwm_right:00000000 pwm_right
     /tmp/cclLk6It.s:1692   .data.pwm_left:00000000 pwm_left
     /tmp/cclLk6It.s:405    .text.set_Backward:00000000 $t
     /tmp/cclLk6It.s:411    .text.set_Backward:00000000 set_Backward
     /tmp/cclLk6It.s:450    .text.set_Backward:00000028 $d
     /tmp/cclLk6It.s:458    .text.set_Right:00000000 $t
     /tmp/cclLk6It.s:464    .text.set_Right:00000000 set_Right
     /tmp/cclLk6It.s:503    .text.set_Right:00000028 $d
     /tmp/cclLk6It.s:511    .text.set_Left:00000000 $t
     /tmp/cclLk6It.s:517    .text.set_Left:00000000 set_Left
     /tmp/cclLk6It.s:556    .text.set_Left:00000028 $d
     /tmp/cclLk6It.s:564    .text.motors_Off:00000000 $t
     /tmp/cclLk6It.s:570    .text.motors_Off:00000000 motors_Off
     /tmp/cclLk6It.s:596    .rodata.MoveMotors.str1.4:00000000 $d
     /tmp/cclLk6It.s:611    .text.MoveMotors:00000000 $t
     /tmp/cclLk6It.s:617    .text.MoveMotors:00000000 MoveMotors
     /tmp/cclLk6It.s:841    .text.MoveMotors:000000fc $d
     /tmp/cclLk6It.s:1704   .bss.turning:00000000 turning
     /tmp/cclLk6It.s:1731   .bss.target_dist:00000000 target_dist
     /tmp/cclLk6It.s:1711   .bss.heading:00000000 heading
     /tmp/cclLk6It.s:854    .text.encoder_init:00000000 $t
     /tmp/cclLk6It.s:860    .text.encoder_init:00000000 encoder_init
     /tmp/cclLk6It.s:1049   .text.encoder_init:000000a4 $d
     /tmp/cclLk6It.s:1062   .text.motor_init:00000000 $t
     /tmp/cclLk6It.s:1068   .text.motor_init:00000000 motor_init
     /tmp/cclLk6It.s:1092   .text.ObjectDetected:00000000 $t
     /tmp/cclLk6It.s:1098   .text.ObjectDetected:00000000 ObjectDetected
     /tmp/cclLk6It.s:1192   .text.ObjectDetected:0000003c $d
     /tmp/cclLk6It.s:1202   .rodata.TIM6_DAC_IRQHandler.str1.4:00000000 $d
     /tmp/cclLk6It.s:1223   .text.TIM6_DAC_IRQHandler:00000000 $t
     /tmp/cclLk6It.s:1229   .text.TIM6_DAC_IRQHandler:00000000 TIM6_DAC_IRQHandler
     /tmp/cclLk6It.s:1585   .text.TIM6_DAC_IRQHandler:000001c8 $d
     /tmp/cclLk6It.s:1745   .bss.motorl_speed:00000000 motorl_speed
     /tmp/cclLk6It.s:1738   .bss.motorr_speed:00000000 motorr_speed
     /tmp/cclLk6It.s:1725   .bss.current_dist:00000000 current_dist
     /tmp/cclLk6It.s:1718   .bss.absolute_dist:00000000 absolute_dist
     /tmp/cclLk6It.s:1610   .text.get_distance:00000000 $t
     /tmp/cclLk6It.s:1616   .text.get_distance:00000000 get_distance
     /tmp/cclLk6It.s:1633   .text.get_distance:00000008 $d
     /tmp/cclLk6It.s:1640   .text.get_heading:00000000 $t
     /tmp/cclLk6It.s:1646   .text.get_heading:00000000 get_heading
     /tmp/cclLk6It.s:1682   .text.get_heading:00000024 $d
ARM GAS  /tmp/cclLk6It.s 			page 54


     /tmp/cclLk6It.s:1705   .bss.turning:00000000 $d
     /tmp/cclLk6It.s:1708   .bss.heading:00000000 $d
     /tmp/cclLk6It.s:1715   .bss.absolute_dist:00000000 $d
     /tmp/cclLk6It.s:1722   .bss.current_dist:00000000 $d
     /tmp/cclLk6It.s:1732   .bss.target_dist:00000000 $d
     /tmp/cclLk6It.s:1735   .bss.motorr_speed:00000000 $d
     /tmp/cclLk6It.s:1742   .bss.motorl_speed:00000000 $d

UNDEFINED SYMBOLS
HAL_GPIO_WritePin
motor_left_pins
motor_right_pins
__aeabi_uidiv
__aeabi_i2d
__aeabi_ddiv
__aeabi_d2uiz
__aeabi_dmul
__aeabi_f2d
__aeabi_dadd
__aeabi_d2f
__aeabi_dsub
GetUltrasonic
ultrasonic_left_pins
ultrasonic_right_pins
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2iz
__aeabi_fadd
__aeabi_f2uiz
sprintf
USART_SendString
cos
__aeabi_d2iz
__aeabi_idivmod
