ARM GAS  /tmp/cc8ure6P.s 			page 1


   1              		.cpu cortex-m0
   2              		.arch armv6s-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"motor.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "Src/motor.c"
  18              		.section	.text.pwm_init,"ax",%progbits
  19              		.align	1
  20              		.global	pwm_init
  21              		.syntax unified
  22              		.code	16
  23              		.thumb_func
  25              	pwm_init:
  26              	.LFB44:
   1:Src/motor.c   **** /* ------------------------------------------------------------------------------------------------
   2:Src/motor.c   ****  *  Motor Control and Initialization Functions
   3:Src/motor.c   ****  * ------------------------------------------------------------------------------------------------
   4:Src/motor.c   ****  */
   5:Src/motor.c   **** #include "motor.h"
   6:Src/motor.c   **** 
   7:Src/motor.c   **** volatile int16_t error_integral = 0;    // Integrated error signal
   8:Src/motor.c   **** volatile uint8_t duty_cycle = 0;    	// Output PWM duty cycle
   9:Src/motor.c   **** volatile int16_t target_rpm = 0;    	// Desired speed target
  10:Src/motor.c   **** volatile int16_t motorl_speed = 0;   	// Measured left motor speed
  11:Src/motor.c   **** volatile int16_t motorr_speed = 0;   	// Measured left motor speed
  12:Src/motor.c   **** volatile int8_t adc_value = 0;      	// ADC measured motor current
  13:Src/motor.c   **** volatile int16_t error = 0;         	// Speed error signal
  14:Src/motor.c   **** volatile uint8_t Kp = 1;            	// Proportional gain
  15:Src/motor.c   **** volatile uint8_t Ki = 1;            	// Integral gain
  16:Src/motor.c   **** 
  17:Src/motor.c   **** // Sets up the entire motor drive system
  18:Src/motor.c   **** void motor_init(void) {
  19:Src/motor.c   ****     pwm_init();
  20:Src/motor.c   ****     encoder_init();
  21:Src/motor.c   ****     ADC_init();
  22:Src/motor.c   **** }
  23:Src/motor.c   **** 
  24:Src/motor.c   **** // Sets up the PWM and direction signals to drive the H-Bridge
  25:Src/motor.c   **** void pwm_init(void) {
  27              		.loc 1 25 21 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/cc8ure6P.s 			page 2


  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
  26:Src/motor.c   **** 	//RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
  27:Src/motor.c   **** 	
  28:Src/motor.c   ****     // Set up pin PA4 for H-bridge PWM output (TIMER 14 CH1)
  29:Src/motor.c   ****     GPIOA->MODER |= (1 << 9);
  38              		.loc 1 29 5 view .LVU1
  39              		.loc 1 29 10 is_stmt 0 view .LVU2
  40 0002 9022     		movs	r2, #144
  41 0004 D205     		lsls	r2, r2, #23
  42 0006 1168     		ldr	r1, [r2]
  43              		.loc 1 29 18 view .LVU3
  44 0008 8023     		movs	r3, #128
  45 000a 9B00     		lsls	r3, r3, #2
  46 000c 0B43     		orrs	r3, r1
  47 000e 1360     		str	r3, [r2]
  30:Src/motor.c   ****     GPIOA->MODER &= ~(1 << 8);
  48              		.loc 1 30 5 is_stmt 1 view .LVU4
  49              		.loc 1 30 10 is_stmt 0 view .LVU5
  50 0010 1368     		ldr	r3, [r2]
  51              		.loc 1 30 18 view .LVU6
  52 0012 3C49     		ldr	r1, .L2
  53 0014 0B40     		ands	r3, r1
  54 0016 1360     		str	r3, [r2]
  31:Src/motor.c   **** 	
  32:Src/motor.c   **** 	  // Set up pin PB3 for H-bridge PWM output (TIMER 2 CH2)
  33:Src/motor.c   ****     GPIOB->MODER |= (1 << 7);
  55              		.loc 1 33 5 is_stmt 1 view .LVU7
  56              		.loc 1 33 10 is_stmt 0 view .LVU8
  57 0018 3B4B     		ldr	r3, .L2+4
  58 001a 1968     		ldr	r1, [r3]
  59              		.loc 1 33 18 view .LVU9
  60 001c 8020     		movs	r0, #128
  61 001e 0143     		orrs	r1, r0
  62 0020 1960     		str	r1, [r3]
  34:Src/motor.c   ****     GPIOB->MODER &= ~(1 << 6);
  63              		.loc 1 34 5 is_stmt 1 view .LVU10
  64              		.loc 1 34 10 is_stmt 0 view .LVU11
  65 0022 1968     		ldr	r1, [r3]
  66              		.loc 1 34 18 view .LVU12
  67 0024 4038     		subs	r0, r0, #64
  68 0026 8143     		bics	r1, r0
  69 0028 1960     		str	r1, [r3]
  35:Src/motor.c   **** 
  36:Src/motor.c   ****     // Set PA4 to AF4,
  37:Src/motor.c   ****     GPIOA->AFR[0] &= 0xFFF0FFFF; // clear PA4 bits,
  70              		.loc 1 37 5 is_stmt 1 view .LVU13
  71              		.loc 1 37 15 is_stmt 0 view .LVU14
  72 002a 116A     		ldr	r1, [r2, #32]
  73              		.loc 1 37 19 view .LVU15
  74 002c 3748     		ldr	r0, .L2+8
  75 002e 0140     		ands	r1, r0
  76 0030 1162     		str	r1, [r2, #32]
  38:Src/motor.c   ****     GPIOA->AFR[0] |= (1 << 18);
  77              		.loc 1 38 5 is_stmt 1 view .LVU16
ARM GAS  /tmp/cc8ure6P.s 			page 3


  78              		.loc 1 38 15 is_stmt 0 view .LVU17
  79 0032 106A     		ldr	r0, [r2, #32]
  80              		.loc 1 38 19 view .LVU18
  81 0034 8021     		movs	r1, #128
  82 0036 C902     		lsls	r1, r1, #11
  83 0038 0143     		orrs	r1, r0
  84 003a 1162     		str	r1, [r2, #32]
  39:Src/motor.c   **** 	
  40:Src/motor.c   **** 		// Set PB3 to AF2,
  41:Src/motor.c   ****     GPIOB->AFR[0] &= 0xFFFF0FFF; // clear PB3 bits,
  85              		.loc 1 41 5 is_stmt 1 view .LVU19
  86              		.loc 1 41 15 is_stmt 0 view .LVU20
  87 003c 196A     		ldr	r1, [r3, #32]
  88              		.loc 1 41 19 view .LVU21
  89 003e 3448     		ldr	r0, .L2+12
  90 0040 0140     		ands	r1, r0
  91 0042 1962     		str	r1, [r3, #32]
  42:Src/motor.c   ****     GPIOB->AFR[0] |= (1 << 13);
  92              		.loc 1 42 5 is_stmt 1 view .LVU22
  93              		.loc 1 42 15 is_stmt 0 view .LVU23
  94 0044 186A     		ldr	r0, [r3, #32]
  95              		.loc 1 42 19 view .LVU24
  96 0046 8021     		movs	r1, #128
  97 0048 8901     		lsls	r1, r1, #6
  98 004a 0143     		orrs	r1, r0
  99 004c 1962     		str	r1, [r3, #32]
  43:Src/motor.c   **** 
  44:Src/motor.c   ****     // Set up a PA5, PA8 as GPIO output pins for motor direction control
  45:Src/motor.c   ****     GPIOA->MODER &= 0xFFFCF3FF; // clear PA5, PA6 bits,
 100              		.loc 1 45 5 is_stmt 1 view .LVU25
 101              		.loc 1 45 10 is_stmt 0 view .LVU26
 102 004e 1168     		ldr	r1, [r2]
 103              		.loc 1 45 18 view .LVU27
 104 0050 3048     		ldr	r0, .L2+16
 105 0052 0140     		ands	r1, r0
 106 0054 1160     		str	r1, [r2]
  46:Src/motor.c   ****     GPIOA->MODER |= (1 << 10) | (1 << 16);
 107              		.loc 1 46 5 is_stmt 1 view .LVU28
 108              		.loc 1 46 10 is_stmt 0 view .LVU29
 109 0056 1068     		ldr	r0, [r2]
 110              		.loc 1 46 18 view .LVU30
 111 0058 8221     		movs	r1, #130
 112 005a 4902     		lsls	r1, r1, #9
 113 005c 0143     		orrs	r1, r0
 114 005e 1160     		str	r1, [r2]
  47:Src/motor.c   **** 	
  48:Src/motor.c   **** 		// Set up a PB2, PB10 as GPIO output pins for motor direction control
  49:Src/motor.c   ****     GPIOB->MODER &= 0xFFCFFFCF; // clear PB2, PB10 bits,
 115              		.loc 1 49 5 is_stmt 1 view .LVU31
 116              		.loc 1 49 10 is_stmt 0 view .LVU32
 117 0060 1A68     		ldr	r2, [r3]
 118              		.loc 1 49 18 view .LVU33
 119 0062 2D49     		ldr	r1, .L2+20
 120 0064 0A40     		ands	r2, r1
 121 0066 1A60     		str	r2, [r3]
  50:Src/motor.c   ****     GPIOB->MODER |= (1 << 4) | (1 << 20);
 122              		.loc 1 50 5 is_stmt 1 view .LVU34
ARM GAS  /tmp/cc8ure6P.s 			page 4


 123              		.loc 1 50 10 is_stmt 0 view .LVU35
 124 0068 1968     		ldr	r1, [r3]
 125              		.loc 1 50 18 view .LVU36
 126 006a 2C4A     		ldr	r2, .L2+24
 127 006c 0A43     		orrs	r2, r1
 128 006e 1A60     		str	r2, [r3]
  51:Src/motor.c   ****    
  52:Src/motor.c   ****     //Initialize one direction pin to high, the other low
  53:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_a.gpio, motor_left_pins.dir_a.pin.Pin, GPIO_PIN_SET);
 129              		.loc 1 53 2 is_stmt 1 view .LVU37
 130              		.loc 1 53 73 is_stmt 0 view .LVU38
 131 0070 2B4C     		ldr	r4, .L2+28
 132              		.loc 1 53 2 view .LVU39
 133 0072 A18B     		ldrh	r1, [r4, #28]
 134 0074 A069     		ldr	r0, [r4, #24]
 135 0076 0122     		movs	r2, #1
 136 0078 FFF7FEFF 		bl	HAL_GPIO_WritePin
 137              	.LVL0:
  54:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_b.gpio, motor_left_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
 138              		.loc 1 54 2 is_stmt 1 view .LVU40
 139 007c A18E     		ldrh	r1, [r4, #52]
 140 007e 206B     		ldr	r0, [r4, #48]
 141 0080 0022     		movs	r2, #0
 142 0082 FFF7FEFF 		bl	HAL_GPIO_WritePin
 143              	.LVL1:
  55:Src/motor.c   **** 
  56:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_a.gpio, motor_right_pins.dir_a.pin.Pin, GPIO_PIN_SET);
 144              		.loc 1 56 2 view .LVU41
 145              		.loc 1 56 75 is_stmt 0 view .LVU42
 146 0086 274C     		ldr	r4, .L2+32
 147              		.loc 1 56 2 view .LVU43
 148 0088 A18B     		ldrh	r1, [r4, #28]
 149 008a A069     		ldr	r0, [r4, #24]
 150 008c 0122     		movs	r2, #1
 151 008e FFF7FEFF 		bl	HAL_GPIO_WritePin
 152              	.LVL2:
  57:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_b.gpio, motor_right_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
 153              		.loc 1 57 2 is_stmt 1 view .LVU44
 154 0092 A18E     		ldrh	r1, [r4, #52]
 155 0094 206B     		ldr	r0, [r4, #48]
 156 0096 0022     		movs	r2, #0
 157 0098 FFF7FEFF 		bl	HAL_GPIO_WritePin
 158              	.LVL3:
  58:Src/motor.c   **** 
  59:Src/motor.c   ****     // Set up PWM timer
  60:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;
 159              		.loc 1 60 5 view .LVU45
 160              		.loc 1 60 8 is_stmt 0 view .LVU46
 161 009c 224B     		ldr	r3, .L2+36
 162 009e D969     		ldr	r1, [r3, #28]
 163              		.loc 1 60 18 view .LVU47
 164 00a0 8022     		movs	r2, #128
 165 00a2 5200     		lsls	r2, r2, #1
 166 00a4 0A43     		orrs	r2, r1
 167 00a6 DA61     		str	r2, [r3, #28]
  61:Src/motor.c   ****     TIM14->CR1 = 0;                         // Clear control registers
 168              		.loc 1 61 5 is_stmt 1 view .LVU48
ARM GAS  /tmp/cc8ure6P.s 			page 5


 169              		.loc 1 61 16 is_stmt 0 view .LVU49
 170 00a8 204A     		ldr	r2, .L2+40
 171 00aa 0021     		movs	r1, #0
 172 00ac 1160     		str	r1, [r2]
  62:Src/motor.c   ****     TIM14->CCMR1 = 0;                       // (prevents having to manually clear bits)
 173              		.loc 1 62 5 is_stmt 1 view .LVU50
 174              		.loc 1 62 18 is_stmt 0 view .LVU51
 175 00ae 9161     		str	r1, [r2, #24]
  63:Src/motor.c   ****     TIM14->CCER = 0;
 176              		.loc 1 63 5 is_stmt 1 view .LVU52
 177              		.loc 1 63 17 is_stmt 0 view .LVU53
 178 00b0 1162     		str	r1, [r2, #32]
  64:Src/motor.c   **** 		
  65:Src/motor.c   **** 		RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
 179              		.loc 1 65 3 is_stmt 1 view .LVU54
 180              		.loc 1 65 6 is_stmt 0 view .LVU55
 181 00b2 DC69     		ldr	r4, [r3, #28]
 182              		.loc 1 65 16 view .LVU56
 183 00b4 0120     		movs	r0, #1
 184 00b6 0443     		orrs	r4, r0
 185 00b8 DC61     		str	r4, [r3, #28]
  66:Src/motor.c   ****     TIM2->CR1 = 0;                         // Clear control registers
 186              		.loc 1 66 5 is_stmt 1 view .LVU57
 187              		.loc 1 66 15 is_stmt 0 view .LVU58
 188 00ba 8023     		movs	r3, #128
 189 00bc DB05     		lsls	r3, r3, #23
 190 00be 1960     		str	r1, [r3]
  67:Src/motor.c   ****     TIM2->CCMR1 = 0;                       // (prevents having to manually clear bits)
 191              		.loc 1 67 5 is_stmt 1 view .LVU59
 192              		.loc 1 67 17 is_stmt 0 view .LVU60
 193 00c0 9961     		str	r1, [r3, #24]
  68:Src/motor.c   ****     TIM2->CCER = 0;
 194              		.loc 1 68 5 is_stmt 1 view .LVU61
 195              		.loc 1 68 16 is_stmt 0 view .LVU62
 196 00c2 1962     		str	r1, [r3, #32]
  69:Src/motor.c   **** 
  70:Src/motor.c   ****     // Set output-compare CH1 to PWM1 mode and enable CCR1 preload buffer
  71:Src/motor.c   ****     TIM14->CCMR1 |= (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE);
 197              		.loc 1 71 5 is_stmt 1 view .LVU63
 198              		.loc 1 71 10 is_stmt 0 view .LVU64
 199 00c4 9469     		ldr	r4, [r2, #24]
 200              		.loc 1 71 18 view .LVU65
 201 00c6 6825     		movs	r5, #104
 202 00c8 2C43     		orrs	r4, r5
 203 00ca 9461     		str	r4, [r2, #24]
  72:Src/motor.c   ****     TIM14->CCER |= TIM_CCER_CC1E;           // Enable capture-compare channel 1
 204              		.loc 1 72 5 is_stmt 1 view .LVU66
 205              		.loc 1 72 10 is_stmt 0 view .LVU67
 206 00cc 146A     		ldr	r4, [r2, #32]
 207              		.loc 1 72 17 view .LVU68
 208 00ce 0443     		orrs	r4, r0
 209 00d0 1462     		str	r4, [r2, #32]
  73:Src/motor.c   ****     TIM14->PSC = 1;                         // Run timer on 24Mhz
 210              		.loc 1 73 5 is_stmt 1 view .LVU69
 211              		.loc 1 73 16 is_stmt 0 view .LVU70
 212 00d2 9062     		str	r0, [r2, #40]
  74:Src/motor.c   ****     TIM14->ARR = 1200;                      // PWM at 20kHz
ARM GAS  /tmp/cc8ure6P.s 			page 6


 213              		.loc 1 74 5 is_stmt 1 view .LVU71
 214              		.loc 1 74 16 is_stmt 0 view .LVU72
 215 00d4 9625     		movs	r5, #150
 216 00d6 ED00     		lsls	r5, r5, #3
 217 00d8 D562     		str	r5, [r2, #44]
  75:Src/motor.c   ****     TIM14->CCR1 = 0;                        // Start PWM at 0% duty cycle
 218              		.loc 1 75 5 is_stmt 1 view .LVU73
 219              		.loc 1 75 17 is_stmt 0 view .LVU74
 220 00da 5163     		str	r1, [r2, #52]
  76:Src/motor.c   ****     
  77:Src/motor.c   ****     TIM14->CR1 |= TIM_CR1_CEN;              // Enable timer
 221              		.loc 1 77 5 is_stmt 1 view .LVU75
 222              		.loc 1 77 10 is_stmt 0 view .LVU76
 223 00dc 1468     		ldr	r4, [r2]
 224              		.loc 1 77 16 view .LVU77
 225 00de 0443     		orrs	r4, r0
 226 00e0 1460     		str	r4, [r2]
  78:Src/motor.c   **** 		
  79:Src/motor.c   **** 		TIM2->CCMR1 |= (TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2PE);
 227              		.loc 1 79 3 is_stmt 1 view .LVU78
 228              		.loc 1 79 7 is_stmt 0 view .LVU79
 229 00e2 9C69     		ldr	r4, [r3, #24]
 230              		.loc 1 79 15 view .LVU80
 231 00e4 D022     		movs	r2, #208
 232 00e6 D201     		lsls	r2, r2, #7
 233 00e8 2243     		orrs	r2, r4
 234 00ea 9A61     		str	r2, [r3, #24]
  80:Src/motor.c   ****     TIM2->CCER |= TIM_CCER_CC2E;           // Enable capture-compare channel 2
 235              		.loc 1 80 5 is_stmt 1 view .LVU81
 236              		.loc 1 80 9 is_stmt 0 view .LVU82
 237 00ec 1A6A     		ldr	r2, [r3, #32]
 238              		.loc 1 80 16 view .LVU83
 239 00ee 1024     		movs	r4, #16
 240 00f0 2243     		orrs	r2, r4
 241 00f2 1A62     		str	r2, [r3, #32]
  81:Src/motor.c   ****     TIM2->PSC = 1;                         // Run timer on 24Mhz
 242              		.loc 1 81 5 is_stmt 1 view .LVU84
 243              		.loc 1 81 15 is_stmt 0 view .LVU85
 244 00f4 9862     		str	r0, [r3, #40]
  82:Src/motor.c   ****     TIM2->ARR = 1200;                      // PWM at 20kHz
 245              		.loc 1 82 5 is_stmt 1 view .LVU86
 246              		.loc 1 82 15 is_stmt 0 view .LVU87
 247 00f6 DD62     		str	r5, [r3, #44]
  83:Src/motor.c   ****     TIM2->CCR2 = 0;                        // Start PWM at 0% duty cycle
 248              		.loc 1 83 5 is_stmt 1 view .LVU88
 249              		.loc 1 83 16 is_stmt 0 view .LVU89
 250 00f8 9963     		str	r1, [r3, #56]
  84:Src/motor.c   ****     
  85:Src/motor.c   ****     TIM2->CR1 |= TIM_CR1_CEN;              // Enable timer
 251              		.loc 1 85 5 is_stmt 1 view .LVU90
 252              		.loc 1 85 9 is_stmt 0 view .LVU91
 253 00fa 1A68     		ldr	r2, [r3]
 254              		.loc 1 85 15 view .LVU92
 255 00fc 0243     		orrs	r2, r0
 256 00fe 1A60     		str	r2, [r3]
  86:Src/motor.c   **** }
 257              		.loc 1 86 1 view .LVU93
ARM GAS  /tmp/cc8ure6P.s 			page 7


 258              		@ sp needed
 259 0100 70BD     		pop	{r4, r5, r6, pc}
 260              	.L3:
 261 0102 C046     		.align	2
 262              	.L2:
 263 0104 FFFEFFFF 		.word	-257
 264 0108 00040048 		.word	1207960576
 265 010c FFFFF0FF 		.word	-983041
 266 0110 FF0FFFFF 		.word	-61441
 267 0114 FFF3FCFF 		.word	-199681
 268 0118 CFFFCFFF 		.word	-3145777
 269 011c 10001000 		.word	1048592
 270 0120 00000000 		.word	motor_left_pins
 271 0124 00000000 		.word	motor_right_pins
 272 0128 00100240 		.word	1073876992
 273 012c 00200040 		.word	1073750016
 274              		.cfi_endproc
 275              	.LFE44:
 277              		.global	__aeabi_uidiv
 278              		.section	.text.pwm_setDutyCycleL,"ax",%progbits
 279              		.align	1
 280              		.global	pwm_setDutyCycleL
 281              		.syntax unified
 282              		.code	16
 283              		.thumb_func
 285              	pwm_setDutyCycleL:
 286              	.LVL4:
 287              	.LFB45:
  87:Src/motor.c   **** 
  88:Src/motor.c   **** // Set the duty cycle of the PWM Left, accepts (0-100)
  89:Src/motor.c   **** void pwm_setDutyCycleL(uint8_t duty) {
 288              		.loc 1 89 38 is_stmt 1 view -0
 289              		.cfi_startproc
 290              		@ args = 0, pretend = 0, frame = 0
 291              		@ frame_needed = 0, uses_anonymous_args = 0
 292              		.loc 1 89 38 is_stmt 0 view .LVU95
 293 0000 10B5     		push	{r4, lr}
 294              	.LCFI1:
 295              		.cfi_def_cfa_offset 8
 296              		.cfi_offset 4, -8
 297              		.cfi_offset 14, -4
  90:Src/motor.c   ****     if(duty <= 100) {
 298              		.loc 1 90 5 is_stmt 1 view .LVU96
 299              		.loc 1 90 7 is_stmt 0 view .LVU97
 300 0002 6428     		cmp	r0, #100
 301 0004 06D8     		bhi	.L4
  91:Src/motor.c   ****         TIM14->CCR1 = ((uint32_t)duty*TIM14->ARR)/100;  // Use linear transform to produce CCR1 val
 302              		.loc 1 91 9 is_stmt 1 view .LVU98
 303              		.loc 1 91 44 is_stmt 0 view .LVU99
 304 0006 044C     		ldr	r4, .L6
 305 0008 E36A     		ldr	r3, [r4, #44]
 306              		.loc 1 91 38 view .LVU100
 307 000a 5843     		muls	r0, r3
 308              	.LVL5:
 309              		.loc 1 91 50 view .LVU101
 310 000c 6421     		movs	r1, #100
 311 000e FFF7FEFF 		bl	__aeabi_uidiv
ARM GAS  /tmp/cc8ure6P.s 			page 8


 312              	.LVL6:
 313              		.loc 1 91 21 view .LVU102
 314 0012 6063     		str	r0, [r4, #52]
 315              	.L4:
  92:Src/motor.c   ****         // (CCR1 == "pulse" parameter in PWM struct used by peripheral library)
  93:Src/motor.c   ****     }
  94:Src/motor.c   **** }
 316              		.loc 1 94 1 view .LVU103
 317              		@ sp needed
 318 0014 10BD     		pop	{r4, pc}
 319              	.L7:
 320 0016 C046     		.align	2
 321              	.L6:
 322 0018 00200040 		.word	1073750016
 323              		.cfi_endproc
 324              	.LFE45:
 326              		.section	.text.pwm_setDutyCycleR,"ax",%progbits
 327              		.align	1
 328              		.global	pwm_setDutyCycleR
 329              		.syntax unified
 330              		.code	16
 331              		.thumb_func
 333              	pwm_setDutyCycleR:
 334              	.LVL7:
 335              	.LFB46:
  95:Src/motor.c   **** 
  96:Src/motor.c   **** // Set the duty cycle of the PWM Right, accepts (0-100)
  97:Src/motor.c   **** void pwm_setDutyCycleR(uint8_t duty) {
 336              		.loc 1 97 38 is_stmt 1 view -0
 337              		.cfi_startproc
 338              		@ args = 0, pretend = 0, frame = 0
 339              		@ frame_needed = 0, uses_anonymous_args = 0
 340              		.loc 1 97 38 is_stmt 0 view .LVU105
 341 0000 10B5     		push	{r4, lr}
 342              	.LCFI2:
 343              		.cfi_def_cfa_offset 8
 344              		.cfi_offset 4, -8
 345              		.cfi_offset 14, -4
  98:Src/motor.c   ****     if(duty <= 100) {
 346              		.loc 1 98 5 is_stmt 1 view .LVU106
 347              		.loc 1 98 7 is_stmt 0 view .LVU107
 348 0002 6428     		cmp	r0, #100
 349 0004 07D8     		bhi	.L8
  99:Src/motor.c   ****         TIM2->CCR2 = ((uint32_t)duty*TIM2->ARR)/100;  // Use linear transform to produce CCR1 value
 350              		.loc 1 99 9 is_stmt 1 view .LVU108
 351              		.loc 1 99 42 is_stmt 0 view .LVU109
 352 0006 8024     		movs	r4, #128
 353 0008 E405     		lsls	r4, r4, #23
 354 000a E36A     		ldr	r3, [r4, #44]
 355              		.loc 1 99 37 view .LVU110
 356 000c 5843     		muls	r0, r3
 357              	.LVL8:
 358              		.loc 1 99 48 view .LVU111
 359 000e 6421     		movs	r1, #100
 360 0010 FFF7FEFF 		bl	__aeabi_uidiv
 361              	.LVL9:
 362              		.loc 1 99 20 view .LVU112
ARM GAS  /tmp/cc8ure6P.s 			page 9


 363 0014 A063     		str	r0, [r4, #56]
 364              	.L8:
 100:Src/motor.c   ****         // (CCR2 == "pulse" parameter in PWM struct used by peripheral library)
 101:Src/motor.c   ****     }
 102:Src/motor.c   **** }
 365              		.loc 1 102 1 view .LVU113
 366              		@ sp needed
 367 0016 10BD     		pop	{r4, pc}
 368              		.cfi_endproc
 369              	.LFE46:
 371              		.section	.text.set_Motor_Direction,"ax",%progbits
 372              		.align	1
 373              		.global	set_Motor_Direction
 374              		.syntax unified
 375              		.code	16
 376              		.thumb_func
 378              	set_Motor_Direction:
 379              	.LVL10:
 380              	.LFB47:
 103:Src/motor.c   **** 
 104:Src/motor.c   **** /*
 105:Src/motor.c   ****  * This sets an individual motor's direction.
 106:Src/motor.c   ****  * Note: use MoveMotors to change multiple motor values, eg to turn.
 107:Src/motor.c   ****  */
 108:Src/motor.c   **** void set_Motor_Direction(Direction dir, motor_pins_t* pins){
 381              		.loc 1 108 60 is_stmt 1 view -0
 382              		.cfi_startproc
 383              		@ args = 0, pretend = 0, frame = 0
 384              		@ frame_needed = 0, uses_anonymous_args = 0
 385              		.loc 1 108 60 is_stmt 0 view .LVU115
 386 0000 10B5     		push	{r4, lr}
 387              	.LCFI3:
 388              		.cfi_def_cfa_offset 8
 389              		.cfi_offset 4, -8
 390              		.cfi_offset 14, -4
 391 0002 0C00     		movs	r4, r1
 109:Src/motor.c   **** 	switch(dir){
 392              		.loc 1 109 2 is_stmt 1 view .LVU116
 393 0004 0028     		cmp	r0, #0
 394 0006 08D0     		beq	.L11
 395 0008 0328     		cmp	r0, #3
 396 000a 17D0     		beq	.L12
 110:Src/motor.c   **** 		case FORWARD:
 111:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_SET);
 112:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 113:Src/motor.c   **** 			pwm_setDutyCycleL(100);
 114:Src/motor.c   **** 			pwm_setDutyCycleR(100);
 115:Src/motor.c   **** 			break;
 116:Src/motor.c   **** 		case BACKWARD:
 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_SET);
 118:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 119:Src/motor.c   **** 			pwm_setDutyCycleR(100);
 120:Src/motor.c   **** 			pwm_setDutyCycleL(100);
 121:Src/motor.c   **** 			break;
 122:Src/motor.c   **** 		default:
 123:Src/motor.c   **** 			pwm_setDutyCycleL(0);
 397              		.loc 1 123 4 view .LVU117
ARM GAS  /tmp/cc8ure6P.s 			page 10


 398 000c 0020     		movs	r0, #0
 399              	.LVL11:
 400              		.loc 1 123 4 is_stmt 0 view .LVU118
 401 000e FFF7FEFF 		bl	pwm_setDutyCycleL
 402              	.LVL12:
 124:Src/motor.c   **** 			pwm_setDutyCycleR(0);
 403              		.loc 1 124 4 is_stmt 1 view .LVU119
 404 0012 0020     		movs	r0, #0
 405 0014 FFF7FEFF 		bl	pwm_setDutyCycleR
 406              	.LVL13:
 125:Src/motor.c   **** 			;
 407              		.loc 1 125 4 view .LVU120
 126:Src/motor.c   **** 	}
 127:Src/motor.c   **** }
 408              		.loc 1 127 1 is_stmt 0 view .LVU121
 409 0018 0FE0     		b	.L10
 410              	.LVL14:
 411              	.L11:
 111:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 412              		.loc 1 111 4 is_stmt 1 view .LVU122
 413 001a 898B     		ldrh	r1, [r1, #28]
 414              	.LVL15:
 111:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 415              		.loc 1 111 4 is_stmt 0 view .LVU123
 416 001c A069     		ldr	r0, [r4, #24]
 417              	.LVL16:
 111:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 418              		.loc 1 111 4 view .LVU124
 419 001e 0122     		movs	r2, #1
 420 0020 FFF7FEFF 		bl	HAL_GPIO_WritePin
 421              	.LVL17:
 112:Src/motor.c   **** 			pwm_setDutyCycleL(100);
 422              		.loc 1 112 4 is_stmt 1 view .LVU125
 423 0024 A18E     		ldrh	r1, [r4, #52]
 424 0026 206B     		ldr	r0, [r4, #48]
 425 0028 0022     		movs	r2, #0
 426 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
 427              	.LVL18:
 113:Src/motor.c   **** 			pwm_setDutyCycleR(100);
 428              		.loc 1 113 4 view .LVU126
 429 002e 6420     		movs	r0, #100
 430 0030 FFF7FEFF 		bl	pwm_setDutyCycleL
 431              	.LVL19:
 114:Src/motor.c   **** 			break;
 432              		.loc 1 114 4 view .LVU127
 433 0034 6420     		movs	r0, #100
 434 0036 FFF7FEFF 		bl	pwm_setDutyCycleR
 435              	.LVL20:
 115:Src/motor.c   **** 		case BACKWARD:
 436              		.loc 1 115 4 view .LVU128
 437              	.L10:
 438              		.loc 1 127 1 is_stmt 0 view .LVU129
 439              		@ sp needed
 440              	.LVL21:
 441              		.loc 1 127 1 view .LVU130
 442 003a 10BD     		pop	{r4, pc}
 443              	.LVL22:
ARM GAS  /tmp/cc8ure6P.s 			page 11


 444              	.L12:
 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 445              		.loc 1 117 4 is_stmt 1 view .LVU131
 446 003c 898B     		ldrh	r1, [r1, #28]
 447              	.LVL23:
 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 448              		.loc 1 117 4 is_stmt 0 view .LVU132
 449 003e A069     		ldr	r0, [r4, #24]
 450              	.LVL24:
 117:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 451              		.loc 1 117 4 view .LVU133
 452 0040 0122     		movs	r2, #1
 453 0042 FFF7FEFF 		bl	HAL_GPIO_WritePin
 454              	.LVL25:
 118:Src/motor.c   **** 			pwm_setDutyCycleR(100);
 455              		.loc 1 118 4 is_stmt 1 view .LVU134
 456 0046 A18E     		ldrh	r1, [r4, #52]
 457 0048 206B     		ldr	r0, [r4, #48]
 458 004a 0022     		movs	r2, #0
 459 004c FFF7FEFF 		bl	HAL_GPIO_WritePin
 460              	.LVL26:
 119:Src/motor.c   **** 			pwm_setDutyCycleL(100);
 461              		.loc 1 119 4 view .LVU135
 462 0050 6420     		movs	r0, #100
 463 0052 FFF7FEFF 		bl	pwm_setDutyCycleR
 464              	.LVL27:
 120:Src/motor.c   **** 			break;
 465              		.loc 1 120 4 view .LVU136
 466 0056 6420     		movs	r0, #100
 467 0058 FFF7FEFF 		bl	pwm_setDutyCycleL
 468              	.LVL28:
 121:Src/motor.c   **** 		default:
 469              		.loc 1 121 4 view .LVU137
 470 005c EDE7     		b	.L10
 471              		.cfi_endproc
 472              	.LFE47:
 474              		.section	.text.set_Forward,"ax",%progbits
 475              		.align	1
 476              		.global	set_Forward
 477              		.syntax unified
 478              		.code	16
 479              		.thumb_func
 481              	set_Forward:
 482              	.LFB48:
 128:Src/motor.c   **** 
 129:Src/motor.c   **** void set_Forward(){
 483              		.loc 1 129 19 view -0
 484              		.cfi_startproc
 485              		@ args = 0, pretend = 0, frame = 0
 486              		@ frame_needed = 0, uses_anonymous_args = 0
 487 0000 10B5     		push	{r4, lr}
 488              	.LCFI4:
 489              		.cfi_def_cfa_offset 8
 490              		.cfi_offset 4, -8
 491              		.cfi_offset 14, -4
 130:Src/motor.c   **** 	//left go forward
 131:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
ARM GAS  /tmp/cc8ure6P.s 			page 12


 492              		.loc 1 131 2 view .LVU139
 493 0002 0449     		ldr	r1, .L17
 494 0004 0020     		movs	r0, #0
 495 0006 FFF7FEFF 		bl	set_Motor_Direction
 496              	.LVL29:
 132:Src/motor.c   **** 
 133:Src/motor.c   **** 	//right go forward
 134:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 497              		.loc 1 134 2 view .LVU140
 498 000a 0349     		ldr	r1, .L17+4
 499 000c 0020     		movs	r0, #0
 500 000e FFF7FEFF 		bl	set_Motor_Direction
 501              	.LVL30:
 135:Src/motor.c   **** 
 136:Src/motor.c   **** 	/* the old way
 137:Src/motor.c   **** 		GPIOA->ODR |= (1 << 5);
 138:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 8);
 139:Src/motor.c   **** 		GPIOB->ODR |= (1 << 10);
 140:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 2);
 141:Src/motor.c   **** 	*/
 142:Src/motor.c   **** }
 502              		.loc 1 142 1 is_stmt 0 view .LVU141
 503              		@ sp needed
 504 0012 10BD     		pop	{r4, pc}
 505              	.L18:
 506              		.align	2
 507              	.L17:
 508 0014 00000000 		.word	motor_left_pins
 509 0018 00000000 		.word	motor_right_pins
 510              		.cfi_endproc
 511              	.LFE48:
 513              		.section	.text.set_Backward,"ax",%progbits
 514              		.align	1
 515              		.global	set_Backward
 516              		.syntax unified
 517              		.code	16
 518              		.thumb_func
 520              	set_Backward:
 521              	.LFB49:
 143:Src/motor.c   **** 
 144:Src/motor.c   **** void set_Backward(){
 522              		.loc 1 144 20 is_stmt 1 view -0
 523              		.cfi_startproc
 524              		@ args = 0, pretend = 0, frame = 0
 525              		@ frame_needed = 0, uses_anonymous_args = 0
 526 0000 10B5     		push	{r4, lr}
 527              	.LCFI5:
 528              		.cfi_def_cfa_offset 8
 529              		.cfi_offset 4, -8
 530              		.cfi_offset 14, -4
 145:Src/motor.c   **** 	//left go backward
 146:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 531              		.loc 1 146 2 view .LVU143
 532 0002 0449     		ldr	r1, .L20
 533 0004 0320     		movs	r0, #3
 534 0006 FFF7FEFF 		bl	set_Motor_Direction
 535              	.LVL31:
ARM GAS  /tmp/cc8ure6P.s 			page 13


 147:Src/motor.c   **** 
 148:Src/motor.c   **** 	//right go backward
 149:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 536              		.loc 1 149 2 view .LVU144
 537 000a 0349     		ldr	r1, .L20+4
 538 000c 0320     		movs	r0, #3
 539 000e FFF7FEFF 		bl	set_Motor_Direction
 540              	.LVL32:
 150:Src/motor.c   **** 
 151:Src/motor.c   **** 	/* the old way
 152:Src/motor.c   **** 		GPIOA->ODR |= (1 << 8);
 153:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 5);
 154:Src/motor.c   **** 		GPIOB->ODR |= (1 << 2);
 155:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 10);
 156:Src/motor.c   **** 	*/
 157:Src/motor.c   **** }
 541              		.loc 1 157 1 is_stmt 0 view .LVU145
 542              		@ sp needed
 543 0012 10BD     		pop	{r4, pc}
 544              	.L21:
 545              		.align	2
 546              	.L20:
 547 0014 00000000 		.word	motor_left_pins
 548 0018 00000000 		.word	motor_right_pins
 549              		.cfi_endproc
 550              	.LFE49:
 552              		.section	.text.set_Right,"ax",%progbits
 553              		.align	1
 554              		.global	set_Right
 555              		.syntax unified
 556              		.code	16
 557              		.thumb_func
 559              	set_Right:
 560              	.LFB50:
 158:Src/motor.c   **** 
 159:Src/motor.c   **** void set_Right(){
 561              		.loc 1 159 17 is_stmt 1 view -0
 562              		.cfi_startproc
 563              		@ args = 0, pretend = 0, frame = 0
 564              		@ frame_needed = 0, uses_anonymous_args = 0
 565 0000 10B5     		push	{r4, lr}
 566              	.LCFI6:
 567              		.cfi_def_cfa_offset 8
 568              		.cfi_offset 4, -8
 569              		.cfi_offset 14, -4
 160:Src/motor.c   **** 	//left go forward
 161:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
 570              		.loc 1 161 2 view .LVU147
 571 0002 0449     		ldr	r1, .L23
 572 0004 0020     		movs	r0, #0
 573 0006 FFF7FEFF 		bl	set_Motor_Direction
 574              	.LVL33:
 162:Src/motor.c   **** 
 163:Src/motor.c   **** 	//right go backward
 164:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 575              		.loc 1 164 2 view .LVU148
 576 000a 0349     		ldr	r1, .L23+4
ARM GAS  /tmp/cc8ure6P.s 			page 14


 577 000c 0320     		movs	r0, #3
 578 000e FFF7FEFF 		bl	set_Motor_Direction
 579              	.LVL34:
 165:Src/motor.c   **** 
 166:Src/motor.c   **** 	/* old way
 167:Src/motor.c   **** 		GPIOA->ODR |= (1 << 5);
 168:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 8);
 169:Src/motor.c   **** 		GPIOB->ODR |= (1 << 2);
 170:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 10);
 171:Src/motor.c   **** 	*/
 172:Src/motor.c   **** }
 580              		.loc 1 172 1 is_stmt 0 view .LVU149
 581              		@ sp needed
 582 0012 10BD     		pop	{r4, pc}
 583              	.L24:
 584              		.align	2
 585              	.L23:
 586 0014 00000000 		.word	motor_left_pins
 587 0018 00000000 		.word	motor_right_pins
 588              		.cfi_endproc
 589              	.LFE50:
 591              		.section	.text.set_Left,"ax",%progbits
 592              		.align	1
 593              		.global	set_Left
 594              		.syntax unified
 595              		.code	16
 596              		.thumb_func
 598              	set_Left:
 599              	.LFB51:
 173:Src/motor.c   **** 
 174:Src/motor.c   **** void set_Left(){
 600              		.loc 1 174 16 is_stmt 1 view -0
 601              		.cfi_startproc
 602              		@ args = 0, pretend = 0, frame = 0
 603              		@ frame_needed = 0, uses_anonymous_args = 0
 604 0000 10B5     		push	{r4, lr}
 605              	.LCFI7:
 606              		.cfi_def_cfa_offset 8
 607              		.cfi_offset 4, -8
 608              		.cfi_offset 14, -4
 175:Src/motor.c   **** 	//left go backward
 176:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 609              		.loc 1 176 2 view .LVU151
 610 0002 0449     		ldr	r1, .L26
 611 0004 0320     		movs	r0, #3
 612 0006 FFF7FEFF 		bl	set_Motor_Direction
 613              	.LVL35:
 177:Src/motor.c   **** 	
 178:Src/motor.c   **** 	//right go forward
 179:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 614              		.loc 1 179 2 view .LVU152
 615 000a 0349     		ldr	r1, .L26+4
 616 000c 0020     		movs	r0, #0
 617 000e FFF7FEFF 		bl	set_Motor_Direction
 618              	.LVL36:
 180:Src/motor.c   **** 	
 181:Src/motor.c   **** 	/*
ARM GAS  /tmp/cc8ure6P.s 			page 15


 182:Src/motor.c   **** 		GPIOA->ODR |= (1 << 8);
 183:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 5);
 184:Src/motor.c   **** 		GPIOB->ODR |= (1 << 10);
 185:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 2);
 186:Src/motor.c   **** 	*/
 187:Src/motor.c   **** }
 619              		.loc 1 187 1 is_stmt 0 view .LVU153
 620              		@ sp needed
 621 0012 10BD     		pop	{r4, pc}
 622              	.L27:
 623              		.align	2
 624              	.L26:
 625 0014 00000000 		.word	motor_left_pins
 626 0018 00000000 		.word	motor_right_pins
 627              		.cfi_endproc
 628              	.LFE51:
 630              		.section	.text.set_Off,"ax",%progbits
 631              		.align	1
 632              		.global	set_Off
 633              		.syntax unified
 634              		.code	16
 635              		.thumb_func
 637              	set_Off:
 638              	.LFB52:
 188:Src/motor.c   **** 
 189:Src/motor.c   **** void set_Off(){
 639              		.loc 1 189 15 is_stmt 1 view -0
 640              		.cfi_startproc
 641              		@ args = 0, pretend = 0, frame = 0
 642              		@ frame_needed = 0, uses_anonymous_args = 0
 643 0000 10B5     		push	{r4, lr}
 644              	.LCFI8:
 645              		.cfi_def_cfa_offset 8
 646              		.cfi_offset 4, -8
 647              		.cfi_offset 14, -4
 190:Src/motor.c   **** 	set_Motor_Direction(OFF, &motor_left_pins);
 648              		.loc 1 190 2 view .LVU155
 649 0002 0449     		ldr	r1, .L29
 650 0004 0420     		movs	r0, #4
 651 0006 FFF7FEFF 		bl	set_Motor_Direction
 652              	.LVL37:
 191:Src/motor.c   **** 	set_Motor_Direction(OFF, &motor_right_pins);
 653              		.loc 1 191 2 view .LVU156
 654 000a 0349     		ldr	r1, .L29+4
 655 000c 0420     		movs	r0, #4
 656 000e FFF7FEFF 		bl	set_Motor_Direction
 657              	.LVL38:
 192:Src/motor.c   **** }
 658              		.loc 1 192 1 is_stmt 0 view .LVU157
 659              		@ sp needed
 660 0012 10BD     		pop	{r4, pc}
 661              	.L30:
 662              		.align	2
 663              	.L29:
 664 0014 00000000 		.word	motor_left_pins
 665 0018 00000000 		.word	motor_right_pins
 666              		.cfi_endproc
ARM GAS  /tmp/cc8ure6P.s 			page 16


 667              	.LFE52:
 669              		.section	.rodata.MoveMotors.str1.4,"aMS",%progbits,1
 670              		.align	2
 671              	.LC12:
 672 0000 4D6F7665 		.ascii	"MoveMotors executed!\012\000"
 672      4D6F746F 
 672      72732065 
 672      78656375 
 672      74656421 
 673 0016 0000     		.align	2
 674              	.LC14:
 675 0018 496E7661 		.ascii	"Invalid command to MoveMotors!\012\000"
 675      6C696420 
 675      636F6D6D 
 675      616E6420 
 675      746F204D 
 676              		.section	.text.MoveMotors,"ax",%progbits
 677              		.align	1
 678              		.global	MoveMotors
 679              		.syntax unified
 680              		.code	16
 681              		.thumb_func
 683              	MoveMotors:
 684              	.LVL39:
 685              	.LFB53:
 193:Src/motor.c   **** 
 194:Src/motor.c   **** uint8_t* MoveMotors(MotorCommand* cmd){
 686              		.loc 1 194 39 is_stmt 1 view -0
 687              		.cfi_startproc
 688              		@ args = 0, pretend = 0, frame = 0
 689              		@ frame_needed = 0, uses_anonymous_args = 0
 690              		.loc 1 194 39 is_stmt 0 view .LVU159
 691 0000 10B5     		push	{r4, lr}
 692              	.LCFI9:
 693              		.cfi_def_cfa_offset 8
 694              		.cfi_offset 4, -8
 695              		.cfi_offset 14, -4
 696 0002 0400     		movs	r4, r0
 195:Src/motor.c   **** 	set_Off();
 697              		.loc 1 195 2 is_stmt 1 view .LVU160
 698 0004 FFF7FEFF 		bl	set_Off
 699              	.LVL40:
 196:Src/motor.c   **** 	set_On();
 700              		.loc 1 196 2 view .LVU161
 701 0008 FFF7FEFF 		bl	set_On
 702              	.LVL41:
 197:Src/motor.c   **** 	uint8_t* err = "MoveMotors executed!\n";
 703              		.loc 1 197 2 view .LVU162
 198:Src/motor.c   **** 	switch(cmd->dir){
 704              		.loc 1 198 2 view .LVU163
 705              		.loc 1 198 12 is_stmt 0 view .LVU164
 706 000c 2378     		ldrb	r3, [r4]
 707              		.loc 1 198 2 view .LVU165
 708 000e 012B     		cmp	r3, #1
 709 0010 09D0     		beq	.L32
 710 0012 022B     		cmp	r3, #2
 711 0014 0BD0     		beq	.L33
ARM GAS  /tmp/cc8ure6P.s 			page 17


 712 0016 002B     		cmp	r3, #0
 713 0018 01D0     		beq	.L36
 714 001a 0748     		ldr	r0, .L37
 715              	.LVL42:
 199:Src/motor.c   **** 		case FORWARD:
 200:Src/motor.c   **** 			set_Forward();
 201:Src/motor.c   **** 			break;
 202:Src/motor.c   **** 		case LEFT:
 203:Src/motor.c   **** 			set_Left();
 204:Src/motor.c   **** 			break;
 205:Src/motor.c   **** 		case RIGHT:
 206:Src/motor.c   **** 			set_Right();
 207:Src/motor.c   **** 			break;
 208:Src/motor.c   **** 		default:
 209:Src/motor.c   **** 			err = "Invalid command to MoveMotors!\n";
 210:Src/motor.c   **** 	}
 211:Src/motor.c   **** 	return err;
 716              		.loc 1 211 2 is_stmt 1 view .LVU166
 717              	.L31:
 212:Src/motor.c   **** }
 718              		.loc 1 212 1 is_stmt 0 view .LVU167
 719              		@ sp needed
 720              	.LVL43:
 721              		.loc 1 212 1 view .LVU168
 722 001c 10BD     		pop	{r4, pc}
 723              	.LVL44:
 724              	.L36:
 200:Src/motor.c   **** 			break;
 725              		.loc 1 200 4 is_stmt 1 view .LVU169
 726 001e FFF7FEFF 		bl	set_Forward
 727              	.LVL45:
 201:Src/motor.c   **** 		case LEFT:
 728              		.loc 1 201 4 view .LVU170
 197:Src/motor.c   **** 	switch(cmd->dir){
 729              		.loc 1 197 11 is_stmt 0 view .LVU171
 730 0022 0648     		ldr	r0, .L37+4
 201:Src/motor.c   **** 		case LEFT:
 731              		.loc 1 201 4 view .LVU172
 732 0024 FAE7     		b	.L31
 733              	.L32:
 203:Src/motor.c   **** 			break;
 734              		.loc 1 203 4 is_stmt 1 view .LVU173
 735 0026 FFF7FEFF 		bl	set_Left
 736              	.LVL46:
 204:Src/motor.c   **** 		case RIGHT:
 737              		.loc 1 204 4 view .LVU174
 197:Src/motor.c   **** 	switch(cmd->dir){
 738              		.loc 1 197 11 is_stmt 0 view .LVU175
 739 002a 0448     		ldr	r0, .L37+4
 204:Src/motor.c   **** 		case RIGHT:
 740              		.loc 1 204 4 view .LVU176
 741 002c F6E7     		b	.L31
 742              	.L33:
 206:Src/motor.c   **** 			break;
 743              		.loc 1 206 4 is_stmt 1 view .LVU177
 744 002e FFF7FEFF 		bl	set_Right
 745              	.LVL47:
ARM GAS  /tmp/cc8ure6P.s 			page 18


 207:Src/motor.c   **** 		default:
 746              		.loc 1 207 4 view .LVU178
 197:Src/motor.c   **** 	switch(cmd->dir){
 747              		.loc 1 197 11 is_stmt 0 view .LVU179
 748 0032 0248     		ldr	r0, .L37+4
 207:Src/motor.c   **** 		default:
 749              		.loc 1 207 4 view .LVU180
 750 0034 F2E7     		b	.L31
 751              	.L38:
 752 0036 C046     		.align	2
 753              	.L37:
 754 0038 18000000 		.word	.LC14
 755 003c 00000000 		.word	.LC12
 756              		.cfi_endproc
 757              	.LFE53:
 759              		.section	.text.encoder_init,"ax",%progbits
 760              		.align	1
 761              		.global	encoder_init
 762              		.syntax unified
 763              		.code	16
 764              		.thumb_func
 766              	encoder_init:
 767              	.LFB54:
 213:Src/motor.c   **** 
 214:Src/motor.c   **** // Sets up encoder interface to read motor speed
 215:Src/motor.c   **** void encoder_init(void) {
 768              		.loc 1 215 25 is_stmt 1 view -0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 0
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 773              	.LCFI10:
 774              		.cfi_def_cfa_offset 20
 775              		.cfi_offset 4, -20
 776              		.cfi_offset 5, -16
 777              		.cfi_offset 6, -12
 778              		.cfi_offset 7, -8
 779              		.cfi_offset 14, -4
 780 0002 C646     		mov	lr, r8
 781 0004 00B5     		push	{lr}
 782              	.LCFI11:
 783              		.cfi_def_cfa_offset 24
 784              		.cfi_offset 8, -24
 216:Src/motor.c   ****     
 217:Src/motor.c   ****     // Set up encoder input pins (TIMER 3 CH1 and CH2)
 218:Src/motor.c   ****     GPIOB->MODER &= ~(GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0);
 785              		.loc 1 218 5 view .LVU182
 786              		.loc 1 218 10 is_stmt 0 view .LVU183
 787 0006 394B     		ldr	r3, .L40
 788 0008 1A68     		ldr	r2, [r3]
 789              		.loc 1 218 18 view .LVU184
 790 000a 3949     		ldr	r1, .L40+4
 791 000c 0A40     		ands	r2, r1
 792 000e 1A60     		str	r2, [r3]
 219:Src/motor.c   ****     GPIOB->MODER |= (GPIO_MODER_MODER4_1 | GPIO_MODER_MODER5_1);
 793              		.loc 1 219 5 is_stmt 1 view .LVU185
 794              		.loc 1 219 10 is_stmt 0 view .LVU186
ARM GAS  /tmp/cc8ure6P.s 			page 19


 795 0010 1968     		ldr	r1, [r3]
 796              		.loc 1 219 18 view .LVU187
 797 0012 A022     		movs	r2, #160
 798 0014 1201     		lsls	r2, r2, #4
 799 0016 0A43     		orrs	r2, r1
 800 0018 1A60     		str	r2, [r3]
 220:Src/motor.c   ****     GPIOB->AFR[0] |= ( (1 << 16) | (1 << 20) );
 801              		.loc 1 220 5 is_stmt 1 view .LVU188
 802              		.loc 1 220 15 is_stmt 0 view .LVU189
 803 001a 196A     		ldr	r1, [r3, #32]
 804              		.loc 1 220 19 view .LVU190
 805 001c 8822     		movs	r2, #136
 806 001e 5203     		lsls	r2, r2, #13
 807 0020 0A43     		orrs	r2, r1
 808 0022 1A62     		str	r2, [r3, #32]
 221:Src/motor.c   **** 		
 222:Src/motor.c   **** 		// Set up encoder input pins (TIMER 15 CH1 and CH2)
 223:Src/motor.c   **** 		GPIOB->MODER &= ~(GPIO_MODER_MODER14_0 | GPIO_MODER_MODER15_0);
 809              		.loc 1 223 3 is_stmt 1 view .LVU191
 810              		.loc 1 223 8 is_stmt 0 view .LVU192
 811 0024 1A68     		ldr	r2, [r3]
 812              		.loc 1 223 16 view .LVU193
 813 0026 3349     		ldr	r1, .L40+8
 814 0028 0A40     		ands	r2, r1
 815 002a 1A60     		str	r2, [r3]
 224:Src/motor.c   ****     GPIOB->MODER |= (GPIO_MODER_MODER14_1 | GPIO_MODER_MODER15_1);
 816              		.loc 1 224 5 is_stmt 1 view .LVU194
 817              		.loc 1 224 10 is_stmt 0 view .LVU195
 818 002c 1968     		ldr	r1, [r3]
 819              		.loc 1 224 18 view .LVU196
 820 002e A022     		movs	r2, #160
 821 0030 1206     		lsls	r2, r2, #24
 822 0032 0A43     		orrs	r2, r1
 823 0034 1A60     		str	r2, [r3]
 225:Src/motor.c   ****     GPIOB->AFR[1] |= ( (1 << 24) | (1 << 28) );
 824              		.loc 1 225 5 is_stmt 1 view .LVU197
 825              		.loc 1 225 15 is_stmt 0 view .LVU198
 826 0036 596A     		ldr	r1, [r3, #36]
 827              		.loc 1 225 19 view .LVU199
 828 0038 8822     		movs	r2, #136
 829 003a 5205     		lsls	r2, r2, #21
 830 003c 0A43     		orrs	r2, r1
 831 003e 5A62     		str	r2, [r3, #36]
 226:Src/motor.c   **** 
 227:Src/motor.c   ****     // Set up encoder interface (TIM3 encoder input mode)
 228:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
 832              		.loc 1 228 5 is_stmt 1 view .LVU200
 833              		.loc 1 228 8 is_stmt 0 view .LVU201
 834 0040 2D49     		ldr	r1, .L40+12
 835 0042 CB69     		ldr	r3, [r1, #28]
 836              		.loc 1 228 18 view .LVU202
 837 0044 0222     		movs	r2, #2
 838 0046 1343     		orrs	r3, r2
 839 0048 CB61     		str	r3, [r1, #28]
 229:Src/motor.c   ****     TIM3->CCMR1 = 0;
 840              		.loc 1 229 5 is_stmt 1 view .LVU203
 841              		.loc 1 229 17 is_stmt 0 view .LVU204
ARM GAS  /tmp/cc8ure6P.s 			page 20


 842 004a 2C4B     		ldr	r3, .L40+16
 843 004c 0022     		movs	r2, #0
 844 004e 9A61     		str	r2, [r3, #24]
 230:Src/motor.c   ****     TIM3->CCER = 0;
 845              		.loc 1 230 5 is_stmt 1 view .LVU205
 846              		.loc 1 230 16 is_stmt 0 view .LVU206
 847 0050 1A62     		str	r2, [r3, #32]
 231:Src/motor.c   ****     TIM3->SMCR = 0;
 848              		.loc 1 231 5 is_stmt 1 view .LVU207
 849              		.loc 1 231 16 is_stmt 0 view .LVU208
 850 0052 9A60     		str	r2, [r3, #8]
 232:Src/motor.c   ****     TIM3->CR1 = 0;
 851              		.loc 1 232 5 is_stmt 1 view .LVU209
 852              		.loc 1 232 15 is_stmt 0 view .LVU210
 853 0054 1A60     		str	r2, [r3]
 233:Src/motor.c   **** 
 234:Src/motor.c   ****     TIM3->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected 
 854              		.loc 1 234 5 is_stmt 1 view .LVU211
 855              		.loc 1 234 9 is_stmt 0 view .LVU212
 856 0056 9869     		ldr	r0, [r3, #24]
 857              		.loc 1 234 17 view .LVU213
 858 0058 0224     		movs	r4, #2
 859 005a FF34     		adds	r4, r4, #255
 860 005c A046     		mov	r8, r4
 861 005e 2043     		orrs	r0, r4
 862 0060 9861     		str	r0, [r3, #24]
 235:Src/motor.c   ****     TIM3->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and f
 863              		.loc 1 235 5 is_stmt 1 view .LVU214
 864              		.loc 1 235 9 is_stmt 0 view .LVU215
 865 0062 9868     		ldr	r0, [r3, #8]
 866              		.loc 1 235 16 view .LVU216
 867 0064 0327     		movs	r7, #3
 868 0066 3843     		orrs	r0, r7
 869 0068 9860     		str	r0, [r3, #8]
 236:Src/motor.c   ****     TIM3->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest pos
 870              		.loc 1 236 5 is_stmt 1 view .LVU217
 871              		.loc 1 236 15 is_stmt 0 view .LVU218
 872 006a 254E     		ldr	r6, .L40+20
 873 006c DE62     		str	r6, [r3, #44]
 237:Src/motor.c   ****     TIM3->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negati
 874              		.loc 1 237 5 is_stmt 1 view .LVU219
 875              		.loc 1 237 15 is_stmt 0 view .LVU220
 876 006e 254D     		ldr	r5, .L40+24
 877 0070 5D62     		str	r5, [r3, #36]
 238:Src/motor.c   ****     // (Could also cast unsigned register to signed number to get negative numbers if it rotates ba
 239:Src/motor.c   ****     //  just another option, the mid-bias is a bit simpler to understand though.)
 240:Src/motor.c   ****     TIM3->CR1 |= TIM_CR1_CEN;                               // Enable timer
 878              		.loc 1 240 5 is_stmt 1 view .LVU221
 879              		.loc 1 240 9 is_stmt 0 view .LVU222
 880 0072 1868     		ldr	r0, [r3]
 881 0074 8446     		mov	ip, r0
 882              		.loc 1 240 15 view .LVU223
 883 0076 0120     		movs	r0, #1
 884 0078 6446     		mov	r4, ip
 885 007a 0443     		orrs	r4, r0
 886 007c 1C60     		str	r4, [r3]
 241:Src/motor.c   **** 		
ARM GAS  /tmp/cc8ure6P.s 			page 21


 242:Src/motor.c   **** 		RCC->APB2ENR |= RCC_APB2ENR_TIM15EN;
 887              		.loc 1 242 3 is_stmt 1 view .LVU224
 888              		.loc 1 242 6 is_stmt 0 view .LVU225
 889 007e 8B69     		ldr	r3, [r1, #24]
 890 0080 9C46     		mov	ip, r3
 891              		.loc 1 242 16 view .LVU226
 892 0082 8023     		movs	r3, #128
 893 0084 5B02     		lsls	r3, r3, #9
 894 0086 6446     		mov	r4, ip
 895 0088 2343     		orrs	r3, r4
 896 008a 8B61     		str	r3, [r1, #24]
 243:Src/motor.c   ****     TIM15->CCMR1 = 0;
 897              		.loc 1 243 5 is_stmt 1 view .LVU227
 898              		.loc 1 243 18 is_stmt 0 view .LVU228
 899 008c 1E4B     		ldr	r3, .L40+28
 900 008e 9A61     		str	r2, [r3, #24]
 244:Src/motor.c   ****     TIM15->CCER = 0;
 901              		.loc 1 244 5 is_stmt 1 view .LVU229
 902              		.loc 1 244 17 is_stmt 0 view .LVU230
 903 0090 1A62     		str	r2, [r3, #32]
 245:Src/motor.c   ****     TIM15->SMCR = 0;
 904              		.loc 1 245 5 is_stmt 1 view .LVU231
 905              		.loc 1 245 17 is_stmt 0 view .LVU232
 906 0092 9A60     		str	r2, [r3, #8]
 246:Src/motor.c   ****     TIM15->CR1 = 0;
 907              		.loc 1 246 5 is_stmt 1 view .LVU233
 908              		.loc 1 246 16 is_stmt 0 view .LVU234
 909 0094 1A60     		str	r2, [r3]
 247:Src/motor.c   **** 
 248:Src/motor.c   ****     TIM15->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected
 910              		.loc 1 248 5 is_stmt 1 view .LVU235
 911              		.loc 1 248 10 is_stmt 0 view .LVU236
 912 0096 9A69     		ldr	r2, [r3, #24]
 913              		.loc 1 248 18 view .LVU237
 914 0098 4446     		mov	r4, r8
 915 009a 1443     		orrs	r4, r2
 916 009c 9C61     		str	r4, [r3, #24]
 249:Src/motor.c   ****     TIM15->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and 
 917              		.loc 1 249 5 is_stmt 1 view .LVU238
 918              		.loc 1 249 10 is_stmt 0 view .LVU239
 919 009e 9A68     		ldr	r2, [r3, #8]
 920              		.loc 1 249 17 view .LVU240
 921 00a0 3A43     		orrs	r2, r7
 922 00a2 9A60     		str	r2, [r3, #8]
 250:Src/motor.c   ****     TIM15->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest po
 923              		.loc 1 250 5 is_stmt 1 view .LVU241
 924              		.loc 1 250 16 is_stmt 0 view .LVU242
 925 00a4 DE62     		str	r6, [r3, #44]
 251:Src/motor.c   ****     TIM15->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negat
 926              		.loc 1 251 5 is_stmt 1 view .LVU243
 927              		.loc 1 251 16 is_stmt 0 view .LVU244
 928 00a6 5D62     		str	r5, [r3, #36]
 252:Src/motor.c   ****     // (Could also cast unsigned register to signed number to get negative numbers if it rotates ba
 253:Src/motor.c   ****     //  just another option, the mid-bias is a bit simpler to understand though.)
 254:Src/motor.c   ****     TIM15->CR1 |= TIM_CR1_CEN;     
 929              		.loc 1 254 5 is_stmt 1 view .LVU245
 930              		.loc 1 254 10 is_stmt 0 view .LVU246
ARM GAS  /tmp/cc8ure6P.s 			page 22


 931 00a8 1A68     		ldr	r2, [r3]
 932              		.loc 1 254 16 view .LVU247
 933 00aa 0243     		orrs	r2, r0
 934 00ac 1A60     		str	r2, [r3]
 255:Src/motor.c   **** 
 256:Src/motor.c   ****     // Configure a second timer (TIM6) to fire an ISR on update event
 257:Src/motor.c   ****     // Used to periodically check and update speed variable
 258:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
 935              		.loc 1 258 5 is_stmt 1 view .LVU248
 936              		.loc 1 258 8 is_stmt 0 view .LVU249
 937 00ae CB69     		ldr	r3, [r1, #28]
 938              		.loc 1 258 18 view .LVU250
 939 00b0 1022     		movs	r2, #16
 940 00b2 1343     		orrs	r3, r2
 941 00b4 CB61     		str	r3, [r1, #28]
 259:Src/motor.c   ****     
 260:Src/motor.c   ****     // Select PSC and ARR values that give an appropriate interrupt rate
 261:Src/motor.c   ****     TIM6->PSC = 11;
 942              		.loc 1 261 5 is_stmt 1 view .LVU251
 943              		.loc 1 261 15 is_stmt 0 view .LVU252
 944 00b6 154B     		ldr	r3, .L40+32
 945 00b8 053A     		subs	r2, r2, #5
 946 00ba 9A62     		str	r2, [r3, #40]
 262:Src/motor.c   ****     TIM6->ARR = 30000;
 947              		.loc 1 262 5 is_stmt 1 view .LVU253
 948              		.loc 1 262 15 is_stmt 0 view .LVU254
 949 00bc 144A     		ldr	r2, .L40+36
 950 00be DA62     		str	r2, [r3, #44]
 263:Src/motor.c   ****     
 264:Src/motor.c   ****     TIM6->DIER |= TIM_DIER_UIE;             // Enable update event interrupt
 951              		.loc 1 264 5 is_stmt 1 view .LVU255
 952              		.loc 1 264 9 is_stmt 0 view .LVU256
 953 00c0 DA68     		ldr	r2, [r3, #12]
 954              		.loc 1 264 16 view .LVU257
 955 00c2 0243     		orrs	r2, r0
 956 00c4 DA60     		str	r2, [r3, #12]
 265:Src/motor.c   ****     TIM6->CR1 |= TIM_CR1_CEN;               // Enable Timer
 957              		.loc 1 265 5 is_stmt 1 view .LVU258
 958              		.loc 1 265 9 is_stmt 0 view .LVU259
 959 00c6 1A68     		ldr	r2, [r3]
 960              		.loc 1 265 15 view .LVU260
 961 00c8 0243     		orrs	r2, r0
 962 00ca 1A60     		str	r2, [r3]
 266:Src/motor.c   **** 
 267:Src/motor.c   ****     NVIC_EnableIRQ(TIM6_DAC_IRQn);          // Enable interrupt in NVIC
 963              		.loc 1 267 5 is_stmt 1 view .LVU261
 964              	.LVL48:
 965              	.LBB6:
 966              	.LBI6:
 967              		.file 2 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V5.0.5
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     28. May 2018
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /*
ARM GAS  /tmp/cc8ure6P.s 			page 23


   8:Drivers/CMSIS/Include/core_cm0.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/core_cm0.h ****  *
  10:Drivers/CMSIS/Include/core_cm0.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/core_cm0.h ****  *
  12:Drivers/CMSIS/Include/core_cm0.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/core_cm0.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/core_cm0.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/core_cm0.h ****  *
  16:Drivers/CMSIS/Include/core_cm0.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/core_cm0.h ****  *
  18:Drivers/CMSIS/Include/core_cm0.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/core_cm0.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/core_cm0.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/core_cm0.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/core_cm0.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/core_cm0.h ****  */
  24:Drivers/CMSIS/Include/core_cm0.h **** 
  25:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  26:Drivers/CMSIS/Include/core_cm0.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__clang__)
  28:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  29:Drivers/CMSIS/Include/core_cm0.h **** #endif
  30:Drivers/CMSIS/Include/core_cm0.h **** 
  31:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  32:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  35:Drivers/CMSIS/Include/core_cm0.h **** 
  36:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  37:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  38:Drivers/CMSIS/Include/core_cm0.h **** #endif
  39:Drivers/CMSIS/Include/core_cm0.h **** 
  40:Drivers/CMSIS/Include/core_cm0.h **** /**
  41:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  46:Drivers/CMSIS/Include/core_cm0.h **** 
  47:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  52:Drivers/CMSIS/Include/core_cm0.h ****  */
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h **** 
  55:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  56:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  57:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  58:Drivers/CMSIS/Include/core_cm0.h **** /**
  59:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  60:Drivers/CMSIS/Include/core_cm0.h ****   @{
  61:Drivers/CMSIS/Include/core_cm0.h ****  */
  62:Drivers/CMSIS/Include/core_cm0.h **** 
  63:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_version.h"
  64:Drivers/CMSIS/Include/core_cm0.h ****  
ARM GAS  /tmp/cc8ure6P.s 			page 24


  65:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  66:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  69:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:Drivers/CMSIS/Include/core_cm0.h **** 
  71:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
  75:Drivers/CMSIS/Include/core_cm0.h **** */
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
  77:Drivers/CMSIS/Include/core_cm0.h **** 
  78:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
  79:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
  80:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  82:Drivers/CMSIS/Include/core_cm0.h **** 
  83:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
  85:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  87:Drivers/CMSIS/Include/core_cm0.h **** 
  88:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  89:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  92:Drivers/CMSIS/Include/core_cm0.h **** 
  93:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  94:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
  95:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  97:Drivers/CMSIS/Include/core_cm0.h **** 
  98:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TI_ARM__ )
  99:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 100:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 102:Drivers/CMSIS/Include/core_cm0.h **** 
 103:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 104:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 105:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 107:Drivers/CMSIS/Include/core_cm0.h **** 
 108:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 109:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 110:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 112:Drivers/CMSIS/Include/core_cm0.h **** 
 113:Drivers/CMSIS/Include/core_cm0.h **** #endif
 114:Drivers/CMSIS/Include/core_cm0.h **** 
 115:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** 
 118:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 119:Drivers/CMSIS/Include/core_cm0.h **** }
 120:Drivers/CMSIS/Include/core_cm0.h **** #endif
 121:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cc8ure6P.s 			page 25


 122:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 123:Drivers/CMSIS/Include/core_cm0.h **** 
 124:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 127:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 128:Drivers/CMSIS/Include/core_cm0.h **** 
 129:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 130:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 131:Drivers/CMSIS/Include/core_cm0.h **** #endif
 132:Drivers/CMSIS/Include/core_cm0.h **** 
 133:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 134:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 135:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 136:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 137:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 138:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 139:Drivers/CMSIS/Include/core_cm0.h **** 
 140:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 141:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 142:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 143:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 144:Drivers/CMSIS/Include/core_cm0.h **** 
 145:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 146:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 147:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 148:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 149:Drivers/CMSIS/Include/core_cm0.h **** #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 152:Drivers/CMSIS/Include/core_cm0.h **** /**
 153:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 154:Drivers/CMSIS/Include/core_cm0.h **** 
 155:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 156:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 157:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 158:Drivers/CMSIS/Include/core_cm0.h **** */
 159:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 160:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 161:Drivers/CMSIS/Include/core_cm0.h **** #else
 162:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 163:Drivers/CMSIS/Include/core_cm0.h **** #endif
 164:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 165:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 166:Drivers/CMSIS/Include/core_cm0.h **** 
 167:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 168:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 169:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 170:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** 
 175:Drivers/CMSIS/Include/core_cm0.h **** 
 176:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 177:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 178:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
ARM GAS  /tmp/cc8ure6P.s 			page 26


 179:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 180:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 181:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 182:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 183:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 184:Drivers/CMSIS/Include/core_cm0.h **** /**
 185:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 186:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 187:Drivers/CMSIS/Include/core_cm0.h **** */
 188:Drivers/CMSIS/Include/core_cm0.h **** 
 189:Drivers/CMSIS/Include/core_cm0.h **** /**
 190:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 191:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 192:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 193:Drivers/CMSIS/Include/core_cm0.h ****   @{
 194:Drivers/CMSIS/Include/core_cm0.h ****  */
 195:Drivers/CMSIS/Include/core_cm0.h **** 
 196:Drivers/CMSIS/Include/core_cm0.h **** /**
 197:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 198:Drivers/CMSIS/Include/core_cm0.h ****  */
 199:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 200:Drivers/CMSIS/Include/core_cm0.h **** {
 201:Drivers/CMSIS/Include/core_cm0.h ****   struct
 202:Drivers/CMSIS/Include/core_cm0.h ****   {
 203:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 204:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 205:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 206:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 207:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 208:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 209:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 210:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 211:Drivers/CMSIS/Include/core_cm0.h **** 
 212:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 214:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 215:Drivers/CMSIS/Include/core_cm0.h **** 
 216:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 217:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 218:Drivers/CMSIS/Include/core_cm0.h **** 
 219:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 220:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 223:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 224:Drivers/CMSIS/Include/core_cm0.h **** 
 225:Drivers/CMSIS/Include/core_cm0.h **** 
 226:Drivers/CMSIS/Include/core_cm0.h **** /**
 227:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 228:Drivers/CMSIS/Include/core_cm0.h ****  */
 229:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 230:Drivers/CMSIS/Include/core_cm0.h **** {
 231:Drivers/CMSIS/Include/core_cm0.h ****   struct
 232:Drivers/CMSIS/Include/core_cm0.h ****   {
 233:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 234:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 235:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
ARM GAS  /tmp/cc8ure6P.s 			page 27


 236:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 237:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 238:Drivers/CMSIS/Include/core_cm0.h **** 
 239:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 240:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 241:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 242:Drivers/CMSIS/Include/core_cm0.h **** 
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 257:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 258:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 259:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 260:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 261:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 262:Drivers/CMSIS/Include/core_cm0.h **** 
 263:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 264:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 268:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 274:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 275:Drivers/CMSIS/Include/core_cm0.h **** 
 276:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 277:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 278:Drivers/CMSIS/Include/core_cm0.h **** 
 279:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 280:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 281:Drivers/CMSIS/Include/core_cm0.h **** 
 282:Drivers/CMSIS/Include/core_cm0.h **** 
 283:Drivers/CMSIS/Include/core_cm0.h **** /**
 284:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 285:Drivers/CMSIS/Include/core_cm0.h ****  */
 286:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 287:Drivers/CMSIS/Include/core_cm0.h **** {
 288:Drivers/CMSIS/Include/core_cm0.h ****   struct
 289:Drivers/CMSIS/Include/core_cm0.h ****   {
 290:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 291:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 292:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
ARM GAS  /tmp/cc8ure6P.s 			page 28


 293:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 294:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 295:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 296:Drivers/CMSIS/Include/core_cm0.h **** 
 297:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 298:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 299:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 300:Drivers/CMSIS/Include/core_cm0.h **** 
 301:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 302:Drivers/CMSIS/Include/core_cm0.h **** 
 303:Drivers/CMSIS/Include/core_cm0.h **** 
 304:Drivers/CMSIS/Include/core_cm0.h **** /**
 305:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 306:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 307:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 308:Drivers/CMSIS/Include/core_cm0.h ****   @{
 309:Drivers/CMSIS/Include/core_cm0.h ****  */
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /**
 312:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 313:Drivers/CMSIS/Include/core_cm0.h ****  */
 314:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 315:Drivers/CMSIS/Include/core_cm0.h **** {
 316:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 317:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 318:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 319:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 320:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 321:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 322:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 323:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 324:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 325:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 326:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 327:Drivers/CMSIS/Include/core_cm0.h **** 
 328:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 333:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 334:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 335:Drivers/CMSIS/Include/core_cm0.h ****   @{
 336:Drivers/CMSIS/Include/core_cm0.h ****  */
 337:Drivers/CMSIS/Include/core_cm0.h **** 
 338:Drivers/CMSIS/Include/core_cm0.h **** /**
 339:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 340:Drivers/CMSIS/Include/core_cm0.h ****  */
 341:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 342:Drivers/CMSIS/Include/core_cm0.h **** {
 343:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 344:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 345:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 346:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 347:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 348:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 349:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
ARM GAS  /tmp/cc8ure6P.s 			page 29


 350:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 351:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 352:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 353:Drivers/CMSIS/Include/core_cm0.h **** 
 354:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 355:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 356:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 357:Drivers/CMSIS/Include/core_cm0.h **** 
 358:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 359:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 360:Drivers/CMSIS/Include/core_cm0.h **** 
 361:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 362:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 363:Drivers/CMSIS/Include/core_cm0.h **** 
 364:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 365:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 366:Drivers/CMSIS/Include/core_cm0.h **** 
 367:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 368:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 369:Drivers/CMSIS/Include/core_cm0.h **** 
 370:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 371:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 372:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 373:Drivers/CMSIS/Include/core_cm0.h **** 
 374:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 375:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 376:Drivers/CMSIS/Include/core_cm0.h **** 
 377:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 378:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 379:Drivers/CMSIS/Include/core_cm0.h **** 
 380:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 381:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 382:Drivers/CMSIS/Include/core_cm0.h **** 
 383:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 384:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 387:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 388:Drivers/CMSIS/Include/core_cm0.h **** 
 389:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 390:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 391:Drivers/CMSIS/Include/core_cm0.h **** 
 392:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 393:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 394:Drivers/CMSIS/Include/core_cm0.h **** 
 395:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 396:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 397:Drivers/CMSIS/Include/core_cm0.h **** 
 398:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 399:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 400:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** 
 405:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
ARM GAS  /tmp/cc8ure6P.s 			page 30


 407:Drivers/CMSIS/Include/core_cm0.h **** 
 408:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** 
 411:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** 
 414:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** 
 421:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** 
 424:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 434:Drivers/CMSIS/Include/core_cm0.h **** 
 435:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** 
 438:Drivers/CMSIS/Include/core_cm0.h **** /**
 439:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 440:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 441:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 442:Drivers/CMSIS/Include/core_cm0.h ****   @{
 443:Drivers/CMSIS/Include/core_cm0.h ****  */
 444:Drivers/CMSIS/Include/core_cm0.h **** 
 445:Drivers/CMSIS/Include/core_cm0.h **** /**
 446:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 447:Drivers/CMSIS/Include/core_cm0.h ****  */
 448:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 449:Drivers/CMSIS/Include/core_cm0.h **** {
 450:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 451:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 452:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 453:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 454:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 458:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 459:Drivers/CMSIS/Include/core_cm0.h **** 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 461:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 462:Drivers/CMSIS/Include/core_cm0.h **** 
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
ARM GAS  /tmp/cc8ure6P.s 			page 31


 464:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 471:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 472:Drivers/CMSIS/Include/core_cm0.h **** 
 473:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 475:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 476:Drivers/CMSIS/Include/core_cm0.h **** 
 477:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 478:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 479:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 480:Drivers/CMSIS/Include/core_cm0.h **** 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 482:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 483:Drivers/CMSIS/Include/core_cm0.h **** 
 484:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 485:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 486:Drivers/CMSIS/Include/core_cm0.h **** 
 487:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 488:Drivers/CMSIS/Include/core_cm0.h **** 
 489:Drivers/CMSIS/Include/core_cm0.h **** 
 490:Drivers/CMSIS/Include/core_cm0.h **** /**
 491:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 492:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 493:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 494:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 495:Drivers/CMSIS/Include/core_cm0.h ****   @{
 496:Drivers/CMSIS/Include/core_cm0.h ****  */
 497:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 498:Drivers/CMSIS/Include/core_cm0.h **** 
 499:Drivers/CMSIS/Include/core_cm0.h **** 
 500:Drivers/CMSIS/Include/core_cm0.h **** /**
 501:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 502:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 503:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 504:Drivers/CMSIS/Include/core_cm0.h ****   @{
 505:Drivers/CMSIS/Include/core_cm0.h ****  */
 506:Drivers/CMSIS/Include/core_cm0.h **** 
 507:Drivers/CMSIS/Include/core_cm0.h **** /**
 508:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 509:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 510:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 511:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 512:Drivers/CMSIS/Include/core_cm0.h **** */
 513:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 514:Drivers/CMSIS/Include/core_cm0.h **** 
 515:Drivers/CMSIS/Include/core_cm0.h **** /**
 516:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 517:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 518:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 519:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 520:Drivers/CMSIS/Include/core_cm0.h **** */
ARM GAS  /tmp/cc8ure6P.s 			page 32


 521:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 522:Drivers/CMSIS/Include/core_cm0.h **** 
 523:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** 
 526:Drivers/CMSIS/Include/core_cm0.h **** /**
 527:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 528:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 529:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 530:Drivers/CMSIS/Include/core_cm0.h ****   @{
 531:Drivers/CMSIS/Include/core_cm0.h ****  */
 532:Drivers/CMSIS/Include/core_cm0.h **** 
 533:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Core Hardware */
 534:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 535:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 536:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 537:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 538:Drivers/CMSIS/Include/core_cm0.h **** 
 539:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 540:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 541:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 542:Drivers/CMSIS/Include/core_cm0.h **** 
 543:Drivers/CMSIS/Include/core_cm0.h **** 
 544:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 545:Drivers/CMSIS/Include/core_cm0.h **** 
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 549:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 550:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 551:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 552:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 553:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 554:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 557:Drivers/CMSIS/Include/core_cm0.h **** */
 558:Drivers/CMSIS/Include/core_cm0.h **** 
 559:Drivers/CMSIS/Include/core_cm0.h **** 
 560:Drivers/CMSIS/Include/core_cm0.h **** 
 561:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 562:Drivers/CMSIS/Include/core_cm0.h **** /**
 563:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 564:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 565:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 566:Drivers/CMSIS/Include/core_cm0.h ****   @{
 567:Drivers/CMSIS/Include/core_cm0.h ****  */
 568:Drivers/CMSIS/Include/core_cm0.h **** 
 569:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_NVIC_VIRTUAL
 570:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 571:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 572:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 573:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 574:Drivers/CMSIS/Include/core_cm0.h **** #else
 575:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
 576:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
 577:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
ARM GAS  /tmp/cc8ure6P.s 			page 33


 578:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 579:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 580:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 581:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 582:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 583:Drivers/CMSIS/Include/core_cm0.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
 584:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 585:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 586:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 587:Drivers/CMSIS/Include/core_cm0.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 588:Drivers/CMSIS/Include/core_cm0.h **** 
 589:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 590:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 591:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 592:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 593:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 594:Drivers/CMSIS/Include/core_cm0.h **** #else
 595:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetVector              __NVIC_SetVector
 596:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetVector              __NVIC_GetVector
 597:Drivers/CMSIS/Include/core_cm0.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 598:Drivers/CMSIS/Include/core_cm0.h **** 
 599:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_USER_IRQ_OFFSET          16
 600:Drivers/CMSIS/Include/core_cm0.h **** 
 601:Drivers/CMSIS/Include/core_cm0.h **** 
 602:Drivers/CMSIS/Include/core_cm0.h **** /* The following EXC_RETURN values are saved the LR on exception entry */
 603:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after ret
 604:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after retu
 605:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after retu
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under Armv6-M                  */
 609:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 610:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 611:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 612:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 613:Drivers/CMSIS/Include/core_cm0.h **** 
 614:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_SetPriorityGrouping(X) (void)(X)
 615:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_GetPriorityGrouping()  (0U)
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /**
 618:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable Interrupt
 619:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 620:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 621:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 622:Drivers/CMSIS/Include/core_cm0.h ****  */
 623:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 968              		.loc 2 623 22 view .LVU262
 969              	.LBB7:
 624:Drivers/CMSIS/Include/core_cm0.h **** {
 625:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 970              		.loc 2 625 3 view .LVU263
 626:Drivers/CMSIS/Include/core_cm0.h ****   {
 627:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 971              		.loc 2 627 5 view .LVU264
 972              		.loc 2 627 20 is_stmt 0 view .LVU265
 973 00cc 114B     		ldr	r3, .L40+40
 974 00ce 8022     		movs	r2, #128
ARM GAS  /tmp/cc8ure6P.s 			page 34


 975 00d0 9202     		lsls	r2, r2, #10
 976 00d2 1A60     		str	r2, [r3]
 977              	.LVL49:
 978              		.loc 2 627 20 view .LVU266
 979              	.LBE7:
 980              	.LBE6:
 268:Src/motor.c   ****     NVIC_SetPriority(TIM6_DAC_IRQn,2);
 981              		.loc 1 268 5 is_stmt 1 view .LVU267
 982              	.LBB8:
 983              	.LBI8:
 628:Drivers/CMSIS/Include/core_cm0.h ****   }
 629:Drivers/CMSIS/Include/core_cm0.h **** }
 630:Drivers/CMSIS/Include/core_cm0.h **** 
 631:Drivers/CMSIS/Include/core_cm0.h **** 
 632:Drivers/CMSIS/Include/core_cm0.h **** /**
 633:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Enable status
 634:Drivers/CMSIS/Include/core_cm0.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 635:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 636:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt is not enabled.
 637:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt is enabled.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 643:Drivers/CMSIS/Include/core_cm0.h ****   {
 644:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 645:Drivers/CMSIS/Include/core_cm0.h ****   }
 646:Drivers/CMSIS/Include/core_cm0.h ****   else
 647:Drivers/CMSIS/Include/core_cm0.h ****   {
 648:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 649:Drivers/CMSIS/Include/core_cm0.h ****   }
 650:Drivers/CMSIS/Include/core_cm0.h **** }
 651:Drivers/CMSIS/Include/core_cm0.h **** 
 652:Drivers/CMSIS/Include/core_cm0.h **** 
 653:Drivers/CMSIS/Include/core_cm0.h **** /**
 654:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable Interrupt
 655:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 656:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 657:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 658:Drivers/CMSIS/Include/core_cm0.h ****  */
 659:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 660:Drivers/CMSIS/Include/core_cm0.h **** {
 661:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 662:Drivers/CMSIS/Include/core_cm0.h ****   {
 663:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 664:Drivers/CMSIS/Include/core_cm0.h ****     __DSB();
 665:Drivers/CMSIS/Include/core_cm0.h ****     __ISB();
 666:Drivers/CMSIS/Include/core_cm0.h ****   }
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 674:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
ARM GAS  /tmp/cc8ure6P.s 			page 35


 675:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 676:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 677:Drivers/CMSIS/Include/core_cm0.h ****  */
 678:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 679:Drivers/CMSIS/Include/core_cm0.h **** {
 680:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 681:Drivers/CMSIS/Include/core_cm0.h ****   {
 682:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 683:Drivers/CMSIS/Include/core_cm0.h ****   }
 684:Drivers/CMSIS/Include/core_cm0.h ****   else
 685:Drivers/CMSIS/Include/core_cm0.h ****   {
 686:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 687:Drivers/CMSIS/Include/core_cm0.h ****   }
 688:Drivers/CMSIS/Include/core_cm0.h **** }
 689:Drivers/CMSIS/Include/core_cm0.h **** 
 690:Drivers/CMSIS/Include/core_cm0.h **** 
 691:Drivers/CMSIS/Include/core_cm0.h **** /**
 692:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 693:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 694:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 695:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 696:Drivers/CMSIS/Include/core_cm0.h ****  */
 697:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 698:Drivers/CMSIS/Include/core_cm0.h **** {
 699:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 700:Drivers/CMSIS/Include/core_cm0.h ****   {
 701:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 702:Drivers/CMSIS/Include/core_cm0.h ****   }
 703:Drivers/CMSIS/Include/core_cm0.h **** }
 704:Drivers/CMSIS/Include/core_cm0.h **** 
 705:Drivers/CMSIS/Include/core_cm0.h **** 
 706:Drivers/CMSIS/Include/core_cm0.h **** /**
 707:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 708:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 710:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 715:Drivers/CMSIS/Include/core_cm0.h ****   {
 716:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 717:Drivers/CMSIS/Include/core_cm0.h ****   }
 718:Drivers/CMSIS/Include/core_cm0.h **** }
 719:Drivers/CMSIS/Include/core_cm0.h **** 
 720:Drivers/CMSIS/Include/core_cm0.h **** 
 721:Drivers/CMSIS/Include/core_cm0.h **** /**
 722:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 723:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 724:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 725:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 726:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 727:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 728:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every processor exception.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 984              		.loc 2 730 22 view .LVU268
ARM GAS  /tmp/cc8ure6P.s 			page 36


 985              	.LBB9:
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 986              		.loc 2 732 3 view .LVU269
 733:Drivers/CMSIS/Include/core_cm0.h ****   {
 734:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 987              		.loc 2 734 5 view .LVU270
 988              		.loc 2 734 52 is_stmt 0 view .LVU271
 989 00d4 C420     		movs	r0, #196
 990 00d6 8000     		lsls	r0, r0, #2
 991 00d8 1958     		ldr	r1, [r3, r0]
 992              		.loc 2 734 33 view .LVU272
 993 00da 0F4A     		ldr	r2, .L40+44
 994 00dc 1140     		ands	r1, r2
 995              		.loc 2 734 102 view .LVU273
 996 00de 8022     		movs	r2, #128
 997 00e0 1202     		lsls	r2, r2, #8
 998 00e2 0A43     		orrs	r2, r1
 999              		.loc 2 734 30 view .LVU274
 1000 00e4 1A50     		str	r2, [r3, r0]
 1001              	.LVL50:
 1002              		.loc 2 734 30 view .LVU275
 1003              	.LBE9:
 1004              	.LBE8:
 269:Src/motor.c   **** }
 1005              		.loc 1 269 1 view .LVU276
 1006              		@ sp needed
 1007 00e6 80BC     		pop	{r7}
 1008 00e8 B846     		mov	r8, r7
 1009 00ea F0BD     		pop	{r4, r5, r6, r7, pc}
 1010              	.L41:
 1011              		.align	2
 1012              	.L40:
 1013 00ec 00040048 		.word	1207960576
 1014 00f0 FFFAFFFF 		.word	-1281
 1015 00f4 FFFFFFAF 		.word	-1342177281
 1016 00f8 00100240 		.word	1073876992
 1017 00fc 00040040 		.word	1073742848
 1018 0100 FFFF0000 		.word	65535
 1019 0104 FF7F0000 		.word	32767
 1020 0108 00400140 		.word	1073823744
 1021 010c 00100040 		.word	1073745920
 1022 0110 30750000 		.word	30000
 1023 0114 00E100E0 		.word	-536813312
 1024 0118 FF00FFFF 		.word	-65281
 1025              		.cfi_endproc
 1026              	.LFE54:
 1028              		.section	.text.TIM6_DAC_IRQHandler,"ax",%progbits
 1029              		.align	1
 1030              		.global	TIM6_DAC_IRQHandler
 1031              		.syntax unified
 1032              		.code	16
 1033              		.thumb_func
 1035              	TIM6_DAC_IRQHandler:
 1036              	.LFB55:
 270:Src/motor.c   **** 
 271:Src/motor.c   **** // Encoder interrupt to calculate motor speed, also manages PI controller
ARM GAS  /tmp/cc8ure6P.s 			page 37


 272:Src/motor.c   **** void TIM6_DAC_IRQHandler(void) {
 1037              		.loc 1 272 32 is_stmt 1 view -0
 1038              		.cfi_startproc
 1039              		@ args = 0, pretend = 0, frame = 0
 1040              		@ frame_needed = 0, uses_anonymous_args = 0
 1041              		@ link register save eliminated.
 273:Src/motor.c   ****     /* Calculate the motor speed in raw encoder counts
 274:Src/motor.c   ****      * Note the motor speed is signed! Motor can be run in reverse.
 275:Src/motor.c   ****      * Speed is measured by how far the counter moved from center point
 276:Src/motor.c   ****      */
 277:Src/motor.c   ****     motorl_speed = (TIM3->CNT - 0x7FFF);
 1042              		.loc 1 277 5 view .LVU278
 1043              		.loc 1 277 25 is_stmt 0 view .LVU279
 1044 0000 0B4A     		ldr	r2, .L43
 1045 0002 536A     		ldr	r3, [r2, #36]
 1046              		.loc 1 277 31 view .LVU280
 1047 0004 0B49     		ldr	r1, .L43+4
 1048 0006 8C46     		mov	ip, r1
 1049 0008 6344     		add	r3, r3, ip
 1050 000a 1BB2     		sxth	r3, r3
 1051              		.loc 1 277 18 view .LVU281
 1052 000c 0A49     		ldr	r1, .L43+8
 1053 000e 0B80     		strh	r3, [r1]
 278:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 1054              		.loc 1 278 5 is_stmt 1 view .LVU282
 1055              		.loc 1 278 15 is_stmt 0 view .LVU283
 1056 0010 0A49     		ldr	r1, .L43+12
 1057 0012 5162     		str	r1, [r2, #36]
 279:Src/motor.c   **** 	  motorr_speed = (TIM15->CNT - 0x7FFF);
 1058              		.loc 1 279 4 is_stmt 1 view .LVU284
 1059              		.loc 1 279 25 is_stmt 0 view .LVU285
 1060 0014 0A4A     		ldr	r2, .L43+16
 1061 0016 536A     		ldr	r3, [r2, #36]
 1062              		.loc 1 279 31 view .LVU286
 1063 0018 6344     		add	r3, r3, ip
 1064 001a 1BB2     		sxth	r3, r3
 1065              		.loc 1 279 17 view .LVU287
 1066 001c 0948     		ldr	r0, .L43+20
 1067 001e 0380     		strh	r3, [r0]
 280:Src/motor.c   ****     TIM15->CNT = 0x7FFF; // Reset back to center point
 1068              		.loc 1 280 5 is_stmt 1 view .LVU288
 1069              		.loc 1 280 16 is_stmt 0 view .LVU289
 1070 0020 5162     		str	r1, [r2, #36]
 281:Src/motor.c   ****     
 282:Src/motor.c   ****     // Call the PI update function
 283:Src/motor.c   ****     TIM6->SR &= ~TIM_SR_UIF;        // Acknowledge the interrupt
 1071              		.loc 1 283 5 is_stmt 1 view .LVU290
 1072              		.loc 1 283 9 is_stmt 0 view .LVU291
 1073 0022 094A     		ldr	r2, .L43+24
 1074 0024 1369     		ldr	r3, [r2, #16]
 1075              		.loc 1 283 14 view .LVU292
 1076 0026 0121     		movs	r1, #1
 1077 0028 8B43     		bics	r3, r1
 1078 002a 1361     		str	r3, [r2, #16]
 284:Src/motor.c   **** }
 1079              		.loc 1 284 1 view .LVU293
 1080              		@ sp needed
ARM GAS  /tmp/cc8ure6P.s 			page 38


 1081 002c 7047     		bx	lr
 1082              	.L44:
 1083 002e C046     		.align	2
 1084              	.L43:
 1085 0030 00040040 		.word	1073742848
 1086 0034 0180FFFF 		.word	-32767
 1087 0038 00000000 		.word	motorl_speed
 1088 003c FF7F0000 		.word	32767
 1089 0040 00400140 		.word	1073823744
 1090 0044 00000000 		.word	motorr_speed
 1091 0048 00100040 		.word	1073745920
 1092              		.cfi_endproc
 1093              	.LFE55:
 1095              		.section	.text.ADC_init,"ax",%progbits
 1096              		.align	1
 1097              		.global	ADC_init
 1098              		.syntax unified
 1099              		.code	16
 1100              		.thumb_func
 1102              	ADC_init:
 1103              	.LFB56:
 285:Src/motor.c   **** 
 286:Src/motor.c   **** void ADC_init(void) {
 1104              		.loc 1 286 21 is_stmt 1 view -0
 1105              		.cfi_startproc
 1106              		@ args = 0, pretend = 0, frame = 0
 1107              		@ frame_needed = 0, uses_anonymous_args = 0
 1108              		@ link register save eliminated.
 287:Src/motor.c   **** 
 288:Src/motor.c   ****     // Configure PA1 for ADC input (used for current monitoring)
 289:Src/motor.c   ****     GPIOA->MODER |= (GPIO_MODER_MODER1_0 | GPIO_MODER_MODER1_1);
 1109              		.loc 1 289 5 view .LVU295
 1110              		.loc 1 289 10 is_stmt 0 view .LVU296
 1111 0000 9022     		movs	r2, #144
 1112 0002 D205     		lsls	r2, r2, #23
 1113 0004 1368     		ldr	r3, [r2]
 1114              		.loc 1 289 18 view .LVU297
 1115 0006 0C21     		movs	r1, #12
 1116 0008 0B43     		orrs	r3, r1
 1117 000a 1360     		str	r3, [r2]
 290:Src/motor.c   **** 
 291:Src/motor.c   ****     // Configure ADC to 8-bit continuous-run mode, (asynchronous clock mode)
 292:Src/motor.c   ****     RCC->APB2ENR |= RCC_APB2ENR_ADCEN;
 1118              		.loc 1 292 5 is_stmt 1 view .LVU298
 1119              		.loc 1 292 8 is_stmt 0 view .LVU299
 1120 000c 154A     		ldr	r2, .L49
 1121 000e 9169     		ldr	r1, [r2, #24]
 1122              		.loc 1 292 18 view .LVU300
 1123 0010 8023     		movs	r3, #128
 1124 0012 9B00     		lsls	r3, r3, #2
 1125 0014 0B43     		orrs	r3, r1
 1126 0016 9361     		str	r3, [r2, #24]
 293:Src/motor.c   **** 
 294:Src/motor.c   ****     ADC1->CFGR1 = 0;                        // Default resolution is 12-bit (RES[1:0] = 00 --> 12-b
 1127              		.loc 1 294 5 is_stmt 1 view .LVU301
 1128              		.loc 1 294 17 is_stmt 0 view .LVU302
 1129 0018 134B     		ldr	r3, .L49+4
ARM GAS  /tmp/cc8ure6P.s 			page 39


 1130 001a 0021     		movs	r1, #0
 1131 001c D960     		str	r1, [r3, #12]
 295:Src/motor.c   ****     ADC1->CFGR1 |= ADC_CFGR1_CONT;          // Set to continuous mode
 1132              		.loc 1 295 5 is_stmt 1 view .LVU303
 1133              		.loc 1 295 9 is_stmt 0 view .LVU304
 1134 001e D868     		ldr	r0, [r3, #12]
 1135              		.loc 1 295 17 view .LVU305
 1136 0020 8022     		movs	r2, #128
 1137 0022 9201     		lsls	r2, r2, #6
 1138 0024 0243     		orrs	r2, r0
 1139 0026 DA60     		str	r2, [r3, #12]
 296:Src/motor.c   ****     ADC1->CHSELR |= ADC_CHSELR_CHSEL1;      // Enable channel 1
 1140              		.loc 1 296 5 is_stmt 1 view .LVU306
 1141              		.loc 1 296 9 is_stmt 0 view .LVU307
 1142 0028 9A6A     		ldr	r2, [r3, #40]
 1143              		.loc 1 296 18 view .LVU308
 1144 002a 0220     		movs	r0, #2
 1145 002c 0243     		orrs	r2, r0
 1146 002e 9A62     		str	r2, [r3, #40]
 297:Src/motor.c   **** 
 298:Src/motor.c   ****     ADC1->CR = 0;
 1147              		.loc 1 298 5 is_stmt 1 view .LVU309
 1148              		.loc 1 298 14 is_stmt 0 view .LVU310
 1149 0030 9960     		str	r1, [r3, #8]
 299:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADCAL;               // Perform self calibration
 1150              		.loc 1 299 5 is_stmt 1 view .LVU311
 1151              		.loc 1 299 9 is_stmt 0 view .LVU312
 1152 0032 9968     		ldr	r1, [r3, #8]
 1153              		.loc 1 299 14 view .LVU313
 1154 0034 8022     		movs	r2, #128
 1155 0036 1206     		lsls	r2, r2, #24
 1156 0038 0A43     		orrs	r2, r1
 1157 003a 9A60     		str	r2, [r3, #8]
 300:Src/motor.c   ****     while(ADC1->CR & ADC_CR_ADCAL);         // Delay until calibration is complete
 1158              		.loc 1 300 5 is_stmt 1 view .LVU314
 1159              	.L46:
 1160              		.loc 1 300 11 discriminator 1 view .LVU315
 1161              		.loc 1 300 15 is_stmt 0 discriminator 1 view .LVU316
 1162 003c 0A4B     		ldr	r3, .L49+4
 1163 003e 9B68     		ldr	r3, [r3, #8]
 1164              		.loc 1 300 11 discriminator 1 view .LVU317
 1165 0040 002B     		cmp	r3, #0
 1166 0042 FBDB     		blt	.L46
 301:Src/motor.c   **** 
 302:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADEN;                // Enable ADC
 1167              		.loc 1 302 5 is_stmt 1 view .LVU318
 1168              		.loc 1 302 9 is_stmt 0 view .LVU319
 1169 0044 084A     		ldr	r2, .L49+4
 1170 0046 9368     		ldr	r3, [r2, #8]
 1171              		.loc 1 302 14 view .LVU320
 1172 0048 0121     		movs	r1, #1
 1173 004a 0B43     		orrs	r3, r1
 1174 004c 9360     		str	r3, [r2, #8]
 303:Src/motor.c   ****     while(!(ADC1->ISR & ADC_ISR_ADRDY));    // Wait until ADC ready
 1175              		.loc 1 303 5 is_stmt 1 view .LVU321
 1176              	.L47:
 1177              		.loc 1 303 11 discriminator 1 view .LVU322
ARM GAS  /tmp/cc8ure6P.s 			page 40


 1178              		.loc 1 303 17 is_stmt 0 discriminator 1 view .LVU323
 1179 004e 064B     		ldr	r3, .L49+4
 1180 0050 1B68     		ldr	r3, [r3]
 1181              		.loc 1 303 11 discriminator 1 view .LVU324
 1182 0052 DB07     		lsls	r3, r3, #31
 1183 0054 FBD5     		bpl	.L47
 304:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADSTART;             // Signal conversion start
 1184              		.loc 1 304 5 is_stmt 1 view .LVU325
 1185              		.loc 1 304 9 is_stmt 0 view .LVU326
 1186 0056 044A     		ldr	r2, .L49+4
 1187 0058 9368     		ldr	r3, [r2, #8]
 1188              		.loc 1 304 14 view .LVU327
 1189 005a 0421     		movs	r1, #4
 1190 005c 0B43     		orrs	r3, r1
 1191 005e 9360     		str	r3, [r2, #8]
 305:Src/motor.c   **** }
 1192              		.loc 1 305 1 view .LVU328
 1193              		@ sp needed
 1194 0060 7047     		bx	lr
 1195              	.L50:
 1196 0062 C046     		.align	2
 1197              	.L49:
 1198 0064 00100240 		.word	1073876992
 1199 0068 00240140 		.word	1073816576
 1200              		.cfi_endproc
 1201              	.LFE56:
 1203              		.section	.text.motor_init,"ax",%progbits
 1204              		.align	1
 1205              		.global	motor_init
 1206              		.syntax unified
 1207              		.code	16
 1208              		.thumb_func
 1210              	motor_init:
 1211              	.LFB43:
  18:Src/motor.c   ****     pwm_init();
 1212              		.loc 1 18 23 is_stmt 1 view -0
 1213              		.cfi_startproc
 1214              		@ args = 0, pretend = 0, frame = 0
 1215              		@ frame_needed = 0, uses_anonymous_args = 0
 1216 0000 10B5     		push	{r4, lr}
 1217              	.LCFI12:
 1218              		.cfi_def_cfa_offset 8
 1219              		.cfi_offset 4, -8
 1220              		.cfi_offset 14, -4
  19:Src/motor.c   ****     encoder_init();
 1221              		.loc 1 19 5 view .LVU330
 1222 0002 FFF7FEFF 		bl	pwm_init
 1223              	.LVL51:
  20:Src/motor.c   ****     ADC_init();
 1224              		.loc 1 20 5 view .LVU331
 1225 0006 FFF7FEFF 		bl	encoder_init
 1226              	.LVL52:
  21:Src/motor.c   **** }
 1227              		.loc 1 21 5 view .LVU332
 1228 000a FFF7FEFF 		bl	ADC_init
 1229              	.LVL53:
  22:Src/motor.c   **** 
ARM GAS  /tmp/cc8ure6P.s 			page 41


 1230              		.loc 1 22 1 is_stmt 0 view .LVU333
 1231              		@ sp needed
 1232 000e 10BD     		pop	{r4, pc}
 1233              		.cfi_endproc
 1234              	.LFE43:
 1236              		.global	Ki
 1237              		.section	.data.Ki,"aw"
 1240              	Ki:
 1241 0000 01       		.byte	1
 1242              		.global	Kp
 1243              		.section	.data.Kp,"aw"
 1246              	Kp:
 1247 0000 01       		.byte	1
 1248              		.global	error
 1249              		.section	.bss.error,"aw",%nobits
 1250              		.align	1
 1253              	error:
 1254 0000 0000     		.space	2
 1255              		.global	adc_value
 1256              		.section	.bss.adc_value,"aw",%nobits
 1259              	adc_value:
 1260 0000 00       		.space	1
 1261              		.global	motorr_speed
 1262              		.section	.bss.motorr_speed,"aw",%nobits
 1263              		.align	1
 1266              	motorr_speed:
 1267 0000 0000     		.space	2
 1268              		.global	motorl_speed
 1269              		.section	.bss.motorl_speed,"aw",%nobits
 1270              		.align	1
 1273              	motorl_speed:
 1274 0000 0000     		.space	2
 1275              		.global	target_rpm
 1276              		.section	.bss.target_rpm,"aw",%nobits
 1277              		.align	1
 1280              	target_rpm:
 1281 0000 0000     		.space	2
 1282              		.global	duty_cycle
 1283              		.section	.bss.duty_cycle,"aw",%nobits
 1286              	duty_cycle:
 1287 0000 00       		.space	1
 1288              		.global	error_integral
 1289              		.section	.bss.error_integral,"aw",%nobits
 1290              		.align	1
 1293              	error_integral:
 1294 0000 0000     		.space	2
 1295              		.text
 1296              	.Letext0:
 1297              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1298              		.file 4 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
 1299              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1300              		.file 6 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h"
 1301              		.file 7 "Inc/pins.h"
 1302              		.file 8 "Inc/motor.h"
ARM GAS  /tmp/cc8ure6P.s 			page 42


DEFINED SYMBOLS
                            *ABS*:00000000 motor.c
     /tmp/cc8ure6P.s:19     .text.pwm_init:00000000 $t
     /tmp/cc8ure6P.s:25     .text.pwm_init:00000000 pwm_init
     /tmp/cc8ure6P.s:263    .text.pwm_init:00000104 $d
     /tmp/cc8ure6P.s:279    .text.pwm_setDutyCycleL:00000000 $t
     /tmp/cc8ure6P.s:285    .text.pwm_setDutyCycleL:00000000 pwm_setDutyCycleL
     /tmp/cc8ure6P.s:322    .text.pwm_setDutyCycleL:00000018 $d
     /tmp/cc8ure6P.s:327    .text.pwm_setDutyCycleR:00000000 $t
     /tmp/cc8ure6P.s:333    .text.pwm_setDutyCycleR:00000000 pwm_setDutyCycleR
     /tmp/cc8ure6P.s:372    .text.set_Motor_Direction:00000000 $t
     /tmp/cc8ure6P.s:378    .text.set_Motor_Direction:00000000 set_Motor_Direction
     /tmp/cc8ure6P.s:475    .text.set_Forward:00000000 $t
     /tmp/cc8ure6P.s:481    .text.set_Forward:00000000 set_Forward
     /tmp/cc8ure6P.s:508    .text.set_Forward:00000014 $d
     /tmp/cc8ure6P.s:514    .text.set_Backward:00000000 $t
     /tmp/cc8ure6P.s:520    .text.set_Backward:00000000 set_Backward
     /tmp/cc8ure6P.s:547    .text.set_Backward:00000014 $d
     /tmp/cc8ure6P.s:553    .text.set_Right:00000000 $t
     /tmp/cc8ure6P.s:559    .text.set_Right:00000000 set_Right
     /tmp/cc8ure6P.s:586    .text.set_Right:00000014 $d
     /tmp/cc8ure6P.s:592    .text.set_Left:00000000 $t
     /tmp/cc8ure6P.s:598    .text.set_Left:00000000 set_Left
     /tmp/cc8ure6P.s:625    .text.set_Left:00000014 $d
     /tmp/cc8ure6P.s:631    .text.set_Off:00000000 $t
     /tmp/cc8ure6P.s:637    .text.set_Off:00000000 set_Off
     /tmp/cc8ure6P.s:664    .text.set_Off:00000014 $d
     /tmp/cc8ure6P.s:670    .rodata.MoveMotors.str1.4:00000000 $d
     /tmp/cc8ure6P.s:677    .text.MoveMotors:00000000 $t
     /tmp/cc8ure6P.s:683    .text.MoveMotors:00000000 MoveMotors
     /tmp/cc8ure6P.s:754    .text.MoveMotors:00000038 $d
     /tmp/cc8ure6P.s:760    .text.encoder_init:00000000 $t
     /tmp/cc8ure6P.s:766    .text.encoder_init:00000000 encoder_init
     /tmp/cc8ure6P.s:1013   .text.encoder_init:000000ec $d
     /tmp/cc8ure6P.s:1029   .text.TIM6_DAC_IRQHandler:00000000 $t
     /tmp/cc8ure6P.s:1035   .text.TIM6_DAC_IRQHandler:00000000 TIM6_DAC_IRQHandler
     /tmp/cc8ure6P.s:1085   .text.TIM6_DAC_IRQHandler:00000030 $d
     /tmp/cc8ure6P.s:1273   .bss.motorl_speed:00000000 motorl_speed
     /tmp/cc8ure6P.s:1266   .bss.motorr_speed:00000000 motorr_speed
     /tmp/cc8ure6P.s:1096   .text.ADC_init:00000000 $t
     /tmp/cc8ure6P.s:1102   .text.ADC_init:00000000 ADC_init
     /tmp/cc8ure6P.s:1198   .text.ADC_init:00000064 $d
     /tmp/cc8ure6P.s:1204   .text.motor_init:00000000 $t
     /tmp/cc8ure6P.s:1210   .text.motor_init:00000000 motor_init
     /tmp/cc8ure6P.s:1240   .data.Ki:00000000 Ki
     /tmp/cc8ure6P.s:1246   .data.Kp:00000000 Kp
     /tmp/cc8ure6P.s:1253   .bss.error:00000000 error
     /tmp/cc8ure6P.s:1250   .bss.error:00000000 $d
     /tmp/cc8ure6P.s:1259   .bss.adc_value:00000000 adc_value
     /tmp/cc8ure6P.s:1260   .bss.adc_value:00000000 $d
     /tmp/cc8ure6P.s:1263   .bss.motorr_speed:00000000 $d
     /tmp/cc8ure6P.s:1270   .bss.motorl_speed:00000000 $d
     /tmp/cc8ure6P.s:1280   .bss.target_rpm:00000000 target_rpm
     /tmp/cc8ure6P.s:1277   .bss.target_rpm:00000000 $d
     /tmp/cc8ure6P.s:1286   .bss.duty_cycle:00000000 duty_cycle
     /tmp/cc8ure6P.s:1287   .bss.duty_cycle:00000000 $d
     /tmp/cc8ure6P.s:1293   .bss.error_integral:00000000 error_integral
ARM GAS  /tmp/cc8ure6P.s 			page 43


     /tmp/cc8ure6P.s:1290   .bss.error_integral:00000000 $d

UNDEFINED SYMBOLS
HAL_GPIO_WritePin
motor_left_pins
motor_right_pins
__aeabi_uidiv
set_On
