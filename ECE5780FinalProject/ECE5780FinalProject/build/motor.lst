ARM GAS  /tmp/cchCdSqb.s 			page 1


   1              		.cpu cortex-m0
   2              		.arch armv6s-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"motor.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "Src/motor.c"
  18              		.section	.text.pwm_init,"ax",%progbits
  19              		.align	1
  20              		.global	pwm_init
  21              		.syntax unified
  22              		.code	16
  23              		.thumb_func
  25              	pwm_init:
  26              	.LFB44:
   1:Src/motor.c   **** /* ------------------------------------------------------------------------------------------------
   2:Src/motor.c   ****  *  Motor Control and Initialization Functions
   3:Src/motor.c   ****  * ------------------------------------------------------------------------------------------------
   4:Src/motor.c   ****  */
   5:Src/motor.c   **** #include "motor.h"
   6:Src/motor.c   **** 
   7:Src/motor.c   **** volatile int16_t motorl_speed = 0;   	// Measured left motor speed
   8:Src/motor.c   **** volatile int16_t motorr_speed = 0;   	// Measured left motor speed
   9:Src/motor.c   **** volatile uint8_t target_dist = 0;
  10:Src/motor.c   **** volatile float current_dist = 0;
  11:Src/motor.c   **** volatile float absolute_dist = 0;
  12:Src/motor.c   **** volatile float heading = 0;
  13:Src/motor.c   **** volatile bool turning = false;
  14:Src/motor.c   **** 
  15:Src/motor.c   **** // Sets up the entire motor drive system
  16:Src/motor.c   **** void motor_init(void) {
  17:Src/motor.c   ****     pwm_init();
  18:Src/motor.c   ****     encoder_init();
  19:Src/motor.c   **** }
  20:Src/motor.c   **** 
  21:Src/motor.c   **** // Sets up the PWM and direction signals to drive the H-Bridge
  22:Src/motor.c   **** void pwm_init(void) {
  27              		.loc 1 22 21 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
ARM GAS  /tmp/cchCdSqb.s 			page 2


  37              		.cfi_offset 14, -4
  23:Src/motor.c   **** 	//RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
  24:Src/motor.c   **** 	
  25:Src/motor.c   ****     // Set up pin PA4 for H-bridge PWM output (TIMER 14 CH1)
  26:Src/motor.c   **** 	/*
  27:Src/motor.c   ****     GPIOA->MODER |= (1 << 9);
  28:Src/motor.c   ****     GPIOA->MODER &= ~(1 << 8);
  29:Src/motor.c   **** 	
  30:Src/motor.c   **** 	  // Set up pin PB3 for H-bridge PWM output (TIMER 2 CH2)
  31:Src/motor.c   ****     GPIOB->MODER |= (1 << 7);
  32:Src/motor.c   ****     GPIOB->MODER &= ~(1 << 6);
  33:Src/motor.c   **** 
  34:Src/motor.c   ****     // Set PA4 to AF4,
  35:Src/motor.c   ****     GPIOA->AFR[0] &= 0xFFF0FFFF; // clear PA4 bits,
  36:Src/motor.c   ****     GPIOA->AFR[0] |= (1 << 18);
  37:Src/motor.c   **** 	
  38:Src/motor.c   **** 		// Set PB3 to AF2,
  39:Src/motor.c   ****     GPIOB->AFR[0] &= 0xFFFF0FFF; // clear PB3 bits,
  40:Src/motor.c   ****     GPIOB->AFR[0] |= (1 << 13);
  41:Src/motor.c   **** 
  42:Src/motor.c   ****     // Set up a PA5, PA8 as GPIO output pins for motor direction control
  43:Src/motor.c   ****     GPIOA->MODER &= 0xFFFCF3FF; // clear PA5, PA6 bits,
  44:Src/motor.c   ****     GPIOA->MODER |= (1 << 10) | (1 << 16);
  45:Src/motor.c   **** 	
  46:Src/motor.c   **** 		// Set up a PB2, PB10 as GPIO output pins for motor direction control
  47:Src/motor.c   ****     GPIOB->MODER &= 0xFFCFFFCF; // clear PB2, PB10 bits,
  48:Src/motor.c   ****     GPIOB->MODER |= (1 << 4) | (1 << 20);
  49:Src/motor.c   **** 	*/
  50:Src/motor.c   ****    
  51:Src/motor.c   ****     //Initialize one direction pin to high, the other low
  52:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_a.gpio, motor_left_pins.dir_a.pin.Pin, GPIO_PIN_SET);
  38              		.loc 1 52 2 view .LVU1
  39              		.loc 1 52 73 is_stmt 0 view .LVU2
  40 0002 244C     		ldr	r4, .L2
  41              		.loc 1 52 2 view .LVU3
  42 0004 A18B     		ldrh	r1, [r4, #28]
  43 0006 A069     		ldr	r0, [r4, #24]
  44 0008 0122     		movs	r2, #1
  45 000a FFF7FEFF 		bl	HAL_GPIO_WritePin
  46              	.LVL0:
  53:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_left_pins.dir_b.gpio, motor_left_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
  47              		.loc 1 53 2 is_stmt 1 view .LVU4
  48 000e A18E     		ldrh	r1, [r4, #52]
  49 0010 206B     		ldr	r0, [r4, #48]
  50 0012 0022     		movs	r2, #0
  51 0014 FFF7FEFF 		bl	HAL_GPIO_WritePin
  52              	.LVL1:
  54:Src/motor.c   **** 
  55:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_a.gpio, motor_right_pins.dir_a.pin.Pin, GPIO_PIN_SET);
  53              		.loc 1 55 2 view .LVU5
  54              		.loc 1 55 75 is_stmt 0 view .LVU6
  55 0018 1F4C     		ldr	r4, .L2+4
  56              		.loc 1 55 2 view .LVU7
  57 001a A18B     		ldrh	r1, [r4, #28]
  58 001c A069     		ldr	r0, [r4, #24]
  59 001e 0122     		movs	r2, #1
  60 0020 FFF7FEFF 		bl	HAL_GPIO_WritePin
ARM GAS  /tmp/cchCdSqb.s 			page 3


  61              	.LVL2:
  56:Src/motor.c   **** 	HAL_GPIO_WritePin(motor_right_pins.dir_b.gpio, motor_right_pins.dir_b.pin.Pin, GPIO_PIN_RESET);
  62              		.loc 1 56 2 is_stmt 1 view .LVU8
  63 0024 A18E     		ldrh	r1, [r4, #52]
  64 0026 206B     		ldr	r0, [r4, #48]
  65 0028 0022     		movs	r2, #0
  66 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
  67              	.LVL3:
  57:Src/motor.c   **** 
  58:Src/motor.c   ****     // Set up PWM timer
  59:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;
  68              		.loc 1 59 5 view .LVU9
  69              		.loc 1 59 8 is_stmt 0 view .LVU10
  70 002e 1B4B     		ldr	r3, .L2+8
  71 0030 D969     		ldr	r1, [r3, #28]
  72              		.loc 1 59 18 view .LVU11
  73 0032 8022     		movs	r2, #128
  74 0034 5200     		lsls	r2, r2, #1
  75 0036 0A43     		orrs	r2, r1
  76 0038 DA61     		str	r2, [r3, #28]
  60:Src/motor.c   ****     TIM14->CR1 = 0;                         // Clear control registers
  77              		.loc 1 60 5 is_stmt 1 view .LVU12
  78              		.loc 1 60 16 is_stmt 0 view .LVU13
  79 003a 194A     		ldr	r2, .L2+12
  80 003c 0021     		movs	r1, #0
  81 003e 1160     		str	r1, [r2]
  61:Src/motor.c   ****     TIM14->CCMR1 = 0;                       // (prevents having to manually clear bits)
  82              		.loc 1 61 5 is_stmt 1 view .LVU14
  83              		.loc 1 61 18 is_stmt 0 view .LVU15
  84 0040 9161     		str	r1, [r2, #24]
  62:Src/motor.c   ****     TIM14->CCER = 0;
  85              		.loc 1 62 5 is_stmt 1 view .LVU16
  86              		.loc 1 62 17 is_stmt 0 view .LVU17
  87 0042 1162     		str	r1, [r2, #32]
  63:Src/motor.c   **** 		
  64:Src/motor.c   **** 		RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
  88              		.loc 1 64 3 is_stmt 1 view .LVU18
  89              		.loc 1 64 6 is_stmt 0 view .LVU19
  90 0044 DC69     		ldr	r4, [r3, #28]
  91              		.loc 1 64 16 view .LVU20
  92 0046 0120     		movs	r0, #1
  93 0048 0443     		orrs	r4, r0
  94 004a DC61     		str	r4, [r3, #28]
  65:Src/motor.c   ****     TIM2->CR1 = 0;                         // Clear control registers
  95              		.loc 1 65 5 is_stmt 1 view .LVU21
  96              		.loc 1 65 15 is_stmt 0 view .LVU22
  97 004c 8023     		movs	r3, #128
  98 004e DB05     		lsls	r3, r3, #23
  99 0050 1960     		str	r1, [r3]
  66:Src/motor.c   ****     TIM2->CCMR1 = 0;                       // (prevents having to manually clear bits)
 100              		.loc 1 66 5 is_stmt 1 view .LVU23
 101              		.loc 1 66 17 is_stmt 0 view .LVU24
 102 0052 9961     		str	r1, [r3, #24]
  67:Src/motor.c   ****     TIM2->CCER = 0;
 103              		.loc 1 67 5 is_stmt 1 view .LVU25
 104              		.loc 1 67 16 is_stmt 0 view .LVU26
 105 0054 1962     		str	r1, [r3, #32]
ARM GAS  /tmp/cchCdSqb.s 			page 4


  68:Src/motor.c   **** 
  69:Src/motor.c   ****     // Set output-compare CH1 to PWM1 mode and enable CCR1 preload buffer
  70:Src/motor.c   ****     TIM14->CCMR1 |= (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE);
 106              		.loc 1 70 5 is_stmt 1 view .LVU27
 107              		.loc 1 70 10 is_stmt 0 view .LVU28
 108 0056 9469     		ldr	r4, [r2, #24]
 109              		.loc 1 70 18 view .LVU29
 110 0058 6825     		movs	r5, #104
 111 005a 2C43     		orrs	r4, r5
 112 005c 9461     		str	r4, [r2, #24]
  71:Src/motor.c   ****     TIM14->CCER |= TIM_CCER_CC1E;           // Enable capture-compare channel 1
 113              		.loc 1 71 5 is_stmt 1 view .LVU30
 114              		.loc 1 71 10 is_stmt 0 view .LVU31
 115 005e 146A     		ldr	r4, [r2, #32]
 116              		.loc 1 71 17 view .LVU32
 117 0060 0443     		orrs	r4, r0
 118 0062 1462     		str	r4, [r2, #32]
  72:Src/motor.c   ****     TIM14->PSC = 1;                         // Run timer on 24Mhz
 119              		.loc 1 72 5 is_stmt 1 view .LVU33
 120              		.loc 1 72 16 is_stmt 0 view .LVU34
 121 0064 9062     		str	r0, [r2, #40]
  73:Src/motor.c   ****     TIM14->ARR = 1200;                      // PWM at 20kHz
 122              		.loc 1 73 5 is_stmt 1 view .LVU35
 123              		.loc 1 73 16 is_stmt 0 view .LVU36
 124 0066 9625     		movs	r5, #150
 125 0068 ED00     		lsls	r5, r5, #3
 126 006a D562     		str	r5, [r2, #44]
  74:Src/motor.c   ****     TIM14->CCR1 = 0;                        // Start PWM at 0% duty cycle
 127              		.loc 1 74 5 is_stmt 1 view .LVU37
 128              		.loc 1 74 17 is_stmt 0 view .LVU38
 129 006c 5163     		str	r1, [r2, #52]
  75:Src/motor.c   ****     
  76:Src/motor.c   ****     TIM14->CR1 |= TIM_CR1_CEN;              // Enable timer
 130              		.loc 1 76 5 is_stmt 1 view .LVU39
 131              		.loc 1 76 10 is_stmt 0 view .LVU40
 132 006e 1468     		ldr	r4, [r2]
 133              		.loc 1 76 16 view .LVU41
 134 0070 0443     		orrs	r4, r0
 135 0072 1460     		str	r4, [r2]
  77:Src/motor.c   **** 		
  78:Src/motor.c   **** 		TIM2->CCMR1 |= (TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2PE);
 136              		.loc 1 78 3 is_stmt 1 view .LVU42
 137              		.loc 1 78 7 is_stmt 0 view .LVU43
 138 0074 9C69     		ldr	r4, [r3, #24]
 139              		.loc 1 78 15 view .LVU44
 140 0076 D022     		movs	r2, #208
 141 0078 D201     		lsls	r2, r2, #7
 142 007a 2243     		orrs	r2, r4
 143 007c 9A61     		str	r2, [r3, #24]
  79:Src/motor.c   ****     TIM2->CCER |= TIM_CCER_CC2E;           // Enable capture-compare channel 2
 144              		.loc 1 79 5 is_stmt 1 view .LVU45
 145              		.loc 1 79 9 is_stmt 0 view .LVU46
 146 007e 1A6A     		ldr	r2, [r3, #32]
 147              		.loc 1 79 16 view .LVU47
 148 0080 1024     		movs	r4, #16
 149 0082 2243     		orrs	r2, r4
 150 0084 1A62     		str	r2, [r3, #32]
ARM GAS  /tmp/cchCdSqb.s 			page 5


  80:Src/motor.c   ****     TIM2->PSC = 1;                         // Run timer on 24Mhz
 151              		.loc 1 80 5 is_stmt 1 view .LVU48
 152              		.loc 1 80 15 is_stmt 0 view .LVU49
 153 0086 9862     		str	r0, [r3, #40]
  81:Src/motor.c   ****     TIM2->ARR = 1200;                      // PWM at 20kHz
 154              		.loc 1 81 5 is_stmt 1 view .LVU50
 155              		.loc 1 81 15 is_stmt 0 view .LVU51
 156 0088 DD62     		str	r5, [r3, #44]
  82:Src/motor.c   ****     TIM2->CCR2 = 0;                        // Start PWM at 0% duty cycle
 157              		.loc 1 82 5 is_stmt 1 view .LVU52
 158              		.loc 1 82 16 is_stmt 0 view .LVU53
 159 008a 9963     		str	r1, [r3, #56]
  83:Src/motor.c   ****     
  84:Src/motor.c   ****     TIM2->CR1 |= TIM_CR1_CEN;              // Enable timer
 160              		.loc 1 84 5 is_stmt 1 view .LVU54
 161              		.loc 1 84 9 is_stmt 0 view .LVU55
 162 008c 1A68     		ldr	r2, [r3]
 163              		.loc 1 84 15 view .LVU56
 164 008e 0243     		orrs	r2, r0
 165 0090 1A60     		str	r2, [r3]
  85:Src/motor.c   **** }
 166              		.loc 1 85 1 view .LVU57
 167              		@ sp needed
 168 0092 70BD     		pop	{r4, r5, r6, pc}
 169              	.L3:
 170              		.align	2
 171              	.L2:
 172 0094 00000000 		.word	motor_left_pins
 173 0098 00000000 		.word	motor_right_pins
 174 009c 00100240 		.word	1073876992
 175 00a0 00200040 		.word	1073750016
 176              		.cfi_endproc
 177              	.LFE44:
 179              		.global	__aeabi_uidiv
 180              		.section	.text.pwm_setDutyCycleL,"ax",%progbits
 181              		.align	1
 182              		.global	pwm_setDutyCycleL
 183              		.syntax unified
 184              		.code	16
 185              		.thumb_func
 187              	pwm_setDutyCycleL:
 188              	.LVL4:
 189              	.LFB45:
  86:Src/motor.c   **** 
  87:Src/motor.c   **** // Set the duty cycle of the PWM Left, accepts (0-100)
  88:Src/motor.c   **** void pwm_setDutyCycleL(uint8_t duty) {
 190              		.loc 1 88 38 is_stmt 1 view -0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		.loc 1 88 38 is_stmt 0 view .LVU59
 195 0000 10B5     		push	{r4, lr}
 196              	.LCFI1:
 197              		.cfi_def_cfa_offset 8
 198              		.cfi_offset 4, -8
 199              		.cfi_offset 14, -4
  89:Src/motor.c   ****     if(duty <= 100) {
ARM GAS  /tmp/cchCdSqb.s 			page 6


 200              		.loc 1 89 5 is_stmt 1 view .LVU60
 201              		.loc 1 89 7 is_stmt 0 view .LVU61
 202 0002 6428     		cmp	r0, #100
 203 0004 06D8     		bhi	.L4
  90:Src/motor.c   ****         TIM14->CCR1 = ((uint32_t)duty*TIM14->ARR)/100;  // Use linear transform to produce CCR1 val
 204              		.loc 1 90 9 is_stmt 1 view .LVU62
 205              		.loc 1 90 44 is_stmt 0 view .LVU63
 206 0006 044C     		ldr	r4, .L6
 207 0008 E36A     		ldr	r3, [r4, #44]
 208              		.loc 1 90 38 view .LVU64
 209 000a 5843     		muls	r0, r3
 210              	.LVL5:
 211              		.loc 1 90 50 view .LVU65
 212 000c 6421     		movs	r1, #100
 213 000e FFF7FEFF 		bl	__aeabi_uidiv
 214              	.LVL6:
 215              		.loc 1 90 21 view .LVU66
 216 0012 6063     		str	r0, [r4, #52]
 217              	.L4:
  91:Src/motor.c   ****         // (CCR1 == "pulse" parameter in PWM struct used by peripheral library)
  92:Src/motor.c   ****     }
  93:Src/motor.c   **** }
 218              		.loc 1 93 1 view .LVU67
 219              		@ sp needed
 220 0014 10BD     		pop	{r4, pc}
 221              	.L7:
 222 0016 C046     		.align	2
 223              	.L6:
 224 0018 00200040 		.word	1073750016
 225              		.cfi_endproc
 226              	.LFE45:
 228              		.section	.text.pwm_setDutyCycleR,"ax",%progbits
 229              		.align	1
 230              		.global	pwm_setDutyCycleR
 231              		.syntax unified
 232              		.code	16
 233              		.thumb_func
 235              	pwm_setDutyCycleR:
 236              	.LVL7:
 237              	.LFB46:
  94:Src/motor.c   **** 
  95:Src/motor.c   **** // Set the duty cycle of the PWM Right, accepts (0-100)
  96:Src/motor.c   **** void pwm_setDutyCycleR(uint8_t duty) {
 238              		.loc 1 96 38 is_stmt 1 view -0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		.loc 1 96 38 is_stmt 0 view .LVU69
 243 0000 10B5     		push	{r4, lr}
 244              	.LCFI2:
 245              		.cfi_def_cfa_offset 8
 246              		.cfi_offset 4, -8
 247              		.cfi_offset 14, -4
  97:Src/motor.c   ****     if(duty <= 100) {
 248              		.loc 1 97 5 is_stmt 1 view .LVU70
 249              		.loc 1 97 7 is_stmt 0 view .LVU71
 250 0002 6428     		cmp	r0, #100
ARM GAS  /tmp/cchCdSqb.s 			page 7


 251 0004 07D8     		bhi	.L8
  98:Src/motor.c   ****         TIM2->CCR2 = ((uint32_t)duty*TIM2->ARR)/100;  // Use linear transform to produce CCR1 value
 252              		.loc 1 98 9 is_stmt 1 view .LVU72
 253              		.loc 1 98 42 is_stmt 0 view .LVU73
 254 0006 8024     		movs	r4, #128
 255 0008 E405     		lsls	r4, r4, #23
 256 000a E36A     		ldr	r3, [r4, #44]
 257              		.loc 1 98 37 view .LVU74
 258 000c 5843     		muls	r0, r3
 259              	.LVL8:
 260              		.loc 1 98 48 view .LVU75
 261 000e 6421     		movs	r1, #100
 262 0010 FFF7FEFF 		bl	__aeabi_uidiv
 263              	.LVL9:
 264              		.loc 1 98 20 view .LVU76
 265 0014 A063     		str	r0, [r4, #56]
 266              	.L8:
  99:Src/motor.c   ****         // (CCR2 == "pulse" parameter in PWM struct used by peripheral library)
 100:Src/motor.c   ****     }
 101:Src/motor.c   **** }
 267              		.loc 1 101 1 view .LVU77
 268              		@ sp needed
 269 0016 10BD     		pop	{r4, pc}
 270              		.cfi_endproc
 271              	.LFE46:
 273              		.section	.text.set_Motor_Direction,"ax",%progbits
 274              		.align	1
 275              		.global	set_Motor_Direction
 276              		.syntax unified
 277              		.code	16
 278              		.thumb_func
 280              	set_Motor_Direction:
 281              	.LVL10:
 282              	.LFB47:
 102:Src/motor.c   **** 
 103:Src/motor.c   **** /*
 104:Src/motor.c   ****  * This sets an individual motor's direction.
 105:Src/motor.c   ****  * Note: use MoveMotors to change multiple motor values, eg to turn.
 106:Src/motor.c   ****  */
 107:Src/motor.c   **** void set_Motor_Direction(Direction dir, motor_pins_t* pins){
 283              		.loc 1 107 60 is_stmt 1 view -0
 284              		.cfi_startproc
 285              		@ args = 0, pretend = 0, frame = 0
 286              		@ frame_needed = 0, uses_anonymous_args = 0
 287              		.loc 1 107 60 is_stmt 0 view .LVU79
 288 0000 10B5     		push	{r4, lr}
 289              	.LCFI3:
 290              		.cfi_def_cfa_offset 8
 291              		.cfi_offset 4, -8
 292              		.cfi_offset 14, -4
 293 0002 0C00     		movs	r4, r1
 108:Src/motor.c   **** 	switch(dir){
 294              		.loc 1 108 2 is_stmt 1 view .LVU80
 295 0004 0028     		cmp	r0, #0
 296 0006 02D0     		beq	.L11
 297 0008 0328     		cmp	r0, #3
 298 000a 0BD0     		beq	.L12
ARM GAS  /tmp/cchCdSqb.s 			page 8


 299              	.LVL11:
 300              	.L10:
 109:Src/motor.c   **** 		case FORWARD:
 110:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_SET);
 111:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 112:Src/motor.c   **** 			break;
 113:Src/motor.c   **** 		case BACKWARD:
 114:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_a.gpio, pins->dir_a.pin.Pin, GPIO_PIN_RESET);
 115:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 116:Src/motor.c   **** 			break;
 117:Src/motor.c   **** 		default:
 118:Src/motor.c   **** 			;
 119:Src/motor.c   **** 	}
 120:Src/motor.c   **** }
 301              		.loc 1 120 1 is_stmt 0 view .LVU81
 302              		@ sp needed
 303              	.LVL12:
 304              		.loc 1 120 1 view .LVU82
 305 000c 10BD     		pop	{r4, pc}
 306              	.LVL13:
 307              	.L11:
 110:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 308              		.loc 1 110 4 is_stmt 1 view .LVU83
 309 000e 898B     		ldrh	r1, [r1, #28]
 310              	.LVL14:
 110:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 311              		.loc 1 110 4 is_stmt 0 view .LVU84
 312 0010 A069     		ldr	r0, [r4, #24]
 313              	.LVL15:
 110:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_RESET);
 314              		.loc 1 110 4 view .LVU85
 315 0012 0122     		movs	r2, #1
 316 0014 FFF7FEFF 		bl	HAL_GPIO_WritePin
 317              	.LVL16:
 111:Src/motor.c   **** 			break;
 318              		.loc 1 111 4 is_stmt 1 view .LVU86
 319 0018 A18E     		ldrh	r1, [r4, #52]
 320 001a 206B     		ldr	r0, [r4, #48]
 321 001c 0022     		movs	r2, #0
 322 001e FFF7FEFF 		bl	HAL_GPIO_WritePin
 323              	.LVL17:
 112:Src/motor.c   **** 		case BACKWARD:
 324              		.loc 1 112 4 view .LVU87
 325 0022 F3E7     		b	.L10
 326              	.LVL18:
 327              	.L12:
 114:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 328              		.loc 1 114 4 view .LVU88
 329 0024 898B     		ldrh	r1, [r1, #28]
 330              	.LVL19:
 114:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 331              		.loc 1 114 4 is_stmt 0 view .LVU89
 332 0026 A069     		ldr	r0, [r4, #24]
 333              	.LVL20:
 114:Src/motor.c   **** 			HAL_GPIO_WritePin(pins->dir_b.gpio, pins->dir_b.pin.Pin, GPIO_PIN_SET);
 334              		.loc 1 114 4 view .LVU90
 335 0028 0022     		movs	r2, #0
ARM GAS  /tmp/cchCdSqb.s 			page 9


 336 002a FFF7FEFF 		bl	HAL_GPIO_WritePin
 337              	.LVL21:
 115:Src/motor.c   **** 			break;
 338              		.loc 1 115 4 is_stmt 1 view .LVU91
 339 002e A18E     		ldrh	r1, [r4, #52]
 340 0030 206B     		ldr	r0, [r4, #48]
 341 0032 0122     		movs	r2, #1
 342 0034 FFF7FEFF 		bl	HAL_GPIO_WritePin
 343              	.LVL22:
 116:Src/motor.c   **** 		default:
 344              		.loc 1 116 4 view .LVU92
 118:Src/motor.c   **** 	}
 345              		.loc 1 118 4 view .LVU93
 346              		.loc 1 120 1 is_stmt 0 view .LVU94
 347 0038 E8E7     		b	.L10
 348              		.cfi_endproc
 349              	.LFE47:
 351              		.section	.text.set_Forward,"ax",%progbits
 352              		.align	1
 353              		.global	set_Forward
 354              		.syntax unified
 355              		.code	16
 356              		.thumb_func
 358              	set_Forward:
 359              	.LFB48:
 121:Src/motor.c   **** 
 122:Src/motor.c   **** //Experimentation led to this 91 number for driving straight.
 123:Src/motor.c   **** volatile uint8_t pwm_right = 100;
 124:Src/motor.c   **** volatile uint8_t pwm_left = 100;
 125:Src/motor.c   **** 
 126:Src/motor.c   **** void set_Forward(){
 360              		.loc 1 126 19 is_stmt 1 view -0
 361              		.cfi_startproc
 362              		@ args = 0, pretend = 0, frame = 0
 363              		@ frame_needed = 0, uses_anonymous_args = 0
 364 0000 10B5     		push	{r4, lr}
 365              	.LCFI4:
 366              		.cfi_def_cfa_offset 8
 367              		.cfi_offset 4, -8
 368              		.cfi_offset 14, -4
 127:Src/motor.c   **** 	//left go forward
 128:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
 369              		.loc 1 128 2 view .LVU96
 370 0002 0949     		ldr	r1, .L15
 371 0004 0020     		movs	r0, #0
 372 0006 FFF7FEFF 		bl	set_Motor_Direction
 373              	.LVL23:
 129:Src/motor.c   **** 
 130:Src/motor.c   **** 	//right go forward
 131:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 374              		.loc 1 131 2 view .LVU97
 375 000a 0849     		ldr	r1, .L15+4
 376 000c 0020     		movs	r0, #0
 377 000e FFF7FEFF 		bl	set_Motor_Direction
 378              	.LVL24:
 132:Src/motor.c   **** 
 133:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
ARM GAS  /tmp/cchCdSqb.s 			page 10


 379              		.loc 1 133 2 view .LVU98
 380 0012 074B     		ldr	r3, .L15+8
 381 0014 1878     		ldrb	r0, [r3]
 382 0016 C0B2     		uxtb	r0, r0
 383 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 384              	.LVL25:
 134:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 385              		.loc 1 134 2 view .LVU99
 386 001c 054B     		ldr	r3, .L15+12
 387 001e 1878     		ldrb	r0, [r3]
 388 0020 C0B2     		uxtb	r0, r0
 389 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 390              	.LVL26:
 135:Src/motor.c   **** 
 136:Src/motor.c   **** 
 137:Src/motor.c   **** 	/* the old way
 138:Src/motor.c   **** 		GPIOA->ODR |= (1 << 5);
 139:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 8);
 140:Src/motor.c   **** 		GPIOB->ODR |= (1 << 10);
 141:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 2);
 142:Src/motor.c   **** 	*/
 143:Src/motor.c   **** }
 391              		.loc 1 143 1 is_stmt 0 view .LVU100
 392              		@ sp needed
 393 0026 10BD     		pop	{r4, pc}
 394              	.L16:
 395              		.align	2
 396              	.L15:
 397 0028 00000000 		.word	motor_left_pins
 398 002c 00000000 		.word	motor_right_pins
 399 0030 00000000 		.word	pwm_right
 400 0034 00000000 		.word	pwm_left
 401              		.cfi_endproc
 402              	.LFE48:
 404              		.section	.text.set_Backward,"ax",%progbits
 405              		.align	1
 406              		.global	set_Backward
 407              		.syntax unified
 408              		.code	16
 409              		.thumb_func
 411              	set_Backward:
 412              	.LFB49:
 144:Src/motor.c   **** 
 145:Src/motor.c   **** void set_Backward(){
 413              		.loc 1 145 20 is_stmt 1 view -0
 414              		.cfi_startproc
 415              		@ args = 0, pretend = 0, frame = 0
 416              		@ frame_needed = 0, uses_anonymous_args = 0
 417 0000 10B5     		push	{r4, lr}
 418              	.LCFI5:
 419              		.cfi_def_cfa_offset 8
 420              		.cfi_offset 4, -8
 421              		.cfi_offset 14, -4
 146:Src/motor.c   **** 	//left go backward
 147:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 422              		.loc 1 147 2 view .LVU102
 423 0002 0949     		ldr	r1, .L18
ARM GAS  /tmp/cchCdSqb.s 			page 11


 424 0004 0320     		movs	r0, #3
 425 0006 FFF7FEFF 		bl	set_Motor_Direction
 426              	.LVL27:
 148:Src/motor.c   **** 
 149:Src/motor.c   **** 	//right go backward
 150:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 427              		.loc 1 150 2 view .LVU103
 428 000a 0849     		ldr	r1, .L18+4
 429 000c 0320     		movs	r0, #3
 430 000e FFF7FEFF 		bl	set_Motor_Direction
 431              	.LVL28:
 151:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
 432              		.loc 1 151 2 view .LVU104
 433 0012 074B     		ldr	r3, .L18+8
 434 0014 1878     		ldrb	r0, [r3]
 435 0016 C0B2     		uxtb	r0, r0
 436 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 437              	.LVL29:
 152:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 438              		.loc 1 152 2 view .LVU105
 439 001c 054B     		ldr	r3, .L18+12
 440 001e 1878     		ldrb	r0, [r3]
 441 0020 C0B2     		uxtb	r0, r0
 442 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 443              	.LVL30:
 153:Src/motor.c   **** 	/* the old way
 154:Src/motor.c   **** 		GPIOA->ODR |= (1 << 8);
 155:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 5);
 156:Src/motor.c   **** 		GPIOB->ODR |= (1 << 2);
 157:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 10);
 158:Src/motor.c   **** 	*/
 159:Src/motor.c   **** }
 444              		.loc 1 159 1 is_stmt 0 view .LVU106
 445              		@ sp needed
 446 0026 10BD     		pop	{r4, pc}
 447              	.L19:
 448              		.align	2
 449              	.L18:
 450 0028 00000000 		.word	motor_left_pins
 451 002c 00000000 		.word	motor_right_pins
 452 0030 00000000 		.word	pwm_right
 453 0034 00000000 		.word	pwm_left
 454              		.cfi_endproc
 455              	.LFE49:
 457              		.section	.text.set_Right,"ax",%progbits
 458              		.align	1
 459              		.global	set_Right
 460              		.syntax unified
 461              		.code	16
 462              		.thumb_func
 464              	set_Right:
 465              	.LFB50:
 160:Src/motor.c   **** 
 161:Src/motor.c   **** void set_Right(){
 466              		.loc 1 161 17 is_stmt 1 view -0
 467              		.cfi_startproc
 468              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cchCdSqb.s 			page 12


 469              		@ frame_needed = 0, uses_anonymous_args = 0
 470 0000 10B5     		push	{r4, lr}
 471              	.LCFI6:
 472              		.cfi_def_cfa_offset 8
 473              		.cfi_offset 4, -8
 474              		.cfi_offset 14, -4
 162:Src/motor.c   **** 	//left go forward
 163:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_left_pins);
 475              		.loc 1 163 2 view .LVU108
 476 0002 0949     		ldr	r1, .L21
 477 0004 0020     		movs	r0, #0
 478 0006 FFF7FEFF 		bl	set_Motor_Direction
 479              	.LVL31:
 164:Src/motor.c   **** 
 165:Src/motor.c   **** 	//right go backward
 166:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_right_pins);
 480              		.loc 1 166 2 view .LVU109
 481 000a 0849     		ldr	r1, .L21+4
 482 000c 0320     		movs	r0, #3
 483 000e FFF7FEFF 		bl	set_Motor_Direction
 484              	.LVL32:
 167:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
 485              		.loc 1 167 2 view .LVU110
 486 0012 074B     		ldr	r3, .L21+8
 487 0014 1878     		ldrb	r0, [r3]
 488 0016 C0B2     		uxtb	r0, r0
 489 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 490              	.LVL33:
 168:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 491              		.loc 1 168 2 view .LVU111
 492 001c 054B     		ldr	r3, .L21+12
 493 001e 1878     		ldrb	r0, [r3]
 494 0020 C0B2     		uxtb	r0, r0
 495 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 496              	.LVL34:
 169:Src/motor.c   **** 	/* old way
 170:Src/motor.c   **** 		GPIOA->ODR |= (1 << 5);
 171:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 8);
 172:Src/motor.c   **** 		GPIOB->ODR |= (1 << 2);
 173:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 10);
 174:Src/motor.c   **** 	*/
 175:Src/motor.c   **** }
 497              		.loc 1 175 1 is_stmt 0 view .LVU112
 498              		@ sp needed
 499 0026 10BD     		pop	{r4, pc}
 500              	.L22:
 501              		.align	2
 502              	.L21:
 503 0028 00000000 		.word	motor_left_pins
 504 002c 00000000 		.word	motor_right_pins
 505 0030 00000000 		.word	pwm_right
 506 0034 00000000 		.word	pwm_left
 507              		.cfi_endproc
 508              	.LFE50:
 510              		.section	.text.set_Left,"ax",%progbits
 511              		.align	1
 512              		.global	set_Left
ARM GAS  /tmp/cchCdSqb.s 			page 13


 513              		.syntax unified
 514              		.code	16
 515              		.thumb_func
 517              	set_Left:
 518              	.LFB51:
 176:Src/motor.c   **** 
 177:Src/motor.c   **** void set_Left(){
 519              		.loc 1 177 16 is_stmt 1 view -0
 520              		.cfi_startproc
 521              		@ args = 0, pretend = 0, frame = 0
 522              		@ frame_needed = 0, uses_anonymous_args = 0
 523 0000 10B5     		push	{r4, lr}
 524              	.LCFI7:
 525              		.cfi_def_cfa_offset 8
 526              		.cfi_offset 4, -8
 527              		.cfi_offset 14, -4
 178:Src/motor.c   **** 	//left go backward
 179:Src/motor.c   **** 	set_Motor_Direction(BACKWARD, &motor_left_pins);
 528              		.loc 1 179 2 view .LVU114
 529 0002 0949     		ldr	r1, .L24
 530 0004 0320     		movs	r0, #3
 531 0006 FFF7FEFF 		bl	set_Motor_Direction
 532              	.LVL35:
 180:Src/motor.c   **** 	
 181:Src/motor.c   **** 	//right go forward
 182:Src/motor.c   **** 	set_Motor_Direction(FORWARD, &motor_right_pins);
 533              		.loc 1 182 2 view .LVU115
 534 000a 0849     		ldr	r1, .L24+4
 535 000c 0020     		movs	r0, #0
 536 000e FFF7FEFF 		bl	set_Motor_Direction
 537              	.LVL36:
 183:Src/motor.c   **** 
 184:Src/motor.c   **** 	pwm_setDutyCycleR(pwm_right);
 538              		.loc 1 184 2 view .LVU116
 539 0012 074B     		ldr	r3, .L24+8
 540 0014 1878     		ldrb	r0, [r3]
 541 0016 C0B2     		uxtb	r0, r0
 542 0018 FFF7FEFF 		bl	pwm_setDutyCycleR
 543              	.LVL37:
 185:Src/motor.c   **** 	pwm_setDutyCycleL(pwm_left);
 544              		.loc 1 185 2 view .LVU117
 545 001c 054B     		ldr	r3, .L24+12
 546 001e 1878     		ldrb	r0, [r3]
 547 0020 C0B2     		uxtb	r0, r0
 548 0022 FFF7FEFF 		bl	pwm_setDutyCycleL
 549              	.LVL38:
 186:Src/motor.c   **** 	/*
 187:Src/motor.c   **** 		GPIOA->ODR |= (1 << 8);
 188:Src/motor.c   **** 		GPIOA->ODR &= ~(1 << 5);
 189:Src/motor.c   **** 		GPIOB->ODR |= (1 << 10);
 190:Src/motor.c   **** 		GPIOB->ODR &= ~(1 << 2);
 191:Src/motor.c   **** 	*/
 192:Src/motor.c   **** }
 550              		.loc 1 192 1 is_stmt 0 view .LVU118
 551              		@ sp needed
 552 0026 10BD     		pop	{r4, pc}
 553              	.L25:
ARM GAS  /tmp/cchCdSqb.s 			page 14


 554              		.align	2
 555              	.L24:
 556 0028 00000000 		.word	motor_left_pins
 557 002c 00000000 		.word	motor_right_pins
 558 0030 00000000 		.word	pwm_right
 559 0034 00000000 		.word	pwm_left
 560              		.cfi_endproc
 561              	.LFE51:
 563              		.section	.text.motors_Off,"ax",%progbits
 564              		.align	1
 565              		.global	motors_Off
 566              		.syntax unified
 567              		.code	16
 568              		.thumb_func
 570              	motors_Off:
 571              	.LFB52:
 193:Src/motor.c   **** 
 194:Src/motor.c   **** void motors_Off(){
 572              		.loc 1 194 18 is_stmt 1 view -0
 573              		.cfi_startproc
 574              		@ args = 0, pretend = 0, frame = 0
 575              		@ frame_needed = 0, uses_anonymous_args = 0
 576 0000 10B5     		push	{r4, lr}
 577              	.LCFI8:
 578              		.cfi_def_cfa_offset 8
 579              		.cfi_offset 4, -8
 580              		.cfi_offset 14, -4
 195:Src/motor.c   **** 	pwm_setDutyCycleR(0);
 581              		.loc 1 195 2 view .LVU120
 582 0002 0020     		movs	r0, #0
 583 0004 FFF7FEFF 		bl	pwm_setDutyCycleR
 584              	.LVL39:
 196:Src/motor.c   **** 	pwm_setDutyCycleL(0);
 585              		.loc 1 196 2 view .LVU121
 586 0008 0020     		movs	r0, #0
 587 000a FFF7FEFF 		bl	pwm_setDutyCycleL
 588              	.LVL40:
 197:Src/motor.c   **** }
 589              		.loc 1 197 1 is_stmt 0 view .LVU122
 590              		@ sp needed
 591 000e 10BD     		pop	{r4, pc}
 592              		.cfi_endproc
 593              	.LFE52:
 595              		.section	.text.encoder_init,"ax",%progbits
 596              		.align	1
 597              		.global	encoder_init
 598              		.syntax unified
 599              		.code	16
 600              		.thumb_func
 602              	encoder_init:
 603              	.LFB54:
 198:Src/motor.c   **** 
 199:Src/motor.c   **** uint8_t* MoveMotors(MotorCommand* cmd){
 200:Src/motor.c   **** 	motors_Off();
 201:Src/motor.c   **** 	uint8_t* err = "MoveMotors executed!\n";
 202:Src/motor.c   **** 	switch(cmd->dir){
 203:Src/motor.c   **** 		case FORWARD:
ARM GAS  /tmp/cchCdSqb.s 			page 15


 204:Src/motor.c   **** 			turning = false;
 205:Src/motor.c   **** 			target_dist = cmd->amount;
 206:Src/motor.c   **** 			set_Forward();
 207:Src/motor.c   **** 			break;
 208:Src/motor.c   **** 		case LEFT:
 209:Src/motor.c   **** 			turning = true;
 210:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 211:Src/motor.c   **** 			heading += cmd->amount;
 212:Src/motor.c   **** 			set_Left();
 213:Src/motor.c   **** 			break;
 214:Src/motor.c   **** 		case RIGHT:
 215:Src/motor.c   **** 			turning = true;
 216:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 217:Src/motor.c   **** 			heading -= cmd->amount;
 218:Src/motor.c   **** 			set_Right();
 219:Src/motor.c   **** 			break;
 220:Src/motor.c   **** 		case OFF:
 221:Src/motor.c   **** 			motors_Off();
 222:Src/motor.c   **** 			break;
 223:Src/motor.c   **** 		default:
 224:Src/motor.c   **** 			err = "Invalid command to MoveMotors!\n";
 225:Src/motor.c   **** 	}
 226:Src/motor.c   **** 	//THIS IS BAD. if you send an x it won't stop motors until this delay finishes!
 227:Src/motor.c   **** 	//Switch to a polling structure instead for final
 228:Src/motor.c   **** 	while(get_distance() < target_dist)
 229:Src/motor.c   **** 		;
 230:Src/motor.c   **** 	motors_Off();
 231:Src/motor.c   **** 	return err;
 232:Src/motor.c   **** }
 233:Src/motor.c   **** 
 234:Src/motor.c   **** // Sets up encoder interface to read motor speed
 235:Src/motor.c   **** void encoder_init(void) {
 604              		.loc 1 235 25 is_stmt 1 view -0
 605              		.cfi_startproc
 606              		@ args = 0, pretend = 0, frame = 0
 607              		@ frame_needed = 0, uses_anonymous_args = 0
 608 0000 70B5     		push	{r4, r5, r6, lr}
 609              	.LCFI9:
 610              		.cfi_def_cfa_offset 16
 611              		.cfi_offset 4, -16
 612              		.cfi_offset 5, -12
 613              		.cfi_offset 6, -8
 614              		.cfi_offset 14, -4
 236:Src/motor.c   ****     
 237:Src/motor.c   ****     // Set up encoder input pins (TIMER 3 CH1 and CH2)
 238:Src/motor.c   **** 	/*
 239:Src/motor.c   ****     GPIOB->MODER &= ~(GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0);
 240:Src/motor.c   ****     GPIOB->MODER |= (GPIO_MODER_MODER4_1 | GPIO_MODER_MODER5_1);
 241:Src/motor.c   ****     GPIOB->AFR[0] |= ( (1 << 16) | (1 << 20) );
 242:Src/motor.c   **** 		
 243:Src/motor.c   **** 		// Set up encoder input pins (TIMER 15 CH1 and CH2)
 244:Src/motor.c   **** 		GPIOB->MODER &= ~(GPIO_MODER_MODER14_0 | GPIO_MODER_MODER15_0);
 245:Src/motor.c   ****     GPIOB->MODER |= (GPIO_MODER_MODER14_1 | GPIO_MODER_MODER15_1);
 246:Src/motor.c   ****     GPIOB->AFR[1] |= ( (1 << 24) | (1 << 28) );
 247:Src/motor.c   **** 	*/
 248:Src/motor.c   **** 
 249:Src/motor.c   ****     // Set up encoder interface (TIM3 encoder input mode)
ARM GAS  /tmp/cchCdSqb.s 			page 16


 250:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
 615              		.loc 1 250 5 view .LVU124
 616              		.loc 1 250 8 is_stmt 0 view .LVU125
 617 0002 204A     		ldr	r2, .L28
 618 0004 D369     		ldr	r3, [r2, #28]
 619              		.loc 1 250 18 view .LVU126
 620 0006 0221     		movs	r1, #2
 621 0008 0B43     		orrs	r3, r1
 622 000a D361     		str	r3, [r2, #28]
 251:Src/motor.c   ****     TIM3->CCMR1 = 0;
 623              		.loc 1 251 5 is_stmt 1 view .LVU127
 624              		.loc 1 251 17 is_stmt 0 view .LVU128
 625 000c 1E4B     		ldr	r3, .L28+4
 626 000e 0021     		movs	r1, #0
 627 0010 9961     		str	r1, [r3, #24]
 252:Src/motor.c   ****     TIM3->CCER = 0;
 628              		.loc 1 252 5 is_stmt 1 view .LVU129
 629              		.loc 1 252 16 is_stmt 0 view .LVU130
 630 0012 1962     		str	r1, [r3, #32]
 253:Src/motor.c   ****     TIM3->SMCR = 0;
 631              		.loc 1 253 5 is_stmt 1 view .LVU131
 632              		.loc 1 253 16 is_stmt 0 view .LVU132
 633 0014 9960     		str	r1, [r3, #8]
 254:Src/motor.c   ****     TIM3->CR1 = 0;
 634              		.loc 1 254 5 is_stmt 1 view .LVU133
 635              		.loc 1 254 15 is_stmt 0 view .LVU134
 636 0016 1960     		str	r1, [r3]
 255:Src/motor.c   **** 
 256:Src/motor.c   ****     TIM3->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected 
 637              		.loc 1 256 5 is_stmt 1 view .LVU135
 638              		.loc 1 256 9 is_stmt 0 view .LVU136
 639 0018 9869     		ldr	r0, [r3, #24]
 640              		.loc 1 256 17 view .LVU137
 641 001a 0221     		movs	r1, #2
 642 001c FF31     		adds	r1, r1, #255
 643 001e 0843     		orrs	r0, r1
 644 0020 9861     		str	r0, [r3, #24]
 257:Src/motor.c   ****     TIM3->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and f
 645              		.loc 1 257 5 is_stmt 1 view .LVU138
 646              		.loc 1 257 9 is_stmt 0 view .LVU139
 647 0022 9868     		ldr	r0, [r3, #8]
 648              		.loc 1 257 16 view .LVU140
 649 0024 0325     		movs	r5, #3
 650 0026 2843     		orrs	r0, r5
 651 0028 9860     		str	r0, [r3, #8]
 258:Src/motor.c   ****     TIM3->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest pos
 652              		.loc 1 258 5 is_stmt 1 view .LVU141
 653              		.loc 1 258 15 is_stmt 0 view .LVU142
 654 002a 184C     		ldr	r4, .L28+8
 655 002c DC62     		str	r4, [r3, #44]
 259:Src/motor.c   ****     TIM3->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negati
 656              		.loc 1 259 5 is_stmt 1 view .LVU143
 657              		.loc 1 259 15 is_stmt 0 view .LVU144
 658 002e 1848     		ldr	r0, .L28+12
 659 0030 5862     		str	r0, [r3, #36]
 260:Src/motor.c   ****     // (Could also cast unsigned register to signed number to get negative numbers if it rotates ba
 261:Src/motor.c   ****     //  just another option, the mid-bias is a bit simpler to understand though.)
ARM GAS  /tmp/cchCdSqb.s 			page 17


 262:Src/motor.c   ****     /* TIM3->CR1 |= TIM_CR1_CEN;                               // Enable timer */
 263:Src/motor.c   **** 		
 264:Src/motor.c   **** 
 265:Src/motor.c   ****     TIM3->CCMR2 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected 
 660              		.loc 1 265 5 is_stmt 1 view .LVU145
 661              		.loc 1 265 9 is_stmt 0 view .LVU146
 662 0032 DE69     		ldr	r6, [r3, #28]
 663              		.loc 1 265 17 view .LVU147
 664 0034 3143     		orrs	r1, r6
 665 0036 D961     		str	r1, [r3, #28]
 266:Src/motor.c   ****     TIM3->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and f
 666              		.loc 1 266 5 is_stmt 1 view .LVU148
 667              		.loc 1 266 9 is_stmt 0 view .LVU149
 668 0038 9968     		ldr	r1, [r3, #8]
 669              		.loc 1 266 16 view .LVU150
 670 003a 2943     		orrs	r1, r5
 671 003c 9960     		str	r1, [r3, #8]
 267:Src/motor.c   ****     TIM3->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest pos
 672              		.loc 1 267 5 is_stmt 1 view .LVU151
 673              		.loc 1 267 15 is_stmt 0 view .LVU152
 674 003e DC62     		str	r4, [r3, #44]
 268:Src/motor.c   ****     TIM3->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negati
 675              		.loc 1 268 5 is_stmt 1 view .LVU153
 676              		.loc 1 268 15 is_stmt 0 view .LVU154
 677 0040 5862     		str	r0, [r3, #36]
 269:Src/motor.c   ****     // (Could also cast unsigned register to signed number to get negative numbers if it rotates ba
 270:Src/motor.c   ****     //  just another option, the mid-bias is a bit simpler to understand though.)
 271:Src/motor.c   ****     TIM3->CR1 |= TIM_CR1_CEN;     
 678              		.loc 1 271 5 is_stmt 1 view .LVU155
 679              		.loc 1 271 9 is_stmt 0 view .LVU156
 680 0042 1868     		ldr	r0, [r3]
 681              		.loc 1 271 15 view .LVU157
 682 0044 0121     		movs	r1, #1
 683 0046 0843     		orrs	r0, r1
 684 0048 1860     		str	r0, [r3]
 272:Src/motor.c   **** 
 273:Src/motor.c   ****     // Configure a second timer (TIM6) to fire an ISR on update event
 274:Src/motor.c   ****     // Used to periodically check and update speed variable
 275:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
 685              		.loc 1 275 5 is_stmt 1 view .LVU158
 686              		.loc 1 275 8 is_stmt 0 view .LVU159
 687 004a D369     		ldr	r3, [r2, #28]
 688              		.loc 1 275 18 view .LVU160
 689 004c 1020     		movs	r0, #16
 690 004e 0343     		orrs	r3, r0
 691 0050 D361     		str	r3, [r2, #28]
 276:Src/motor.c   ****     
 277:Src/motor.c   ****     // Select PSC and ARR values that give an appropriate interrupt rate
 278:Src/motor.c   ****     TIM6->PSC = 11;
 692              		.loc 1 278 5 is_stmt 1 view .LVU161
 693              		.loc 1 278 15 is_stmt 0 view .LVU162
 694 0052 104B     		ldr	r3, .L28+16
 695 0054 0B22     		movs	r2, #11
 696 0056 9A62     		str	r2, [r3, #40]
 279:Src/motor.c   ****     TIM6->ARR = 30000;
 697              		.loc 1 279 5 is_stmt 1 view .LVU163
 698              		.loc 1 279 15 is_stmt 0 view .LVU164
ARM GAS  /tmp/cchCdSqb.s 			page 18


 699 0058 0F4A     		ldr	r2, .L28+20
 700 005a DA62     		str	r2, [r3, #44]
 280:Src/motor.c   ****     
 281:Src/motor.c   ****     TIM6->DIER |= TIM_DIER_UIE;             // Enable update event interrupt
 701              		.loc 1 281 5 is_stmt 1 view .LVU165
 702              		.loc 1 281 9 is_stmt 0 view .LVU166
 703 005c DA68     		ldr	r2, [r3, #12]
 704              		.loc 1 281 16 view .LVU167
 705 005e 0A43     		orrs	r2, r1
 706 0060 DA60     		str	r2, [r3, #12]
 282:Src/motor.c   ****     TIM6->CR1 |= TIM_CR1_CEN;               // Enable Timer
 707              		.loc 1 282 5 is_stmt 1 view .LVU168
 708              		.loc 1 282 9 is_stmt 0 view .LVU169
 709 0062 1A68     		ldr	r2, [r3]
 710              		.loc 1 282 15 view .LVU170
 711 0064 0A43     		orrs	r2, r1
 712 0066 1A60     		str	r2, [r3]
 283:Src/motor.c   **** 
 284:Src/motor.c   ****     NVIC_EnableIRQ(TIM6_DAC_IRQn);          // Enable interrupt in NVIC
 713              		.loc 1 284 5 is_stmt 1 view .LVU171
 714              	.LVL41:
 715              	.LBB6:
 716              	.LBI6:
 717              		.file 2 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V5.0.5
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     28. May 2018
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /*
   8:Drivers/CMSIS/Include/core_cm0.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/core_cm0.h ****  *
  10:Drivers/CMSIS/Include/core_cm0.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/core_cm0.h ****  *
  12:Drivers/CMSIS/Include/core_cm0.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/core_cm0.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/core_cm0.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/core_cm0.h ****  *
  16:Drivers/CMSIS/Include/core_cm0.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/core_cm0.h ****  *
  18:Drivers/CMSIS/Include/core_cm0.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/core_cm0.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/core_cm0.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/core_cm0.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/core_cm0.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/core_cm0.h ****  */
  24:Drivers/CMSIS/Include/core_cm0.h **** 
  25:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  26:Drivers/CMSIS/Include/core_cm0.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__clang__)
  28:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  29:Drivers/CMSIS/Include/core_cm0.h **** #endif
  30:Drivers/CMSIS/Include/core_cm0.h **** 
  31:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  32:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  33:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cchCdSqb.s 			page 19


  34:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  35:Drivers/CMSIS/Include/core_cm0.h **** 
  36:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  37:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  38:Drivers/CMSIS/Include/core_cm0.h **** #endif
  39:Drivers/CMSIS/Include/core_cm0.h **** 
  40:Drivers/CMSIS/Include/core_cm0.h **** /**
  41:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  46:Drivers/CMSIS/Include/core_cm0.h **** 
  47:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  52:Drivers/CMSIS/Include/core_cm0.h ****  */
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h **** 
  55:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  56:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  57:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  58:Drivers/CMSIS/Include/core_cm0.h **** /**
  59:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  60:Drivers/CMSIS/Include/core_cm0.h ****   @{
  61:Drivers/CMSIS/Include/core_cm0.h ****  */
  62:Drivers/CMSIS/Include/core_cm0.h **** 
  63:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_version.h"
  64:Drivers/CMSIS/Include/core_cm0.h ****  
  65:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  66:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  69:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:Drivers/CMSIS/Include/core_cm0.h **** 
  71:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
  75:Drivers/CMSIS/Include/core_cm0.h **** */
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
  77:Drivers/CMSIS/Include/core_cm0.h **** 
  78:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
  79:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
  80:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  82:Drivers/CMSIS/Include/core_cm0.h **** 
  83:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
  85:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  87:Drivers/CMSIS/Include/core_cm0.h **** 
  88:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  89:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
ARM GAS  /tmp/cchCdSqb.s 			page 20


  91:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  92:Drivers/CMSIS/Include/core_cm0.h **** 
  93:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  94:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
  95:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  97:Drivers/CMSIS/Include/core_cm0.h **** 
  98:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TI_ARM__ )
  99:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 100:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 102:Drivers/CMSIS/Include/core_cm0.h **** 
 103:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 104:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 105:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 107:Drivers/CMSIS/Include/core_cm0.h **** 
 108:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 109:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 110:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 112:Drivers/CMSIS/Include/core_cm0.h **** 
 113:Drivers/CMSIS/Include/core_cm0.h **** #endif
 114:Drivers/CMSIS/Include/core_cm0.h **** 
 115:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** 
 118:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 119:Drivers/CMSIS/Include/core_cm0.h **** }
 120:Drivers/CMSIS/Include/core_cm0.h **** #endif
 121:Drivers/CMSIS/Include/core_cm0.h **** 
 122:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 123:Drivers/CMSIS/Include/core_cm0.h **** 
 124:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 127:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 128:Drivers/CMSIS/Include/core_cm0.h **** 
 129:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 130:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 131:Drivers/CMSIS/Include/core_cm0.h **** #endif
 132:Drivers/CMSIS/Include/core_cm0.h **** 
 133:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 134:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 135:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 136:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 137:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 138:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 139:Drivers/CMSIS/Include/core_cm0.h **** 
 140:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 141:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 142:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 143:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 144:Drivers/CMSIS/Include/core_cm0.h **** 
 145:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 146:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 147:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
ARM GAS  /tmp/cchCdSqb.s 			page 21


 148:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 149:Drivers/CMSIS/Include/core_cm0.h **** #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 152:Drivers/CMSIS/Include/core_cm0.h **** /**
 153:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 154:Drivers/CMSIS/Include/core_cm0.h **** 
 155:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 156:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 157:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 158:Drivers/CMSIS/Include/core_cm0.h **** */
 159:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 160:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 161:Drivers/CMSIS/Include/core_cm0.h **** #else
 162:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 163:Drivers/CMSIS/Include/core_cm0.h **** #endif
 164:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 165:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 166:Drivers/CMSIS/Include/core_cm0.h **** 
 167:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 168:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 169:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 170:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** 
 175:Drivers/CMSIS/Include/core_cm0.h **** 
 176:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 177:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 178:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 179:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 180:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 181:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 182:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 183:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 184:Drivers/CMSIS/Include/core_cm0.h **** /**
 185:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 186:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 187:Drivers/CMSIS/Include/core_cm0.h **** */
 188:Drivers/CMSIS/Include/core_cm0.h **** 
 189:Drivers/CMSIS/Include/core_cm0.h **** /**
 190:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 191:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 192:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 193:Drivers/CMSIS/Include/core_cm0.h ****   @{
 194:Drivers/CMSIS/Include/core_cm0.h ****  */
 195:Drivers/CMSIS/Include/core_cm0.h **** 
 196:Drivers/CMSIS/Include/core_cm0.h **** /**
 197:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 198:Drivers/CMSIS/Include/core_cm0.h ****  */
 199:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 200:Drivers/CMSIS/Include/core_cm0.h **** {
 201:Drivers/CMSIS/Include/core_cm0.h ****   struct
 202:Drivers/CMSIS/Include/core_cm0.h ****   {
 203:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 204:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
ARM GAS  /tmp/cchCdSqb.s 			page 22


 205:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 206:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 207:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 208:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 209:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 210:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 211:Drivers/CMSIS/Include/core_cm0.h **** 
 212:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 214:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 215:Drivers/CMSIS/Include/core_cm0.h **** 
 216:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 217:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 218:Drivers/CMSIS/Include/core_cm0.h **** 
 219:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 220:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 223:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 224:Drivers/CMSIS/Include/core_cm0.h **** 
 225:Drivers/CMSIS/Include/core_cm0.h **** 
 226:Drivers/CMSIS/Include/core_cm0.h **** /**
 227:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 228:Drivers/CMSIS/Include/core_cm0.h ****  */
 229:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 230:Drivers/CMSIS/Include/core_cm0.h **** {
 231:Drivers/CMSIS/Include/core_cm0.h ****   struct
 232:Drivers/CMSIS/Include/core_cm0.h ****   {
 233:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 234:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 235:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 236:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 237:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 238:Drivers/CMSIS/Include/core_cm0.h **** 
 239:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 240:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 241:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 242:Drivers/CMSIS/Include/core_cm0.h **** 
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 257:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 258:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 259:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 260:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 261:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
ARM GAS  /tmp/cchCdSqb.s 			page 23


 262:Drivers/CMSIS/Include/core_cm0.h **** 
 263:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 264:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 268:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 274:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 275:Drivers/CMSIS/Include/core_cm0.h **** 
 276:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 277:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 278:Drivers/CMSIS/Include/core_cm0.h **** 
 279:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 280:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 281:Drivers/CMSIS/Include/core_cm0.h **** 
 282:Drivers/CMSIS/Include/core_cm0.h **** 
 283:Drivers/CMSIS/Include/core_cm0.h **** /**
 284:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 285:Drivers/CMSIS/Include/core_cm0.h ****  */
 286:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 287:Drivers/CMSIS/Include/core_cm0.h **** {
 288:Drivers/CMSIS/Include/core_cm0.h ****   struct
 289:Drivers/CMSIS/Include/core_cm0.h ****   {
 290:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 291:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 292:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 293:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 294:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 295:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 296:Drivers/CMSIS/Include/core_cm0.h **** 
 297:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 298:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 299:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 300:Drivers/CMSIS/Include/core_cm0.h **** 
 301:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 302:Drivers/CMSIS/Include/core_cm0.h **** 
 303:Drivers/CMSIS/Include/core_cm0.h **** 
 304:Drivers/CMSIS/Include/core_cm0.h **** /**
 305:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 306:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 307:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 308:Drivers/CMSIS/Include/core_cm0.h ****   @{
 309:Drivers/CMSIS/Include/core_cm0.h ****  */
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /**
 312:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 313:Drivers/CMSIS/Include/core_cm0.h ****  */
 314:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 315:Drivers/CMSIS/Include/core_cm0.h **** {
 316:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 317:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 318:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
ARM GAS  /tmp/cchCdSqb.s 			page 24


 319:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 320:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 321:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 322:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 323:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 324:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 325:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 326:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 327:Drivers/CMSIS/Include/core_cm0.h **** 
 328:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 333:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 334:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 335:Drivers/CMSIS/Include/core_cm0.h ****   @{
 336:Drivers/CMSIS/Include/core_cm0.h ****  */
 337:Drivers/CMSIS/Include/core_cm0.h **** 
 338:Drivers/CMSIS/Include/core_cm0.h **** /**
 339:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 340:Drivers/CMSIS/Include/core_cm0.h ****  */
 341:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 342:Drivers/CMSIS/Include/core_cm0.h **** {
 343:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 344:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 345:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 346:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 347:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 348:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 349:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 350:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 351:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 352:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 353:Drivers/CMSIS/Include/core_cm0.h **** 
 354:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 355:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 356:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 357:Drivers/CMSIS/Include/core_cm0.h **** 
 358:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 359:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 360:Drivers/CMSIS/Include/core_cm0.h **** 
 361:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 362:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 363:Drivers/CMSIS/Include/core_cm0.h **** 
 364:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 365:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 366:Drivers/CMSIS/Include/core_cm0.h **** 
 367:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 368:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 369:Drivers/CMSIS/Include/core_cm0.h **** 
 370:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 371:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 372:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 373:Drivers/CMSIS/Include/core_cm0.h **** 
 374:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 375:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
ARM GAS  /tmp/cchCdSqb.s 			page 25


 376:Drivers/CMSIS/Include/core_cm0.h **** 
 377:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 378:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 379:Drivers/CMSIS/Include/core_cm0.h **** 
 380:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 381:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 382:Drivers/CMSIS/Include/core_cm0.h **** 
 383:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 384:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 387:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 388:Drivers/CMSIS/Include/core_cm0.h **** 
 389:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 390:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 391:Drivers/CMSIS/Include/core_cm0.h **** 
 392:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 393:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 394:Drivers/CMSIS/Include/core_cm0.h **** 
 395:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 396:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 397:Drivers/CMSIS/Include/core_cm0.h **** 
 398:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 399:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 400:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** 
 405:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** 
 408:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** 
 411:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** 
 414:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** 
 421:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** 
 424:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
ARM GAS  /tmp/cchCdSqb.s 			page 26


 433:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 434:Drivers/CMSIS/Include/core_cm0.h **** 
 435:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** 
 438:Drivers/CMSIS/Include/core_cm0.h **** /**
 439:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 440:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 441:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 442:Drivers/CMSIS/Include/core_cm0.h ****   @{
 443:Drivers/CMSIS/Include/core_cm0.h ****  */
 444:Drivers/CMSIS/Include/core_cm0.h **** 
 445:Drivers/CMSIS/Include/core_cm0.h **** /**
 446:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 447:Drivers/CMSIS/Include/core_cm0.h ****  */
 448:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 449:Drivers/CMSIS/Include/core_cm0.h **** {
 450:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 451:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 452:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 453:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 454:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 458:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 459:Drivers/CMSIS/Include/core_cm0.h **** 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 461:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 462:Drivers/CMSIS/Include/core_cm0.h **** 
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 471:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 472:Drivers/CMSIS/Include/core_cm0.h **** 
 473:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 475:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 476:Drivers/CMSIS/Include/core_cm0.h **** 
 477:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 478:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 479:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 480:Drivers/CMSIS/Include/core_cm0.h **** 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 482:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 483:Drivers/CMSIS/Include/core_cm0.h **** 
 484:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 485:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 486:Drivers/CMSIS/Include/core_cm0.h **** 
 487:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 488:Drivers/CMSIS/Include/core_cm0.h **** 
 489:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cchCdSqb.s 			page 27


 490:Drivers/CMSIS/Include/core_cm0.h **** /**
 491:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 492:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 493:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 494:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 495:Drivers/CMSIS/Include/core_cm0.h ****   @{
 496:Drivers/CMSIS/Include/core_cm0.h ****  */
 497:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 498:Drivers/CMSIS/Include/core_cm0.h **** 
 499:Drivers/CMSIS/Include/core_cm0.h **** 
 500:Drivers/CMSIS/Include/core_cm0.h **** /**
 501:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 502:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 503:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 504:Drivers/CMSIS/Include/core_cm0.h ****   @{
 505:Drivers/CMSIS/Include/core_cm0.h ****  */
 506:Drivers/CMSIS/Include/core_cm0.h **** 
 507:Drivers/CMSIS/Include/core_cm0.h **** /**
 508:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 509:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 510:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 511:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 512:Drivers/CMSIS/Include/core_cm0.h **** */
 513:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 514:Drivers/CMSIS/Include/core_cm0.h **** 
 515:Drivers/CMSIS/Include/core_cm0.h **** /**
 516:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 517:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 518:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 519:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 520:Drivers/CMSIS/Include/core_cm0.h **** */
 521:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 522:Drivers/CMSIS/Include/core_cm0.h **** 
 523:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** 
 526:Drivers/CMSIS/Include/core_cm0.h **** /**
 527:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 528:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 529:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 530:Drivers/CMSIS/Include/core_cm0.h ****   @{
 531:Drivers/CMSIS/Include/core_cm0.h ****  */
 532:Drivers/CMSIS/Include/core_cm0.h **** 
 533:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Core Hardware */
 534:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 535:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 536:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 537:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 538:Drivers/CMSIS/Include/core_cm0.h **** 
 539:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 540:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 541:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 542:Drivers/CMSIS/Include/core_cm0.h **** 
 543:Drivers/CMSIS/Include/core_cm0.h **** 
 544:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 545:Drivers/CMSIS/Include/core_cm0.h **** 
 546:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/cchCdSqb.s 			page 28


 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 549:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 550:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 551:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 552:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 553:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 554:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 557:Drivers/CMSIS/Include/core_cm0.h **** */
 558:Drivers/CMSIS/Include/core_cm0.h **** 
 559:Drivers/CMSIS/Include/core_cm0.h **** 
 560:Drivers/CMSIS/Include/core_cm0.h **** 
 561:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 562:Drivers/CMSIS/Include/core_cm0.h **** /**
 563:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 564:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 565:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 566:Drivers/CMSIS/Include/core_cm0.h ****   @{
 567:Drivers/CMSIS/Include/core_cm0.h ****  */
 568:Drivers/CMSIS/Include/core_cm0.h **** 
 569:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_NVIC_VIRTUAL
 570:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 571:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 572:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 573:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 574:Drivers/CMSIS/Include/core_cm0.h **** #else
 575:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
 576:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
 577:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 578:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 579:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 580:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 581:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 582:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 583:Drivers/CMSIS/Include/core_cm0.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
 584:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 585:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 586:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 587:Drivers/CMSIS/Include/core_cm0.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 588:Drivers/CMSIS/Include/core_cm0.h **** 
 589:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 590:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 591:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 592:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 593:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 594:Drivers/CMSIS/Include/core_cm0.h **** #else
 595:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetVector              __NVIC_SetVector
 596:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetVector              __NVIC_GetVector
 597:Drivers/CMSIS/Include/core_cm0.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 598:Drivers/CMSIS/Include/core_cm0.h **** 
 599:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_USER_IRQ_OFFSET          16
 600:Drivers/CMSIS/Include/core_cm0.h **** 
 601:Drivers/CMSIS/Include/core_cm0.h **** 
 602:Drivers/CMSIS/Include/core_cm0.h **** /* The following EXC_RETURN values are saved the LR on exception entry */
 603:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after ret
ARM GAS  /tmp/cchCdSqb.s 			page 29


 604:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after retu
 605:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after retu
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under Armv6-M                  */
 609:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 610:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 611:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 612:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 613:Drivers/CMSIS/Include/core_cm0.h **** 
 614:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_SetPriorityGrouping(X) (void)(X)
 615:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_GetPriorityGrouping()  (0U)
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /**
 618:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable Interrupt
 619:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 620:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 621:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 622:Drivers/CMSIS/Include/core_cm0.h ****  */
 623:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 718              		.loc 2 623 22 view .LVU172
 719              	.LBB7:
 624:Drivers/CMSIS/Include/core_cm0.h **** {
 625:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 720              		.loc 2 625 3 view .LVU173
 626:Drivers/CMSIS/Include/core_cm0.h ****   {
 627:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 721              		.loc 2 627 5 view .LVU174
 722              		.loc 2 627 20 is_stmt 0 view .LVU175
 723 0068 0C4B     		ldr	r3, .L28+24
 724 006a 8022     		movs	r2, #128
 725 006c 9202     		lsls	r2, r2, #10
 726 006e 1A60     		str	r2, [r3]
 727              	.LVL42:
 728              		.loc 2 627 20 view .LVU176
 729              	.LBE7:
 730              	.LBE6:
 285:Src/motor.c   ****     NVIC_SetPriority(TIM6_DAC_IRQn,2);
 731              		.loc 1 285 5 is_stmt 1 view .LVU177
 732              	.LBB8:
 733              	.LBI8:
 628:Drivers/CMSIS/Include/core_cm0.h ****   }
 629:Drivers/CMSIS/Include/core_cm0.h **** }
 630:Drivers/CMSIS/Include/core_cm0.h **** 
 631:Drivers/CMSIS/Include/core_cm0.h **** 
 632:Drivers/CMSIS/Include/core_cm0.h **** /**
 633:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Enable status
 634:Drivers/CMSIS/Include/core_cm0.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 635:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 636:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt is not enabled.
 637:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt is enabled.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 643:Drivers/CMSIS/Include/core_cm0.h ****   {
ARM GAS  /tmp/cchCdSqb.s 			page 30


 644:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 645:Drivers/CMSIS/Include/core_cm0.h ****   }
 646:Drivers/CMSIS/Include/core_cm0.h ****   else
 647:Drivers/CMSIS/Include/core_cm0.h ****   {
 648:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 649:Drivers/CMSIS/Include/core_cm0.h ****   }
 650:Drivers/CMSIS/Include/core_cm0.h **** }
 651:Drivers/CMSIS/Include/core_cm0.h **** 
 652:Drivers/CMSIS/Include/core_cm0.h **** 
 653:Drivers/CMSIS/Include/core_cm0.h **** /**
 654:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable Interrupt
 655:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 656:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 657:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 658:Drivers/CMSIS/Include/core_cm0.h ****  */
 659:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 660:Drivers/CMSIS/Include/core_cm0.h **** {
 661:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 662:Drivers/CMSIS/Include/core_cm0.h ****   {
 663:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 664:Drivers/CMSIS/Include/core_cm0.h ****     __DSB();
 665:Drivers/CMSIS/Include/core_cm0.h ****     __ISB();
 666:Drivers/CMSIS/Include/core_cm0.h ****   }
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 674:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 675:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 676:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 677:Drivers/CMSIS/Include/core_cm0.h ****  */
 678:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 679:Drivers/CMSIS/Include/core_cm0.h **** {
 680:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 681:Drivers/CMSIS/Include/core_cm0.h ****   {
 682:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 683:Drivers/CMSIS/Include/core_cm0.h ****   }
 684:Drivers/CMSIS/Include/core_cm0.h ****   else
 685:Drivers/CMSIS/Include/core_cm0.h ****   {
 686:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 687:Drivers/CMSIS/Include/core_cm0.h ****   }
 688:Drivers/CMSIS/Include/core_cm0.h **** }
 689:Drivers/CMSIS/Include/core_cm0.h **** 
 690:Drivers/CMSIS/Include/core_cm0.h **** 
 691:Drivers/CMSIS/Include/core_cm0.h **** /**
 692:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 693:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 694:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 695:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 696:Drivers/CMSIS/Include/core_cm0.h ****  */
 697:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 698:Drivers/CMSIS/Include/core_cm0.h **** {
 699:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 700:Drivers/CMSIS/Include/core_cm0.h ****   {
ARM GAS  /tmp/cchCdSqb.s 			page 31


 701:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 702:Drivers/CMSIS/Include/core_cm0.h ****   }
 703:Drivers/CMSIS/Include/core_cm0.h **** }
 704:Drivers/CMSIS/Include/core_cm0.h **** 
 705:Drivers/CMSIS/Include/core_cm0.h **** 
 706:Drivers/CMSIS/Include/core_cm0.h **** /**
 707:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 708:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 710:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 715:Drivers/CMSIS/Include/core_cm0.h ****   {
 716:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 717:Drivers/CMSIS/Include/core_cm0.h ****   }
 718:Drivers/CMSIS/Include/core_cm0.h **** }
 719:Drivers/CMSIS/Include/core_cm0.h **** 
 720:Drivers/CMSIS/Include/core_cm0.h **** 
 721:Drivers/CMSIS/Include/core_cm0.h **** /**
 722:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 723:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 724:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 725:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 726:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 727:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 728:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every processor exception.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 734              		.loc 2 730 22 view .LVU178
 735              	.LBB9:
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 736              		.loc 2 732 3 view .LVU179
 733:Drivers/CMSIS/Include/core_cm0.h ****   {
 734:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 737              		.loc 2 734 5 view .LVU180
 738              		.loc 2 734 52 is_stmt 0 view .LVU181
 739 0070 C420     		movs	r0, #196
 740 0072 8000     		lsls	r0, r0, #2
 741 0074 1958     		ldr	r1, [r3, r0]
 742              		.loc 2 734 33 view .LVU182
 743 0076 0A4A     		ldr	r2, .L28+28
 744 0078 1140     		ands	r1, r2
 745              		.loc 2 734 102 view .LVU183
 746 007a 8022     		movs	r2, #128
 747 007c 1202     		lsls	r2, r2, #8
 748 007e 0A43     		orrs	r2, r1
 749              		.loc 2 734 30 view .LVU184
 750 0080 1A50     		str	r2, [r3, r0]
 751              	.LVL43:
 752              		.loc 2 734 30 view .LVU185
 753              	.LBE9:
 754              	.LBE8:
 286:Src/motor.c   **** }
 755              		.loc 1 286 1 view .LVU186
ARM GAS  /tmp/cchCdSqb.s 			page 32


 756              		@ sp needed
 757 0082 70BD     		pop	{r4, r5, r6, pc}
 758              	.L29:
 759              		.align	2
 760              	.L28:
 761 0084 00100240 		.word	1073876992
 762 0088 00040040 		.word	1073742848
 763 008c FFFF0000 		.word	65535
 764 0090 FF7F0000 		.word	32767
 765 0094 00100040 		.word	1073745920
 766 0098 30750000 		.word	30000
 767 009c 00E100E0 		.word	-536813312
 768 00a0 FF00FFFF 		.word	-65281
 769              		.cfi_endproc
 770              	.LFE54:
 772              		.section	.text.motor_init,"ax",%progbits
 773              		.align	1
 774              		.global	motor_init
 775              		.syntax unified
 776              		.code	16
 777              		.thumb_func
 779              	motor_init:
 780              	.LFB43:
  16:Src/motor.c   ****     pwm_init();
 781              		.loc 1 16 23 is_stmt 1 view -0
 782              		.cfi_startproc
 783              		@ args = 0, pretend = 0, frame = 0
 784              		@ frame_needed = 0, uses_anonymous_args = 0
 785 0000 10B5     		push	{r4, lr}
 786              	.LCFI10:
 787              		.cfi_def_cfa_offset 8
 788              		.cfi_offset 4, -8
 789              		.cfi_offset 14, -4
  17:Src/motor.c   ****     encoder_init();
 790              		.loc 1 17 5 view .LVU188
 791 0002 FFF7FEFF 		bl	pwm_init
 792              	.LVL44:
  18:Src/motor.c   **** }
 793              		.loc 1 18 5 view .LVU189
 794 0006 FFF7FEFF 		bl	encoder_init
 795              	.LVL45:
  19:Src/motor.c   **** 
 796              		.loc 1 19 1 is_stmt 0 view .LVU190
 797              		@ sp needed
 798 000a 10BD     		pop	{r4, pc}
 799              		.cfi_endproc
 800              	.LFE43:
 802              		.global	__aeabi_i2f
 803              		.global	__aeabi_fdiv
 804              		.global	__aeabi_fmul
 805              		.global	__aeabi_f2iz
 806              		.global	__aeabi_fadd
 807              		.global	__aeabi_f2uiz
 808              		.global	__aeabi_f2d
 809              		.global	__aeabi_d2f
 810              		.section	.text.TIM6_DAC_IRQHandler,"ax",%progbits
 811              		.align	1
ARM GAS  /tmp/cchCdSqb.s 			page 33


 812              		.global	TIM6_DAC_IRQHandler
 813              		.syntax unified
 814              		.code	16
 815              		.thumb_func
 817              	TIM6_DAC_IRQHandler:
 818              	.LFB55:
 287:Src/motor.c   **** 
 288:Src/motor.c   **** // Encoder interrupt to calculate motor speed, also manages PI controller
 289:Src/motor.c   **** void TIM6_DAC_IRQHandler(void) {
 819              		.loc 1 289 32 is_stmt 1 view -0
 820              		.cfi_startproc
 821              		@ args = 0, pretend = 0, frame = 0
 822              		@ frame_needed = 0, uses_anonymous_args = 0
 823 0000 70B5     		push	{r4, r5, r6, lr}
 824              	.LCFI11:
 825              		.cfi_def_cfa_offset 16
 826              		.cfi_offset 4, -16
 827              		.cfi_offset 5, -12
 828              		.cfi_offset 6, -8
 829              		.cfi_offset 14, -4
 290:Src/motor.c   ****     /* Calculate the motor speed in raw encoder counts
 291:Src/motor.c   ****      * Note the motor speed is signed! Motor can be run in reverse.
 292:Src/motor.c   ****      * Speed is measured by how far the counter moved from center point
 293:Src/motor.c   ****      */
 294:Src/motor.c   ****     motorl_speed = (TIM3->CNT - 0x7FFF);
 830              		.loc 1 294 5 view .LVU192
 831              		.loc 1 294 25 is_stmt 0 view .LVU193
 832 0002 3E49     		ldr	r1, .L36
 833 0004 4B6A     		ldr	r3, [r1, #36]
 834              		.loc 1 294 31 view .LVU194
 835 0006 3E4A     		ldr	r2, .L36+4
 836 0008 9446     		mov	ip, r2
 837 000a 6344     		add	r3, r3, ip
 838 000c 1BB2     		sxth	r3, r3
 839              		.loc 1 294 18 view .LVU195
 840 000e 3D4A     		ldr	r2, .L36+8
 841 0010 1380     		strh	r3, [r2]
 295:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 842              		.loc 1 295 5 is_stmt 1 view .LVU196
 843              		.loc 1 295 15 is_stmt 0 view .LVU197
 844 0012 3D48     		ldr	r0, .L36+12
 845 0014 4862     		str	r0, [r1, #36]
 296:Src/motor.c   **** 	motorr_speed = (TIM15->CNT - 0x7FFF);
 846              		.loc 1 296 2 is_stmt 1 view .LVU198
 847              		.loc 1 296 23 is_stmt 0 view .LVU199
 848 0016 3D49     		ldr	r1, .L36+16
 849 0018 4B6A     		ldr	r3, [r1, #36]
 850              		.loc 1 296 29 view .LVU200
 851 001a 6344     		add	r3, r3, ip
 852 001c 1BB2     		sxth	r3, r3
 853              		.loc 1 296 15 view .LVU201
 854 001e 3C4C     		ldr	r4, .L36+20
 855 0020 2380     		strh	r3, [r4]
 297:Src/motor.c   ****     TIM15->CNT = 0x7FFF; // Reset back to center point
 856              		.loc 1 297 5 is_stmt 1 view .LVU202
 857              		.loc 1 297 16 is_stmt 0 view .LVU203
 858 0022 4862     		str	r0, [r1, #36]
ARM GAS  /tmp/cchCdSqb.s 			page 34


 298:Src/motor.c   **** 	
 299:Src/motor.c   **** 	if(abs(motorl_speed)>10){
 859              		.loc 1 299 2 is_stmt 1 view .LVU204
 860              		.loc 1 299 5 is_stmt 0 view .LVU205
 861 0024 1388     		ldrh	r3, [r2]
 862 0026 1BB2     		sxth	r3, r3
 863 0028 DA17     		asrs	r2, r3, #31
 864 002a 9B18     		adds	r3, r3, r2
 865 002c 5340     		eors	r3, r2
 866 002e 9BB2     		uxth	r3, r3
 867              		.loc 1 299 4 view .LVU206
 868 0030 0A2B     		cmp	r3, #10
 869 0032 1FD9     		bls	.L32
 870              	.LBB10:
 300:Src/motor.c   **** 		float ratio = ((float) abs(motorl_speed))/ ((float) motorr_speed);
 871              		.loc 1 300 3 is_stmt 1 view .LVU207
 872              		.loc 1 300 26 is_stmt 0 view .LVU208
 873 0034 334B     		ldr	r3, .L36+8
 874 0036 1888     		ldrh	r0, [r3]
 875 0038 00B2     		sxth	r0, r0
 876 003a C317     		asrs	r3, r0, #31
 877 003c C018     		adds	r0, r0, r3
 878 003e 5840     		eors	r0, r3
 879 0040 80B2     		uxth	r0, r0
 880              		.loc 1 300 18 view .LVU209
 881 0042 FFF7FEFF 		bl	__aeabi_i2f
 882              	.LVL46:
 883 0046 041C     		adds	r4, r0, #0
 884              		.loc 1 300 47 view .LVU210
 885 0048 314B     		ldr	r3, .L36+20
 886 004a 1888     		ldrh	r0, [r3]
 887 004c 00B2     		sxth	r0, r0
 888 004e FFF7FEFF 		bl	__aeabi_i2f
 889              	.LVL47:
 890 0052 011C     		adds	r1, r0, #0
 891              		.loc 1 300 9 view .LVU211
 892 0054 201C     		adds	r0, r4, #0
 893 0056 FFF7FEFF 		bl	__aeabi_fdiv
 894              	.LVL48:
 895 005a 041C     		adds	r4, r0, #0
 896              	.LVL49:
 301:Src/motor.c   **** 		pwm_right = (int)(pwm_right * ratio);
 897              		.loc 1 301 3 is_stmt 1 view .LVU212
 898              		.loc 1 301 31 is_stmt 0 view .LVU213
 899 005c 2D4D     		ldr	r5, .L36+24
 900 005e 2878     		ldrb	r0, [r5]
 901              	.LVL50:
 902              		.loc 1 301 31 view .LVU214
 903 0060 C0B2     		uxtb	r0, r0
 904 0062 FFF7FEFF 		bl	__aeabi_i2f
 905              	.LVL51:
 906 0066 211C     		adds	r1, r4, #0
 907 0068 FFF7FEFF 		bl	__aeabi_fmul
 908              	.LVL52:
 909              		.loc 1 301 15 view .LVU215
 910 006c FFF7FEFF 		bl	__aeabi_f2iz
 911              	.LVL53:
ARM GAS  /tmp/cchCdSqb.s 			page 35


 912              		.loc 1 301 13 view .LVU216
 913 0070 C0B2     		uxtb	r0, r0
 914 0072 2870     		strb	r0, [r5]
 915              	.LVL54:
 916              	.L32:
 917              		.loc 1 301 13 view .LVU217
 918              	.LBE10:
 302:Src/motor.c   **** 	}
 303:Src/motor.c   **** 	
 304:Src/motor.c   **** 	if(target_dist > 0){
 919              		.loc 1 304 2 is_stmt 1 view .LVU218
 920              		.loc 1 304 17 is_stmt 0 view .LVU219
 921 0074 284B     		ldr	r3, .L36+28
 922 0076 1B78     		ldrb	r3, [r3]
 923              		.loc 1 304 4 view .LVU220
 924 0078 002B     		cmp	r3, #0
 925 007a 1AD0     		beq	.L33
 305:Src/motor.c   **** 		current_dist += (float)abs(motorl_speed)/70;
 926              		.loc 1 305 3 is_stmt 1 view .LVU221
 927              		.loc 1 305 26 is_stmt 0 view .LVU222
 928 007c 214B     		ldr	r3, .L36+8
 929 007e 1888     		ldrh	r0, [r3]
 930 0080 00B2     		sxth	r0, r0
 931 0082 C317     		asrs	r3, r0, #31
 932 0084 C018     		adds	r0, r0, r3
 933 0086 5840     		eors	r0, r3
 934 0088 80B2     		uxth	r0, r0
 935              		.loc 1 305 19 view .LVU223
 936 008a FFF7FEFF 		bl	__aeabi_i2f
 937              	.LVL55:
 938              		.loc 1 305 43 view .LVU224
 939 008e 2349     		ldr	r1, .L36+32
 940 0090 FFF7FEFF 		bl	__aeabi_fdiv
 941              	.LVL56:
 942 0094 011C     		adds	r1, r0, #0
 943              		.loc 1 305 16 view .LVU225
 944 0096 224C     		ldr	r4, .L36+36
 945 0098 2068     		ldr	r0, [r4]
 946 009a FFF7FEFF 		bl	__aeabi_fadd
 947              	.LVL57:
 948 009e 2060     		str	r0, [r4]
 306:Src/motor.c   **** 		if ((uint8_t)current_dist >= target_dist){
 949              		.loc 1 306 3 is_stmt 1 view .LVU226
 950              		.loc 1 306 7 is_stmt 0 view .LVU227
 951 00a0 2068     		ldr	r0, [r4]
 952 00a2 FFF7FEFF 		bl	__aeabi_f2uiz
 953              	.LVL58:
 954 00a6 C0B2     		uxtb	r0, r0
 955              		.loc 1 306 29 view .LVU228
 956 00a8 1B4B     		ldr	r3, .L36+28
 957 00aa 1B78     		ldrb	r3, [r3]
 958 00ac DBB2     		uxtb	r3, r3
 959              		.loc 1 306 6 view .LVU229
 960 00ae 9842     		cmp	r0, r3
 961 00b0 05D2     		bcs	.L35
 962              	.L33:
 307:Src/motor.c   **** 			motors_Off();
ARM GAS  /tmp/cchCdSqb.s 			page 36


 308:Src/motor.c   **** 			if(!turning){
 309:Src/motor.c   **** 				absolute_dist += current_dist * (float)sin((double)heading);
 310:Src/motor.c   **** 			}
 311:Src/motor.c   **** 			target_dist = 0;
 312:Src/motor.c   **** 			current_dist = 0;
 313:Src/motor.c   **** 		}
 314:Src/motor.c   **** 	}
 315:Src/motor.c   ****     
 316:Src/motor.c   ****     // Call the PI update function
 317:Src/motor.c   ****     TIM6->SR &= ~TIM_SR_UIF;        // Acknowledge the interrupt
 963              		.loc 1 317 5 is_stmt 1 view .LVU230
 964              		.loc 1 317 9 is_stmt 0 view .LVU231
 965 00b2 1C4A     		ldr	r2, .L36+40
 966 00b4 1369     		ldr	r3, [r2, #16]
 967              		.loc 1 317 14 view .LVU232
 968 00b6 0121     		movs	r1, #1
 969 00b8 8B43     		bics	r3, r1
 970 00ba 1361     		str	r3, [r2, #16]
 318:Src/motor.c   **** }
 971              		.loc 1 318 1 view .LVU233
 972              		@ sp needed
 973 00bc 70BD     		pop	{r4, r5, r6, pc}
 974              	.L35:
 307:Src/motor.c   **** 			motors_Off();
 975              		.loc 1 307 4 is_stmt 1 view .LVU234
 976 00be FFF7FEFF 		bl	motors_Off
 977              	.LVL59:
 308:Src/motor.c   **** 				absolute_dist += current_dist * (float)sin((double)heading);
 978              		.loc 1 308 4 view .LVU235
 308:Src/motor.c   **** 				absolute_dist += current_dist * (float)sin((double)heading);
 979              		.loc 1 308 7 is_stmt 0 view .LVU236
 980 00c2 194B     		ldr	r3, .L36+44
 981 00c4 1B78     		ldrb	r3, [r3]
 308:Src/motor.c   **** 				absolute_dist += current_dist * (float)sin((double)heading);
 982              		.loc 1 308 6 view .LVU237
 983 00c6 002B     		cmp	r3, #0
 984 00c8 11D1     		bne	.L34
 309:Src/motor.c   **** 			}
 985              		.loc 1 309 5 is_stmt 1 view .LVU238
 309:Src/motor.c   **** 			}
 986              		.loc 1 309 44 is_stmt 0 view .LVU239
 987 00ca 184B     		ldr	r3, .L36+48
 988 00cc 1868     		ldr	r0, [r3]
 989 00ce FFF7FEFF 		bl	__aeabi_f2d
 990              	.LVL60:
 991 00d2 FFF7FEFF 		bl	sin
 992              	.LVL61:
 309:Src/motor.c   **** 			}
 993              		.loc 1 309 37 view .LVU240
 994 00d6 FFF7FEFF 		bl	__aeabi_d2f
 995              	.LVL62:
 309:Src/motor.c   **** 			}
 996              		.loc 1 309 35 view .LVU241
 997 00da 114B     		ldr	r3, .L36+36
 998 00dc 1968     		ldr	r1, [r3]
 999 00de FFF7FEFF 		bl	__aeabi_fmul
 1000              	.LVL63:
ARM GAS  /tmp/cchCdSqb.s 			page 37


 1001 00e2 011C     		adds	r1, r0, #0
 309:Src/motor.c   **** 			}
 1002              		.loc 1 309 19 view .LVU242
 1003 00e4 124C     		ldr	r4, .L36+52
 1004 00e6 2068     		ldr	r0, [r4]
 1005 00e8 FFF7FEFF 		bl	__aeabi_fadd
 1006              	.LVL64:
 1007 00ec 2060     		str	r0, [r4]
 1008              	.L34:
 311:Src/motor.c   **** 			current_dist = 0;
 1009              		.loc 1 311 4 is_stmt 1 view .LVU243
 311:Src/motor.c   **** 			current_dist = 0;
 1010              		.loc 1 311 16 is_stmt 0 view .LVU244
 1011 00ee 0A4B     		ldr	r3, .L36+28
 1012 00f0 0022     		movs	r2, #0
 1013 00f2 1A70     		strb	r2, [r3]
 312:Src/motor.c   **** 		}
 1014              		.loc 1 312 4 is_stmt 1 view .LVU245
 312:Src/motor.c   **** 		}
 1015              		.loc 1 312 17 is_stmt 0 view .LVU246
 1016 00f4 0A4B     		ldr	r3, .L36+36
 1017 00f6 0022     		movs	r2, #0
 1018 00f8 1A60     		str	r2, [r3]
 1019 00fa DAE7     		b	.L33
 1020              	.L37:
 1021              		.align	2
 1022              	.L36:
 1023 00fc 00040040 		.word	1073742848
 1024 0100 0180FFFF 		.word	-32767
 1025 0104 00000000 		.word	motorl_speed
 1026 0108 FF7F0000 		.word	32767
 1027 010c 00400140 		.word	1073823744
 1028 0110 00000000 		.word	motorr_speed
 1029 0114 00000000 		.word	pwm_right
 1030 0118 00000000 		.word	target_dist
 1031 011c 00008C42 		.word	1116471296
 1032 0120 00000000 		.word	current_dist
 1033 0124 00100040 		.word	1073745920
 1034 0128 00000000 		.word	turning
 1035 012c 00000000 		.word	heading
 1036 0130 00000000 		.word	absolute_dist
 1037              		.cfi_endproc
 1038              	.LFE55:
 1040              		.section	.text.get_distance,"ax",%progbits
 1041              		.align	1
 1042              		.global	get_distance
 1043              		.syntax unified
 1044              		.code	16
 1045              		.thumb_func
 1047              	get_distance:
 1048              	.LFB56:
 319:Src/motor.c   **** 
 320:Src/motor.c   **** float get_distance(void){
 1049              		.loc 1 320 25 is_stmt 1 view -0
 1050              		.cfi_startproc
 1051              		@ args = 0, pretend = 0, frame = 0
 1052              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cchCdSqb.s 			page 38


 1053              		@ link register save eliminated.
 321:Src/motor.c   **** 	return absolute_dist;
 1054              		.loc 1 321 2 view .LVU248
 1055              		.loc 1 321 9 is_stmt 0 view .LVU249
 1056 0000 014B     		ldr	r3, .L39
 1057 0002 1868     		ldr	r0, [r3]
 322:Src/motor.c   **** }
 1058              		.loc 1 322 1 view .LVU250
 1059              		@ sp needed
 1060 0004 7047     		bx	lr
 1061              	.L40:
 1062 0006 C046     		.align	2
 1063              	.L39:
 1064 0008 00000000 		.word	absolute_dist
 1065              		.cfi_endproc
 1066              	.LFE56:
 1068              		.section	.rodata.MoveMotors.str1.4,"aMS",%progbits,1
 1069              		.align	2
 1070              	.LC28:
 1071 0000 4D6F7665 		.ascii	"MoveMotors executed!\012\000"
 1071      4D6F746F 
 1071      72732065 
 1071      78656375 
 1071      74656421 
 1072 0016 0000     		.align	2
 1073              	.LC30:
 1074 0018 496E7661 		.ascii	"Invalid command to MoveMotors!\012\000"
 1074      6C696420 
 1074      636F6D6D 
 1074      616E6420 
 1074      746F204D 
 1075              		.global	__aeabi_i2d
 1076              		.global	__aeabi_ddiv
 1077              		.global	__aeabi_d2uiz
 1078              		.global	__aeabi_fsub
 1079              		.global	__aeabi_fcmplt
 1080              		.section	.text.MoveMotors,"ax",%progbits
 1081              		.align	1
 1082              		.global	MoveMotors
 1083              		.syntax unified
 1084              		.code	16
 1085              		.thumb_func
 1087              	MoveMotors:
 1088              	.LVL65:
 1089              	.LFB53:
 199:Src/motor.c   **** 	motors_Off();
 1090              		.loc 1 199 39 is_stmt 1 view -0
 1091              		.cfi_startproc
 1092              		@ args = 0, pretend = 0, frame = 0
 1093              		@ frame_needed = 0, uses_anonymous_args = 0
 199:Src/motor.c   **** 	motors_Off();
 1094              		.loc 1 199 39 is_stmt 0 view .LVU252
 1095 0000 70B5     		push	{r4, r5, r6, lr}
 1096              	.LCFI12:
 1097              		.cfi_def_cfa_offset 16
 1098              		.cfi_offset 4, -16
 1099              		.cfi_offset 5, -12
ARM GAS  /tmp/cchCdSqb.s 			page 39


 1100              		.cfi_offset 6, -8
 1101              		.cfi_offset 14, -4
 1102 0002 0400     		movs	r4, r0
 200:Src/motor.c   **** 	uint8_t* err = "MoveMotors executed!\n";
 1103              		.loc 1 200 2 is_stmt 1 view .LVU253
 1104 0004 FFF7FEFF 		bl	motors_Off
 1105              	.LVL66:
 201:Src/motor.c   **** 	switch(cmd->dir){
 1106              		.loc 1 201 2 view .LVU254
 202:Src/motor.c   **** 		case FORWARD:
 1107              		.loc 1 202 2 view .LVU255
 202:Src/motor.c   **** 		case FORWARD:
 1108              		.loc 1 202 12 is_stmt 0 view .LVU256
 1109 0008 2378     		ldrb	r3, [r4]
 202:Src/motor.c   **** 		case FORWARD:
 1110              		.loc 1 202 2 view .LVU257
 1111 000a 022B     		cmp	r3, #2
 1112 000c 46D0     		beq	.L42
 1113 000e 22D8     		bhi	.L43
 1114 0010 002B     		cmp	r3, #0
 1115 0012 39D0     		beq	.L44
 1116 0014 012B     		cmp	r3, #1
 1117 0016 1CD1     		bne	.L49
 209:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 1118              		.loc 1 209 4 is_stmt 1 view .LVU258
 209:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 1119              		.loc 1 209 12 is_stmt 0 view .LVU259
 1120 0018 2F4B     		ldr	r3, .L51
 1121 001a 0122     		movs	r2, #1
 1122 001c 1A70     		strb	r2, [r3]
 210:Src/motor.c   **** 			heading += cmd->amount;
 1123              		.loc 1 210 4 is_stmt 1 view .LVU260
 210:Src/motor.c   **** 			heading += cmd->amount;
 1124              		.loc 1 210 32 is_stmt 0 view .LVU261
 1125 001e 6478     		ldrb	r4, [r4, #1]
 1126              	.LVL67:
 210:Src/motor.c   **** 			heading += cmd->amount;
 1127              		.loc 1 210 41 view .LVU262
 1128 0020 2000     		movs	r0, r4
 1129 0022 FFF7FEFF 		bl	__aeabi_i2d
 1130              	.LVL68:
 1131 0026 0022     		movs	r2, #0
 1132 0028 2C4B     		ldr	r3, .L51+4
 1133 002a FFF7FEFF 		bl	__aeabi_ddiv
 1134              	.LVL69:
 210:Src/motor.c   **** 			heading += cmd->amount;
 1135              		.loc 1 210 18 view .LVU263
 1136 002e FFF7FEFF 		bl	__aeabi_d2uiz
 1137              	.LVL70:
 1138 0032 C0B2     		uxtb	r0, r0
 210:Src/motor.c   **** 			heading += cmd->amount;
 1139              		.loc 1 210 16 view .LVU264
 1140 0034 2A4B     		ldr	r3, .L51+8
 1141 0036 1870     		strb	r0, [r3]
 211:Src/motor.c   **** 			set_Left();
 1142              		.loc 1 211 4 is_stmt 1 view .LVU265
 211:Src/motor.c   **** 			set_Left();
ARM GAS  /tmp/cchCdSqb.s 			page 40


 1143              		.loc 1 211 12 is_stmt 0 view .LVU266
 1144 0038 2A4D     		ldr	r5, .L51+12
 1145 003a 2E68     		ldr	r6, [r5]
 1146 003c 2000     		movs	r0, r4
 1147 003e FFF7FEFF 		bl	__aeabi_i2f
 1148              	.LVL71:
 1149 0042 311C     		adds	r1, r6, #0
 1150 0044 FFF7FEFF 		bl	__aeabi_fadd
 1151              	.LVL72:
 1152 0048 2860     		str	r0, [r5]
 212:Src/motor.c   **** 			break;
 1153              		.loc 1 212 4 is_stmt 1 view .LVU267
 1154 004a FFF7FEFF 		bl	set_Left
 1155              	.LVL73:
 213:Src/motor.c   **** 		case RIGHT:
 1156              		.loc 1 213 4 view .LVU268
 201:Src/motor.c   **** 	switch(cmd->dir){
 1157              		.loc 1 201 11 is_stmt 0 view .LVU269
 1158 004e 264D     		ldr	r5, .L51+16
 213:Src/motor.c   **** 		case RIGHT:
 1159              		.loc 1 213 4 view .LVU270
 1160 0050 08E0     		b	.L48
 1161              	.LVL74:
 1162              	.L49:
 202:Src/motor.c   **** 		case FORWARD:
 1163              		.loc 1 202 2 view .LVU271
 1164 0052 264D     		ldr	r5, .L51+20
 1165 0054 06E0     		b	.L48
 1166              	.L43:
 1167 0056 042B     		cmp	r3, #4
 1168 0058 03D1     		bne	.L50
 221:Src/motor.c   **** 			break;
 1169              		.loc 1 221 4 is_stmt 1 view .LVU272
 1170 005a FFF7FEFF 		bl	motors_Off
 1171              	.LVL75:
 222:Src/motor.c   **** 		default:
 1172              		.loc 1 222 4 view .LVU273
 201:Src/motor.c   **** 	switch(cmd->dir){
 1173              		.loc 1 201 11 is_stmt 0 view .LVU274
 1174 005e 224D     		ldr	r5, .L51+16
 1175              	.LVL76:
 222:Src/motor.c   **** 		default:
 1176              		.loc 1 222 4 view .LVU275
 1177 0060 00E0     		b	.L48
 1178              	.LVL77:
 1179              	.L50:
 202:Src/motor.c   **** 		case FORWARD:
 1180              		.loc 1 202 2 view .LVU276
 1181 0062 224D     		ldr	r5, .L51+20
 1182              	.LVL78:
 1183              	.L48:
 228:Src/motor.c   **** 		;
 1184              		.loc 1 228 23 is_stmt 1 discriminator 1 view .LVU277
 228:Src/motor.c   **** 		;
 1185              		.loc 1 228 8 is_stmt 0 discriminator 1 view .LVU278
 1186 0064 FFF7FEFF 		bl	get_distance
 1187              	.LVL79:
ARM GAS  /tmp/cchCdSqb.s 			page 41


 1188 0068 041C     		adds	r4, r0, #0
 228:Src/motor.c   **** 		;
 1189              		.loc 1 228 23 discriminator 1 view .LVU279
 1190 006a 1D4B     		ldr	r3, .L51+8
 1191 006c 1878     		ldrb	r0, [r3]
 1192 006e C0B2     		uxtb	r0, r0
 1193 0070 FFF7FEFF 		bl	__aeabi_i2f
 1194              	.LVL80:
 1195 0074 011C     		adds	r1, r0, #0
 1196 0076 201C     		adds	r0, r4, #0
 1197 0078 FFF7FEFF 		bl	__aeabi_fcmplt
 1198              	.LVL81:
 1199 007c 0028     		cmp	r0, #0
 1200 007e F1D1     		bne	.L48
 230:Src/motor.c   **** 	return err;
 1201              		.loc 1 230 2 is_stmt 1 view .LVU280
 1202 0080 FFF7FEFF 		bl	motors_Off
 1203              	.LVL82:
 231:Src/motor.c   **** }
 1204              		.loc 1 231 2 view .LVU281
 232:Src/motor.c   **** 
 1205              		.loc 1 232 1 is_stmt 0 view .LVU282
 1206 0084 2800     		movs	r0, r5
 1207              		@ sp needed
 1208              	.LVL83:
 232:Src/motor.c   **** 
 1209              		.loc 1 232 1 view .LVU283
 1210 0086 70BD     		pop	{r4, r5, r6, pc}
 1211              	.LVL84:
 1212              	.L44:
 204:Src/motor.c   **** 			target_dist = cmd->amount;
 1213              		.loc 1 204 4 is_stmt 1 view .LVU284
 204:Src/motor.c   **** 			target_dist = cmd->amount;
 1214              		.loc 1 204 12 is_stmt 0 view .LVU285
 1215 0088 134B     		ldr	r3, .L51
 1216 008a 0022     		movs	r2, #0
 1217 008c 1A70     		strb	r2, [r3]
 205:Src/motor.c   **** 			set_Forward();
 1218              		.loc 1 205 4 is_stmt 1 view .LVU286
 205:Src/motor.c   **** 			set_Forward();
 1219              		.loc 1 205 21 is_stmt 0 view .LVU287
 1220 008e 6278     		ldrb	r2, [r4, #1]
 205:Src/motor.c   **** 			set_Forward();
 1221              		.loc 1 205 16 view .LVU288
 1222 0090 134B     		ldr	r3, .L51+8
 1223 0092 1A70     		strb	r2, [r3]
 206:Src/motor.c   **** 			break;
 1224              		.loc 1 206 4 is_stmt 1 view .LVU289
 1225 0094 FFF7FEFF 		bl	set_Forward
 1226              	.LVL85:
 207:Src/motor.c   **** 		case LEFT:
 1227              		.loc 1 207 4 view .LVU290
 201:Src/motor.c   **** 	switch(cmd->dir){
 1228              		.loc 1 201 11 is_stmt 0 view .LVU291
 1229 0098 134D     		ldr	r5, .L51+16
 207:Src/motor.c   **** 		case LEFT:
 1230              		.loc 1 207 4 view .LVU292
ARM GAS  /tmp/cchCdSqb.s 			page 42


 1231 009a E3E7     		b	.L48
 1232              	.L42:
 215:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 1233              		.loc 1 215 4 is_stmt 1 view .LVU293
 215:Src/motor.c   **** 			target_dist = (uint8_t) (cmd->amount / 11.5);
 1234              		.loc 1 215 12 is_stmt 0 view .LVU294
 1235 009c 0E4B     		ldr	r3, .L51
 1236 009e 0122     		movs	r2, #1
 1237 00a0 1A70     		strb	r2, [r3]
 216:Src/motor.c   **** 			heading -= cmd->amount;
 1238              		.loc 1 216 4 is_stmt 1 view .LVU295
 216:Src/motor.c   **** 			heading -= cmd->amount;
 1239              		.loc 1 216 32 is_stmt 0 view .LVU296
 1240 00a2 6478     		ldrb	r4, [r4, #1]
 1241              	.LVL86:
 216:Src/motor.c   **** 			heading -= cmd->amount;
 1242              		.loc 1 216 41 view .LVU297
 1243 00a4 2000     		movs	r0, r4
 1244 00a6 FFF7FEFF 		bl	__aeabi_i2d
 1245              	.LVL87:
 1246 00aa 0022     		movs	r2, #0
 1247 00ac 0B4B     		ldr	r3, .L51+4
 1248 00ae FFF7FEFF 		bl	__aeabi_ddiv
 1249              	.LVL88:
 216:Src/motor.c   **** 			heading -= cmd->amount;
 1250              		.loc 1 216 18 view .LVU298
 1251 00b2 FFF7FEFF 		bl	__aeabi_d2uiz
 1252              	.LVL89:
 1253 00b6 C0B2     		uxtb	r0, r0
 216:Src/motor.c   **** 			heading -= cmd->amount;
 1254              		.loc 1 216 16 view .LVU299
 1255 00b8 094B     		ldr	r3, .L51+8
 1256 00ba 1870     		strb	r0, [r3]
 217:Src/motor.c   **** 			set_Right();
 1257              		.loc 1 217 4 is_stmt 1 view .LVU300
 217:Src/motor.c   **** 			set_Right();
 1258              		.loc 1 217 12 is_stmt 0 view .LVU301
 1259 00bc 094D     		ldr	r5, .L51+12
 1260 00be 2E68     		ldr	r6, [r5]
 1261 00c0 2000     		movs	r0, r4
 1262 00c2 FFF7FEFF 		bl	__aeabi_i2f
 1263              	.LVL90:
 1264 00c6 011C     		adds	r1, r0, #0
 1265 00c8 301C     		adds	r0, r6, #0
 1266 00ca FFF7FEFF 		bl	__aeabi_fsub
 1267              	.LVL91:
 1268 00ce 2860     		str	r0, [r5]
 218:Src/motor.c   **** 			break;
 1269              		.loc 1 218 4 is_stmt 1 view .LVU302
 1270 00d0 FFF7FEFF 		bl	set_Right
 1271              	.LVL92:
 219:Src/motor.c   **** 		case OFF:
 1272              		.loc 1 219 4 view .LVU303
 201:Src/motor.c   **** 	switch(cmd->dir){
 1273              		.loc 1 201 11 is_stmt 0 view .LVU304
 1274 00d4 044D     		ldr	r5, .L51+16
 219:Src/motor.c   **** 		case OFF:
ARM GAS  /tmp/cchCdSqb.s 			page 43


 1275              		.loc 1 219 4 view .LVU305
 1276 00d6 C5E7     		b	.L48
 1277              	.L52:
 1278              		.align	2
 1279              	.L51:
 1280 00d8 00000000 		.word	turning
 1281 00dc 00002740 		.word	1076297728
 1282 00e0 00000000 		.word	target_dist
 1283 00e4 00000000 		.word	heading
 1284 00e8 00000000 		.word	.LC28
 1285 00ec 18000000 		.word	.LC30
 1286              		.cfi_endproc
 1287              	.LFE53:
 1289              		.global	pwm_left
 1290              		.section	.data.pwm_left,"aw"
 1293              	pwm_left:
 1294 0000 64       		.byte	100
 1295              		.global	pwm_right
 1296              		.section	.data.pwm_right,"aw"
 1299              	pwm_right:
 1300 0000 64       		.byte	100
 1301              		.global	turning
 1302              		.section	.bss.turning,"aw",%nobits
 1305              	turning:
 1306 0000 00       		.space	1
 1307              		.global	heading
 1308              		.section	.bss.heading,"aw",%nobits
 1309              		.align	2
 1312              	heading:
 1313 0000 00000000 		.space	4
 1314              		.global	absolute_dist
 1315              		.section	.bss.absolute_dist,"aw",%nobits
 1316              		.align	2
 1319              	absolute_dist:
 1320 0000 00000000 		.space	4
 1321              		.global	current_dist
 1322              		.section	.bss.current_dist,"aw",%nobits
 1323              		.align	2
 1326              	current_dist:
 1327 0000 00000000 		.space	4
 1328              		.global	target_dist
 1329              		.section	.bss.target_dist,"aw",%nobits
 1332              	target_dist:
 1333 0000 00       		.space	1
 1334              		.global	motorr_speed
 1335              		.section	.bss.motorr_speed,"aw",%nobits
 1336              		.align	1
 1339              	motorr_speed:
 1340 0000 0000     		.space	2
 1341              		.global	motorl_speed
 1342              		.section	.bss.motorl_speed,"aw",%nobits
 1343              		.align	1
 1346              	motorl_speed:
 1347 0000 0000     		.space	2
 1348              		.text
 1349              	.Letext0:
 1350              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
ARM GAS  /tmp/cchCdSqb.s 			page 44


 1351              		.file 4 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
 1352              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1353              		.file 6 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h"
 1354              		.file 7 "Inc/pins.h"
 1355              		.file 8 "Inc/motor.h"
 1356              		.file 9 "/usr/arm-none-eabi/include/math.h"
ARM GAS  /tmp/cchCdSqb.s 			page 45


DEFINED SYMBOLS
                            *ABS*:00000000 motor.c
     /tmp/cchCdSqb.s:19     .text.pwm_init:00000000 $t
     /tmp/cchCdSqb.s:25     .text.pwm_init:00000000 pwm_init
     /tmp/cchCdSqb.s:172    .text.pwm_init:00000094 $d
     /tmp/cchCdSqb.s:181    .text.pwm_setDutyCycleL:00000000 $t
     /tmp/cchCdSqb.s:187    .text.pwm_setDutyCycleL:00000000 pwm_setDutyCycleL
     /tmp/cchCdSqb.s:224    .text.pwm_setDutyCycleL:00000018 $d
     /tmp/cchCdSqb.s:229    .text.pwm_setDutyCycleR:00000000 $t
     /tmp/cchCdSqb.s:235    .text.pwm_setDutyCycleR:00000000 pwm_setDutyCycleR
     /tmp/cchCdSqb.s:274    .text.set_Motor_Direction:00000000 $t
     /tmp/cchCdSqb.s:280    .text.set_Motor_Direction:00000000 set_Motor_Direction
     /tmp/cchCdSqb.s:352    .text.set_Forward:00000000 $t
     /tmp/cchCdSqb.s:358    .text.set_Forward:00000000 set_Forward
     /tmp/cchCdSqb.s:397    .text.set_Forward:00000028 $d
     /tmp/cchCdSqb.s:1299   .data.pwm_right:00000000 pwm_right
     /tmp/cchCdSqb.s:1293   .data.pwm_left:00000000 pwm_left
     /tmp/cchCdSqb.s:405    .text.set_Backward:00000000 $t
     /tmp/cchCdSqb.s:411    .text.set_Backward:00000000 set_Backward
     /tmp/cchCdSqb.s:450    .text.set_Backward:00000028 $d
     /tmp/cchCdSqb.s:458    .text.set_Right:00000000 $t
     /tmp/cchCdSqb.s:464    .text.set_Right:00000000 set_Right
     /tmp/cchCdSqb.s:503    .text.set_Right:00000028 $d
     /tmp/cchCdSqb.s:511    .text.set_Left:00000000 $t
     /tmp/cchCdSqb.s:517    .text.set_Left:00000000 set_Left
     /tmp/cchCdSqb.s:556    .text.set_Left:00000028 $d
     /tmp/cchCdSqb.s:564    .text.motors_Off:00000000 $t
     /tmp/cchCdSqb.s:570    .text.motors_Off:00000000 motors_Off
     /tmp/cchCdSqb.s:596    .text.encoder_init:00000000 $t
     /tmp/cchCdSqb.s:602    .text.encoder_init:00000000 encoder_init
     /tmp/cchCdSqb.s:761    .text.encoder_init:00000084 $d
     /tmp/cchCdSqb.s:773    .text.motor_init:00000000 $t
     /tmp/cchCdSqb.s:779    .text.motor_init:00000000 motor_init
     /tmp/cchCdSqb.s:811    .text.TIM6_DAC_IRQHandler:00000000 $t
     /tmp/cchCdSqb.s:817    .text.TIM6_DAC_IRQHandler:00000000 TIM6_DAC_IRQHandler
     /tmp/cchCdSqb.s:1023   .text.TIM6_DAC_IRQHandler:000000fc $d
     /tmp/cchCdSqb.s:1346   .bss.motorl_speed:00000000 motorl_speed
     /tmp/cchCdSqb.s:1339   .bss.motorr_speed:00000000 motorr_speed
     /tmp/cchCdSqb.s:1332   .bss.target_dist:00000000 target_dist
     /tmp/cchCdSqb.s:1326   .bss.current_dist:00000000 current_dist
     /tmp/cchCdSqb.s:1305   .bss.turning:00000000 turning
     /tmp/cchCdSqb.s:1312   .bss.heading:00000000 heading
     /tmp/cchCdSqb.s:1319   .bss.absolute_dist:00000000 absolute_dist
     /tmp/cchCdSqb.s:1041   .text.get_distance:00000000 $t
     /tmp/cchCdSqb.s:1047   .text.get_distance:00000000 get_distance
     /tmp/cchCdSqb.s:1064   .text.get_distance:00000008 $d
     /tmp/cchCdSqb.s:1069   .rodata.MoveMotors.str1.4:00000000 $d
     /tmp/cchCdSqb.s:1081   .text.MoveMotors:00000000 $t
     /tmp/cchCdSqb.s:1087   .text.MoveMotors:00000000 MoveMotors
     /tmp/cchCdSqb.s:1280   .text.MoveMotors:000000d8 $d
     /tmp/cchCdSqb.s:1306   .bss.turning:00000000 $d
     /tmp/cchCdSqb.s:1309   .bss.heading:00000000 $d
     /tmp/cchCdSqb.s:1316   .bss.absolute_dist:00000000 $d
     /tmp/cchCdSqb.s:1323   .bss.current_dist:00000000 $d
     /tmp/cchCdSqb.s:1333   .bss.target_dist:00000000 $d
     /tmp/cchCdSqb.s:1336   .bss.motorr_speed:00000000 $d
     /tmp/cchCdSqb.s:1343   .bss.motorl_speed:00000000 $d
ARM GAS  /tmp/cchCdSqb.s 			page 46



UNDEFINED SYMBOLS
HAL_GPIO_WritePin
motor_left_pins
motor_right_pins
__aeabi_uidiv
__aeabi_i2f
__aeabi_fdiv
__aeabi_fmul
__aeabi_f2iz
__aeabi_fadd
__aeabi_f2uiz
__aeabi_f2d
__aeabi_d2f
sin
__aeabi_i2d
__aeabi_ddiv
__aeabi_d2uiz
__aeabi_fsub
__aeabi_fcmplt
